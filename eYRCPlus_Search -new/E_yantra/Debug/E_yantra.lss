
E_yantra.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000010c  00800200  00002e0a  00002e9e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e0a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001cd  0080030c  0080030c  00002faa  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  00002fac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  000063a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00006d58  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000024a6  00000000  00000000  00006e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000455  00000000  00000000  000092de  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b43  00000000  00000000  00009733  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000988  00000000  00000000  0000a278  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009d8  00000000  00000000  0000ac00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000013b1  00000000  00000000  0000b5d8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 af 03 	jmp	0x75e	; 0x75e <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 8a 03 	jmp	0x714	; 0x714 <__vector_5>
      18:	0c 94 65 03 	jmp	0x6ca	; 0x6ca <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 5a 10 	jmp	0x20b4	; 0x20b4 <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <timer1_init+0x42>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	13 e0       	ldi	r17, 0x03	; 3
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ea e0       	ldi	r30, 0x0A	; 10
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ac 30       	cpi	r26, 0x0C	; 12
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	14 e0       	ldi	r17, 0x04	; 4
     192:	ac e0       	ldi	r26, 0x0C	; 12
     194:	b3 e0       	ldi	r27, 0x03	; 3
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a9 3d       	cpi	r26, 0xD9	; 217
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 34 13 	call	0x2668	; 0x2668 <main>
     1a4:	0c 94 03 17 	jmp	0x2e06	; 0x2e06 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <avoid_collision>:
unsigned int got_first_cordinate=0;
unsigned int previous,prev_rescue_x,prev_rescue_y;
void avoid_collision (void)
{
	//restore
  if ( got_first_cordinate)
     1ac:	80 91 10 03 	lds	r24, 0x0310
     1b0:	90 91 11 03 	lds	r25, 0x0311
     1b4:	00 97       	sbiw	r24, 0x00	; 0
     1b6:	19 f1       	breq	.+70     	; 0x1fe <avoid_collision+0x52>
  {
    path_log[prev_rescue_x][prev_rescue_y] =previous;
     1b8:	80 91 52 03 	lds	r24, 0x0352
     1bc:	90 91 53 03 	lds	r25, 0x0353
     1c0:	fc 01       	movw	r30, r24
     1c2:	ee 0f       	add	r30, r30
     1c4:	ff 1f       	adc	r31, r31
     1c6:	9c 01       	movw	r18, r24
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	22 0f       	add	r18, r18
     1ce:	33 1f       	adc	r19, r19
     1d0:	22 0f       	add	r18, r18
     1d2:	33 1f       	adc	r19, r19
     1d4:	e2 0f       	add	r30, r18
     1d6:	f3 1f       	adc	r31, r19
     1d8:	8e 0f       	add	r24, r30
     1da:	9f 1f       	adc	r25, r31
     1dc:	20 91 c2 04 	lds	r18, 0x04C2
     1e0:	30 91 c3 04 	lds	r19, 0x04C3
     1e4:	82 0f       	add	r24, r18
     1e6:	93 1f       	adc	r25, r19
     1e8:	fc 01       	movw	r30, r24
     1ea:	ee 0f       	add	r30, r30
     1ec:	ff 1f       	adc	r31, r31
     1ee:	e8 5f       	subi	r30, 0xF8	; 248
     1f0:	fd 4f       	sbci	r31, 0xFD	; 253
     1f2:	80 91 bd 04 	lds	r24, 0x04BD
     1f6:	90 91 be 04 	lds	r25, 0x04BE
     1fa:	91 83       	std	Z+1, r25	; 0x01
     1fc:	80 83       	st	Z, r24
  } 
   //entry
  previous=path_log[rescue_x][rescue_y];
     1fe:	20 91 b3 04 	lds	r18, 0x04B3
     202:	30 91 b4 04 	lds	r19, 0x04B4
     206:	40 91 b9 04 	lds	r20, 0x04B9
     20a:	50 91 ba 04 	lds	r21, 0x04BA
     20e:	f9 01       	movw	r30, r18
     210:	ee 0f       	add	r30, r30
     212:	ff 1f       	adc	r31, r31
     214:	c9 01       	movw	r24, r18
     216:	88 0f       	add	r24, r24
     218:	99 1f       	adc	r25, r25
     21a:	88 0f       	add	r24, r24
     21c:	99 1f       	adc	r25, r25
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	e8 0f       	add	r30, r24
     224:	f9 1f       	adc	r31, r25
     226:	e2 0f       	add	r30, r18
     228:	f3 1f       	adc	r31, r19
     22a:	e4 0f       	add	r30, r20
     22c:	f5 1f       	adc	r31, r21
     22e:	ee 0f       	add	r30, r30
     230:	ff 1f       	adc	r31, r31
     232:	e8 5f       	subi	r30, 0xF8	; 248
     234:	fd 4f       	sbci	r31, 0xFD	; 253
     236:	80 81       	ld	r24, Z
     238:	91 81       	ldd	r25, Z+1	; 0x01
     23a:	90 93 be 04 	sts	0x04BE, r25
     23e:	80 93 bd 04 	sts	0x04BD, r24
  path_log[rescue_x][rescue_y]=7;
     242:	87 e0       	ldi	r24, 0x07	; 7
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	91 83       	std	Z+1, r25	; 0x01
     248:	80 83       	st	Z, r24
 
  prev_rescue_x=rescue_x;
     24a:	30 93 53 03 	sts	0x0353, r19
     24e:	20 93 52 03 	sts	0x0352, r18
  prev_rescue_y=rescue_y;
     252:	50 93 c3 04 	sts	0x04C3, r21
     256:	40 93 c2 04 	sts	0x04C2, r20
  
  got_first_cordinate=1;
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	90 93 11 03 	sts	0x0311, r25
     262:	80 93 10 03 	sts	0x0310, r24
}
     266:	08 95       	ret

00000268 <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     268:	86 e6       	ldi	r24, 0x66	; 102
     26a:	9e e0       	ldi	r25, 0x0E	; 14
     26c:	01 97       	sbiw	r24, 0x01	; 1
     26e:	f1 f7       	brne	.-4      	; 0x26c <lcd_set_4bit+0x4>
     270:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     272:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     274:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     276:	80 e3       	ldi	r24, 0x30	; 48
     278:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     27a:	42 9a       	sbi	0x08, 2	; 8
     27c:	ef ef       	ldi	r30, 0xFF	; 255
     27e:	f7 e4       	ldi	r31, 0x47	; 71
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	f1 f7       	brne	.-4      	; 0x280 <lcd_set_4bit+0x18>
     284:	00 c0       	rjmp	.+0      	; 0x286 <lcd_set_4bit+0x1e>
     286:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     288:	42 98       	cbi	0x08, 2	; 8
     28a:	e6 e6       	ldi	r30, 0x66	; 102
     28c:	fe e0       	ldi	r31, 0x0E	; 14
     28e:	31 97       	sbiw	r30, 0x01	; 1
     290:	f1 f7       	brne	.-4      	; 0x28e <lcd_set_4bit+0x26>
     292:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     294:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     296:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     298:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     29a:	42 9a       	sbi	0x08, 2	; 8
     29c:	ef ef       	ldi	r30, 0xFF	; 255
     29e:	f7 e4       	ldi	r31, 0x47	; 71
     2a0:	31 97       	sbiw	r30, 0x01	; 1
     2a2:	f1 f7       	brne	.-4      	; 0x2a0 <lcd_set_4bit+0x38>
     2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <lcd_set_4bit+0x3e>
     2a6:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2a8:	42 98       	cbi	0x08, 2	; 8
     2aa:	e6 e6       	ldi	r30, 0x66	; 102
     2ac:	fe e0       	ldi	r31, 0x0E	; 14
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	f1 f7       	brne	.-4      	; 0x2ae <lcd_set_4bit+0x46>
     2b2:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     2b4:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     2b6:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     2b8:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     2ba:	42 9a       	sbi	0x08, 2	; 8
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	97 e4       	ldi	r25, 0x47	; 71
     2c0:	01 97       	sbiw	r24, 0x01	; 1
     2c2:	f1 f7       	brne	.-4      	; 0x2c0 <lcd_set_4bit+0x58>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <lcd_set_4bit+0x5e>
     2c6:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2c8:	42 98       	cbi	0x08, 2	; 8
     2ca:	e6 e6       	ldi	r30, 0x66	; 102
     2cc:	fe e0       	ldi	r31, 0x0E	; 14
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	f1 f7       	brne	.-4      	; 0x2ce <lcd_set_4bit+0x66>
     2d2:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     2d4:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     2d6:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     2d8:	80 e2       	ldi	r24, 0x20	; 32
     2da:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     2dc:	42 9a       	sbi	0x08, 2	; 8
     2de:	8f ef       	ldi	r24, 0xFF	; 255
     2e0:	97 e4       	ldi	r25, 0x47	; 71
     2e2:	01 97       	sbiw	r24, 0x01	; 1
     2e4:	f1 f7       	brne	.-4      	; 0x2e2 <lcd_set_4bit+0x7a>
     2e6:	00 c0       	rjmp	.+0      	; 0x2e8 <lcd_set_4bit+0x80>
     2e8:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2ea:	42 98       	cbi	0x08, 2	; 8

	
}
     2ec:	08 95       	ret

000002ee <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     2ee:	98 b1       	in	r25, 0x08	; 8
     2f0:	9f 70       	andi	r25, 0x0F	; 15
     2f2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     2f4:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     2f6:	28 2f       	mov	r18, r24
     2f8:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2fa:	92 2b       	or	r25, r18
     2fc:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     2fe:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     300:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     302:	42 9a       	sbi	0x08, 2	; 8
     304:	ef ef       	ldi	r30, 0xFF	; 255
     306:	f7 e4       	ldi	r31, 0x47	; 71
     308:	31 97       	sbiw	r30, 0x01	; 1
     30a:	f1 f7       	brne	.-4      	; 0x308 <lcd_wr_command+0x1a>
     30c:	00 c0       	rjmp	.+0      	; 0x30e <lcd_wr_command+0x20>
     30e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     310:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     312:	98 b1       	in	r25, 0x08	; 8
     314:	9f 70       	andi	r25, 0x0F	; 15
     316:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     318:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     31a:	82 95       	swap	r24
     31c:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     31e:	89 2b       	or	r24, r25
     320:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     322:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     324:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     326:	42 9a       	sbi	0x08, 2	; 8
     328:	8f ef       	ldi	r24, 0xFF	; 255
     32a:	97 e4       	ldi	r25, 0x47	; 71
     32c:	01 97       	sbiw	r24, 0x01	; 1
     32e:	f1 f7       	brne	.-4      	; 0x32c <lcd_wr_command+0x3e>
     330:	00 c0       	rjmp	.+0      	; 0x332 <lcd_wr_command+0x44>
     332:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     334:	42 98       	cbi	0x08, 2	; 8
}
     336:	08 95       	ret

00000338 <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     338:	0e 94 34 01 	call	0x268	; 0x268 <lcd_set_4bit>
     33c:	86 e6       	ldi	r24, 0x66	; 102
     33e:	9e e0       	ldi	r25, 0x0E	; 14
     340:	01 97       	sbiw	r24, 0x01	; 1
     342:	f1 f7       	brne	.-4      	; 0x340 <lcd_init+0x8>
     344:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     346:	88 e2       	ldi	r24, 0x28	; 40
     348:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
	lcd_wr_command(0x01);
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
	lcd_wr_command(0x06);
     352:	86 e0       	ldi	r24, 0x06	; 6
     354:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
	lcd_wr_command(0x0E);
     358:	8e e0       	ldi	r24, 0x0E	; 14
     35a:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
	lcd_wr_command(0x80);
     35e:	80 e8       	ldi	r24, 0x80	; 128
     360:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
		
}
     364:	08 95       	ret

00000366 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     366:	98 b1       	in	r25, 0x08	; 8
     368:	9f 70       	andi	r25, 0x0F	; 15
     36a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     36c:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     36e:	28 2f       	mov	r18, r24
     370:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     372:	92 2b       	or	r25, r18
     374:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     376:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     378:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     37a:	42 9a       	sbi	0x08, 2	; 8
     37c:	ef ef       	ldi	r30, 0xFF	; 255
     37e:	f7 e4       	ldi	r31, 0x47	; 71
     380:	31 97       	sbiw	r30, 0x01	; 1
     382:	f1 f7       	brne	.-4      	; 0x380 <lcd_wr_char+0x1a>
     384:	00 c0       	rjmp	.+0      	; 0x386 <lcd_wr_char+0x20>
     386:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     388:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     38a:	98 b1       	in	r25, 0x08	; 8
     38c:	9f 70       	andi	r25, 0x0F	; 15
     38e:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     390:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     392:	82 95       	swap	r24
     394:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     396:	89 2b       	or	r24, r25
     398:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     39a:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     39c:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     39e:	42 9a       	sbi	0x08, 2	; 8
     3a0:	8f ef       	ldi	r24, 0xFF	; 255
     3a2:	97 e4       	ldi	r25, 0x47	; 71
     3a4:	01 97       	sbiw	r24, 0x01	; 1
     3a6:	f1 f7       	brne	.-4      	; 0x3a4 <lcd_wr_char+0x3e>
     3a8:	00 c0       	rjmp	.+0      	; 0x3aa <lcd_wr_char+0x44>
     3aa:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     3ac:	42 98       	cbi	0x08, 2	; 8
}
     3ae:	08 95       	ret

000003b0 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     3b0:	80 e8       	ldi	r24, 0x80	; 128
     3b2:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
}
     3b6:	08 95       	ret

000003b8 <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	ec 01       	movw	r28, r24
	while(*str != '\0')
     3be:	88 81       	ld	r24, Y
     3c0:	88 23       	and	r24, r24
     3c2:	31 f0       	breq	.+12     	; 0x3d0 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     3c4:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     3c6:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     3ca:	89 91       	ld	r24, Y+
     3cc:	88 23       	and	r24, r24
     3ce:	d9 f7       	brne	.-10     	; 0x3c6 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	08 95       	ret

000003d6 <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     3d6:	82 30       	cpi	r24, 0x02	; 2
     3d8:	79 f0       	breq	.+30     	; 0x3f8 <lcd_cursor+0x22>
     3da:	83 30       	cpi	r24, 0x03	; 3
     3dc:	18 f4       	brcc	.+6      	; 0x3e4 <lcd_cursor+0xe>
     3de:	81 30       	cpi	r24, 0x01	; 1
     3e0:	c9 f4       	brne	.+50     	; 0x414 <lcd_cursor+0x3e>
     3e2:	05 c0       	rjmp	.+10     	; 0x3ee <lcd_cursor+0x18>
     3e4:	83 30       	cpi	r24, 0x03	; 3
     3e6:	69 f0       	breq	.+26     	; 0x402 <lcd_cursor+0x2c>
     3e8:	84 30       	cpi	r24, 0x04	; 4
     3ea:	a1 f4       	brne	.+40     	; 0x414 <lcd_cursor+0x3e>
     3ec:	0f c0       	rjmp	.+30     	; 0x40c <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     3ee:	86 2f       	mov	r24, r22
     3f0:	81 58       	subi	r24, 0x81	; 129
     3f2:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
     3f6:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     3f8:	86 2f       	mov	r24, r22
     3fa:	81 54       	subi	r24, 0x41	; 65
     3fc:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
     400:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     402:	86 2f       	mov	r24, r22
     404:	8d 56       	subi	r24, 0x6D	; 109
     406:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
     40a:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     40c:	86 2f       	mov	r24, r22
     40e:	8d 52       	subi	r24, 0x2D	; 45
     410:	0e 94 77 01 	call	0x2ee	; 0x2ee <lcd_wr_command>
     414:	08 95       	ret

00000416 <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     416:	0f 93       	push	r16
     418:	1f 93       	push	r17
     41a:	cf 93       	push	r28
     41c:	df 93       	push	r29
     41e:	8a 01       	movw	r16, r20
     420:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     422:	88 23       	and	r24, r24
     424:	11 f0       	breq	.+4      	; 0x42a <lcd_print+0x14>
     426:	66 23       	and	r22, r22
     428:	19 f4       	brne	.+6      	; 0x430 <lcd_print+0x1a>
	{
		lcd_home();
     42a:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <lcd_home>
     42e:	02 c0       	rjmp	.+4      	; 0x434 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     430:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     434:	c5 30       	cpi	r28, 0x05	; 5
     436:	d1 05       	cpc	r29, r1
     438:	71 f4       	brne	.+28     	; 0x456 <lcd_print+0x40>
	{
		million=value/10000+48;
     43a:	c8 01       	movw	r24, r16
     43c:	60 e1       	ldi	r22, 0x10	; 16
     43e:	77 e2       	ldi	r23, 0x27	; 39
     440:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     444:	cb 01       	movw	r24, r22
     446:	c0 96       	adiw	r24, 0x30	; 48
     448:	90 93 55 03 	sts	0x0355, r25
     44c:	80 93 54 03 	sts	0x0354, r24
		lcd_wr_char(million);
     450:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>
     454:	03 c0       	rjmp	.+6      	; 0x45c <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     456:	c4 30       	cpi	r28, 0x04	; 4
     458:	d1 05       	cpc	r29, r1
     45a:	b9 f4       	brne	.+46     	; 0x48a <lcd_print+0x74>
	{
		temp = value/1000;
     45c:	c8 01       	movw	r24, r16
     45e:	68 ee       	ldi	r22, 0xE8	; 232
     460:	73 e0       	ldi	r23, 0x03	; 3
     462:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     466:	cb 01       	movw	r24, r22
     468:	70 93 fb 03 	sts	0x03FB, r23
     46c:	60 93 fa 03 	sts	0x03FA, r22
		thousand = temp%10 + 48;
     470:	6a e0       	ldi	r22, 0x0A	; 10
     472:	70 e0       	ldi	r23, 0x00	; 0
     474:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     478:	c0 96       	adiw	r24, 0x30	; 48
     47a:	90 93 d4 04 	sts	0x04D4, r25
     47e:	80 93 d3 04 	sts	0x04D3, r24
		lcd_wr_char(thousand);
     482:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>
		flag=1;
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	01 c0       	rjmp	.+2      	; 0x48c <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     48a:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     48c:	c3 30       	cpi	r28, 0x03	; 3
     48e:	d1 05       	cpc	r29, r1
     490:	11 f0       	breq	.+4      	; 0x496 <lcd_print+0x80>
     492:	81 30       	cpi	r24, 0x01	; 1
     494:	b1 f4       	brne	.+44     	; 0x4c2 <lcd_print+0xac>
	{
		temp = value/100;
     496:	c8 01       	movw	r24, r16
     498:	64 e6       	ldi	r22, 0x64	; 100
     49a:	70 e0       	ldi	r23, 0x00	; 0
     49c:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     4a0:	cb 01       	movw	r24, r22
     4a2:	70 93 fb 03 	sts	0x03FB, r23
     4a6:	60 93 fa 03 	sts	0x03FA, r22
		hundred = temp%10 + 48;
     4aa:	6a e0       	ldi	r22, 0x0A	; 10
     4ac:	70 e0       	ldi	r23, 0x00	; 0
     4ae:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     4b2:	c0 96       	adiw	r24, 0x30	; 48
     4b4:	90 93 cb 04 	sts	0x04CB, r25
     4b8:	80 93 ca 04 	sts	0x04CA, r24
		lcd_wr_char(hundred);
     4bc:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>
		flag=1;
     4c0:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     4c2:	c2 30       	cpi	r28, 0x02	; 2
     4c4:	d1 05       	cpc	r29, r1
     4c6:	11 f0       	breq	.+4      	; 0x4cc <lcd_print+0xb6>
     4c8:	81 30       	cpi	r24, 0x01	; 1
     4ca:	b1 f4       	brne	.+44     	; 0x4f8 <lcd_print+0xe2>
	{
		temp = value/10;
     4cc:	2a e0       	ldi	r18, 0x0A	; 10
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	c8 01       	movw	r24, r16
     4d2:	b9 01       	movw	r22, r18
     4d4:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     4d8:	cb 01       	movw	r24, r22
     4da:	70 93 fb 03 	sts	0x03FB, r23
     4de:	60 93 fa 03 	sts	0x03FA, r22
		tens = temp%10 + 48;
     4e2:	b9 01       	movw	r22, r18
     4e4:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     4e8:	c0 96       	adiw	r24, 0x30	; 48
     4ea:	90 93 bc 04 	sts	0x04BC, r25
     4ee:	80 93 bb 04 	sts	0x04BB, r24
		lcd_wr_char(tens);
     4f2:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>
		flag=1;
     4f6:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     4f8:	c1 30       	cpi	r28, 0x01	; 1
     4fa:	d1 05       	cpc	r29, r1
     4fc:	11 f0       	breq	.+4      	; 0x502 <lcd_print+0xec>
     4fe:	81 30       	cpi	r24, 0x01	; 1
     500:	61 f4       	brne	.+24     	; 0x51a <lcd_print+0x104>
	{
		unit = value%10 + 48;
     502:	c8 01       	movw	r24, r16
     504:	6a e0       	ldi	r22, 0x0A	; 10
     506:	70 e0       	ldi	r23, 0x00	; 0
     508:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <__udivmodhi4>
     50c:	c0 96       	adiw	r24, 0x30	; 48
     50e:	90 93 d2 04 	sts	0x04D2, r25
     512:	80 93 d1 04 	sts	0x04D1, r24
		lcd_wr_char(unit);
     516:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>
	}
	if(digits>5)
     51a:	c6 30       	cpi	r28, 0x06	; 6
     51c:	d1 05       	cpc	r29, r1
     51e:	1c f0       	brlt	.+6      	; 0x526 <lcd_print+0x110>
	{
		lcd_wr_char('E');
     520:	85 e4       	ldi	r24, 0x45	; 69
     522:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_wr_char>
	}
	
}
     526:	df 91       	pop	r29
     528:	cf 91       	pop	r28
     52a:	1f 91       	pop	r17
     52c:	0f 91       	pop	r16
     52e:	08 95       	ret

00000530 <send_data>:

 void send_data(void)
{ 
	//color=color_read();
	//block_on_bot1=scan_black_block();
	if (connection==0)        // Color connection : IDR
     530:	80 91 14 03 	lds	r24, 0x0314
     534:	90 91 15 03 	lds	r25, 0x0315
     538:	00 97       	sbiw	r24, 0x00	; 0
     53a:	e9 f5       	brne	.+122    	; 0x5b6 <send_data+0x86>
	{   trigger=1;
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	90 93 0f 03 	sts	0x030F, r25
     544:	80 93 0e 03 	sts	0x030E, r24
		lcd_print(1,14,dest_x,1);
     548:	40 91 42 03 	lds	r20, 0x0342
     54c:	50 91 43 03 	lds	r21, 0x0343
     550:	81 e0       	ldi	r24, 0x01	; 1
     552:	6e e0       	ldi	r22, 0x0E	; 14
     554:	21 e0       	ldi	r18, 0x01	; 1
     556:	30 e0       	ldi	r19, 0x00	; 0
     558:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
		lcd_print(1,15,dest_y,1);
     55c:	40 91 c0 04 	lds	r20, 0x04C0
     560:	50 91 c1 04 	lds	r21, 0x04C1
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	6f e0       	ldi	r22, 0x0F	; 15
     568:	21 e0       	ldi	r18, 0x01	; 1
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
		lcd_print(1,16,color,1);
     570:	40 91 c4 04 	lds	r20, 0x04C4
     574:	50 91 c5 04 	lds	r21, 0x04C5
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	60 e1       	ldi	r22, 0x10	; 16
     57c:	21 e0       	ldi	r18, 0x01	; 1
     57e:	30 e0       	ldi	r19, 0x00	; 0
     580:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
	   UDR0=10*dest_x+dest_y;
     584:	80 91 42 03 	lds	r24, 0x0342
     588:	88 0f       	add	r24, r24
     58a:	98 2f       	mov	r25, r24
     58c:	99 0f       	add	r25, r25
     58e:	99 0f       	add	r25, r25
     590:	89 0f       	add	r24, r25
     592:	90 91 c0 04 	lds	r25, 0x04C0
     596:	89 0f       	add	r24, r25
     598:	e6 ec       	ldi	r30, 0xC6	; 198
     59a:	f0 e0       	ldi	r31, 0x00	; 0
     59c:	80 83       	st	Z, r24
	   UDR0=200+10*color+trigger;
     59e:	90 91 0e 03 	lds	r25, 0x030E
     5a2:	98 53       	subi	r25, 0x38	; 56
     5a4:	80 91 c4 04 	lds	r24, 0x04C4
     5a8:	88 0f       	add	r24, r24
     5aa:	28 2f       	mov	r18, r24
     5ac:	22 0f       	add	r18, r18
     5ae:	22 0f       	add	r18, r18
     5b0:	82 0f       	add	r24, r18
     5b2:	89 0f       	add	r24, r25
     5b4:	80 83       	st	Z, r24
	}
	
	lcd_cursor(1,10);
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	6a e0       	ldi	r22, 0x0A	; 10
     5ba:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <lcd_cursor>
	lcd_string("w");
     5be:	80 e0       	ldi	r24, 0x00	; 0
     5c0:	92 e0       	ldi	r25, 0x02	; 2
     5c2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_string>
	lcd_print(1,10,wait,1);
     5c6:	40 91 0c 03 	lds	r20, 0x030C
     5ca:	50 91 0d 03 	lds	r21, 0x030D
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	6a e0       	ldi	r22, 0x0A	; 10
     5d2:	21 e0       	ldi	r18, 0x01	; 1
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
	if ( connection==1)     // Avoid collision as
     5da:	80 91 14 03 	lds	r24, 0x0314
     5de:	90 91 15 03 	lds	r25, 0x0315
     5e2:	81 30       	cpi	r24, 0x01	; 1
     5e4:	91 05       	cpc	r25, r1
     5e6:	69 f4       	brne	.+26     	; 0x602 <send_data+0xd2>
	{
	  UDR0=100+10*x_counter+y_counter;
     5e8:	90 91 2c 03 	lds	r25, 0x032C
     5ec:	9c 59       	subi	r25, 0x9C	; 156
     5ee:	80 91 fa 02 	lds	r24, 0x02FA
     5f2:	88 0f       	add	r24, r24
     5f4:	28 2f       	mov	r18, r24
     5f6:	22 0f       	add	r18, r18
     5f8:	22 0f       	add	r18, r18
     5fa:	82 0f       	add	r24, r18
     5fc:	89 0f       	add	r24, r25
     5fe:	80 93 c6 00 	sts	0x00C6, r24
     602:	08 95       	ret

00000604 <motion_set>:
void motion_set (unsigned char Direct)
{
	unsigned char PortARestore = 0;

	Direct &= 0x0F; 			// removing upper nibble as it is not needed
	PortARestore = PORTA; 			// reading the PORTA's original status
     604:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 			// setting lower direction nibble to 0
     606:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direct)
{
	unsigned char PortARestore = 0;

	Direct &= 0x0F; 			// removing upper nibble as it is not needed
     608:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 			// reading the PORTA's original status
	PortARestore &= 0xF0; 			// setting lower direction nibble to 0
	PortARestore |= Direct; 	// adding lower nibble for direction command and restoring the PORTA status
     60a:	98 2b       	or	r25, r24
	PORTA = PortARestore; 			// setting the command to the port
     60c:	92 b9       	out	0x02, r25	; 2
}
     60e:	08 95       	ret

00000610 <motor_init>:
/* These function are here to get basic functionality                   */
/************************************************************************/

void motor_init (void)
{
	DDRA = DDRA | 0x0F;
     610:	81 b1       	in	r24, 0x01	; 1
     612:	8f 60       	ori	r24, 0x0F	; 15
     614:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0; 
     616:	82 b1       	in	r24, 0x02	; 2
     618:	80 7f       	andi	r24, 0xF0	; 240
     61a:	82 b9       	out	0x02, r24	; 2
	
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     61c:	ea e0       	ldi	r30, 0x0A	; 10
     61e:	f1 e0       	ldi	r31, 0x01	; 1
     620:	80 81       	ld	r24, Z
     622:	88 61       	ori	r24, 0x18	; 24
     624:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     626:	eb e0       	ldi	r30, 0x0B	; 11
     628:	f1 e0       	ldi	r31, 0x01	; 1
     62a:	80 81       	ld	r24, Z
     62c:	88 61       	ori	r24, 0x18	; 24
     62e:	80 83       	st	Z, r24

}
     630:	08 95       	ret

00000632 <timer5_init>:



void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     632:	e1 e2       	ldi	r30, 0x21	; 33
     634:	f1 e0       	ldi	r31, 0x01	; 1
     636:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     638:	8f ef       	ldi	r24, 0xFF	; 255
     63a:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     63e:	91 e0       	ldi	r25, 0x01	; 1
     640:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     644:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     648:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     64c:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     650:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     654:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     658:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     65c:	89 ea       	ldi	r24, 0xA9	; 169
     65e:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     662:	8b e0       	ldi	r24, 0x0B	; 11
     664:	80 83       	st	Z, r24
}
     666:	08 95       	ret

00000668 <velocity>:

void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     668:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     66c:	60 93 2a 01 	sts	0x012A, r22
}
     670:	08 95       	ret

00000672 <forward>:

void forward (void) //both wheels forward
{
	motion_set(0x06);
     672:	86 e0       	ldi	r24, 0x06	; 6
     674:	0e 94 02 03 	call	0x604	; 0x604 <motion_set>
}
     678:	08 95       	ret

0000067a <back>:

void back (void) //both wheels backward
{
	motion_set(0x09);
     67a:	89 e0       	ldi	r24, 0x09	; 9
     67c:	0e 94 02 03 	call	0x604	; 0x604 <motion_set>
}
     680:	08 95       	ret

00000682 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     682:	85 e0       	ldi	r24, 0x05	; 5
     684:	0e 94 02 03 	call	0x604	; 0x604 <motion_set>
}
     688:	08 95       	ret

0000068a <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     68a:	8a e0       	ldi	r24, 0x0A	; 10
     68c:	0e 94 02 03 	call	0x604	; 0x604 <motion_set>
}
     690:	08 95       	ret

00000692 <stop>:


void stop (void) //hard stop
{
	motion_set(0x00);
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	0e 94 02 03 	call	0x604	; 0x604 <motion_set>
}
     698:	08 95       	ret

0000069a <left_encoder_pin_config>:

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     69a:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     69c:	74 9a       	sbi	0x0e, 4	; 14
}
     69e:	08 95       	ret

000006a0 <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     6a0:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     6a2:	75 9a       	sbi	0x0e, 5	; 14
}
     6a4:	08 95       	ret

000006a6 <left_position_encoder_interrupt_init>:



void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     6a6:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     6a8:	ea e6       	ldi	r30, 0x6A	; 106
     6aa:	f0 e0       	ldi	r31, 0x00	; 0
     6ac:	80 81       	ld	r24, Z
     6ae:	82 60       	ori	r24, 0x02	; 2
     6b0:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     6b2:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     6b4:	78 94       	sei
}
     6b6:	08 95       	ret

000006b8 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     6b8:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     6ba:	ea e6       	ldi	r30, 0x6A	; 106
     6bc:	f0 e0       	ldi	r31, 0x00	; 0
     6be:	80 81       	ld	r24, Z
     6c0:	88 60       	ori	r24, 0x08	; 8
     6c2:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     6c4:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     6c6:	78 94       	sei
}
     6c8:	08 95       	ret

000006ca <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     6ca:	1f 92       	push	r1
     6cc:	0f 92       	push	r0
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	0f 92       	push	r0
     6d2:	11 24       	eor	r1, r1
     6d4:	8f 93       	push	r24
     6d6:	9f 93       	push	r25
     6d8:	af 93       	push	r26
     6da:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     6dc:	80 91 3a 03 	lds	r24, 0x033A
     6e0:	90 91 3b 03 	lds	r25, 0x033B
     6e4:	a0 91 3c 03 	lds	r26, 0x033C
     6e8:	b0 91 3d 03 	lds	r27, 0x033D
     6ec:	01 96       	adiw	r24, 0x01	; 1
     6ee:	a1 1d       	adc	r26, r1
     6f0:	b1 1d       	adc	r27, r1
     6f2:	80 93 3a 03 	sts	0x033A, r24
     6f6:	90 93 3b 03 	sts	0x033B, r25
     6fa:	a0 93 3c 03 	sts	0x033C, r26
     6fe:	b0 93 3d 03 	sts	0x033D, r27
}
     702:	bf 91       	pop	r27
     704:	af 91       	pop	r26
     706:	9f 91       	pop	r25
     708:	8f 91       	pop	r24
     70a:	0f 90       	pop	r0
     70c:	0f be       	out	0x3f, r0	; 63
     70e:	0f 90       	pop	r0
     710:	1f 90       	pop	r1
     712:	18 95       	reti

00000714 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
     714:	1f 92       	push	r1
     716:	0f 92       	push	r0
     718:	0f b6       	in	r0, 0x3f	; 63
     71a:	0f 92       	push	r0
     71c:	11 24       	eor	r1, r1
     71e:	8f 93       	push	r24
     720:	9f 93       	push	r25
     722:	af 93       	push	r26
     724:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     726:	80 91 3e 03 	lds	r24, 0x033E
     72a:	90 91 3f 03 	lds	r25, 0x033F
     72e:	a0 91 40 03 	lds	r26, 0x0340
     732:	b0 91 41 03 	lds	r27, 0x0341
     736:	01 96       	adiw	r24, 0x01	; 1
     738:	a1 1d       	adc	r26, r1
     73a:	b1 1d       	adc	r27, r1
     73c:	80 93 3e 03 	sts	0x033E, r24
     740:	90 93 3f 03 	sts	0x033F, r25
     744:	a0 93 40 03 	sts	0x0340, r26
     748:	b0 93 41 03 	sts	0x0341, r27
}
     74c:	bf 91       	pop	r27
     74e:	af 91       	pop	r26
     750:	9f 91       	pop	r25
     752:	8f 91       	pop	r24
     754:	0f 90       	pop	r0
     756:	0f be       	out	0x3f, r0	; 63
     758:	0f 90       	pop	r0
     75a:	1f 90       	pop	r1
     75c:	18 95       	reti

0000075e <__vector_1>:

ISR(INT0_vect)
{
     75e:	1f 92       	push	r1
     760:	0f 92       	push	r0
     762:	0f b6       	in	r0, 0x3f	; 63
     764:	0f 92       	push	r0
     766:	11 24       	eor	r1, r1
     768:	8f 93       	push	r24
     76a:	9f 93       	push	r25
     76c:	af 93       	push	r26
     76e:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     770:	80 91 16 03 	lds	r24, 0x0316
     774:	90 91 17 03 	lds	r25, 0x0317
     778:	a0 91 18 03 	lds	r26, 0x0318
     77c:	b0 91 19 03 	lds	r27, 0x0319
     780:	01 96       	adiw	r24, 0x01	; 1
     782:	a1 1d       	adc	r26, r1
     784:	b1 1d       	adc	r27, r1
     786:	80 93 16 03 	sts	0x0316, r24
     78a:	90 93 17 03 	sts	0x0317, r25
     78e:	a0 93 18 03 	sts	0x0318, r26
     792:	b0 93 19 03 	sts	0x0319, r27
}
     796:	bf 91       	pop	r27
     798:	af 91       	pop	r26
     79a:	9f 91       	pop	r25
     79c:	8f 91       	pop	r24
     79e:	0f 90       	pop	r0
     7a0:	0f be       	out	0x3f, r0	; 63
     7a2:	0f 90       	pop	r0
     7a4:	1f 90       	pop	r1
     7a6:	18 95       	reti

000007a8 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     7a8:	0f 93       	push	r16
     7aa:	1f 93       	push	r17
     7ac:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/4.090; // division by resolution to get shaft count 4.62
     7ae:	bc 01       	movw	r22, r24
     7b0:	80 e0       	ldi	r24, 0x00	; 0
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatunsisf>
     7b8:	28 e4       	ldi	r18, 0x48	; 72
     7ba:	31 ee       	ldi	r19, 0xE1	; 225
     7bc:	42 e8       	ldi	r20, 0x82	; 130
     7be:	50 e4       	ldi	r21, 0x40	; 64
     7c0:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     7c4:	0e 94 4e 14 	call	0x289c	; 0x289c <__fixunssfsi>
     7c8:	dc 01       	movw	r26, r24
     7ca:	cb 01       	movw	r24, r22
     7cc:	a0 e0       	ldi	r26, 0x00	; 0
     7ce:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     7d0:	10 92 3a 03 	sts	0x033A, r1
     7d4:	10 92 3b 03 	sts	0x033B, r1
     7d8:	10 92 3c 03 	sts	0x033C, r1
     7dc:	10 92 3d 03 	sts	0x033D, r1
	ShaftCountLeft = 0;
     7e0:	10 92 3e 03 	sts	0x033E, r1
     7e4:	10 92 3f 03 	sts	0x033F, r1
     7e8:	10 92 40 03 	sts	0x0340, r1
     7ec:	10 92 41 03 	sts	0x0341, r1


	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     7f0:	f1 e0       	ldi	r31, 0x01	; 1
     7f2:	c0 e0       	ldi	r28, 0x00	; 0
     7f4:	40 91 3a 03 	lds	r20, 0x033A
     7f8:	50 91 3b 03 	lds	r21, 0x033B
     7fc:	60 91 3c 03 	lds	r22, 0x033C
     800:	70 91 3d 03 	lds	r23, 0x033D
     804:	00 91 3e 03 	lds	r16, 0x033E
     808:	10 91 3f 03 	lds	r17, 0x033F
     80c:	20 91 40 03 	lds	r18, 0x0340
     810:	30 91 41 03 	lds	r19, 0x0341
     814:	ef 2f       	mov	r30, r31
     816:	48 17       	cp	r20, r24
     818:	59 07       	cpc	r21, r25
     81a:	6a 07       	cpc	r22, r26
     81c:	7b 07       	cpc	r23, r27
     81e:	08 f4       	brcc	.+2      	; 0x822 <angle_rotate+0x7a>
     820:	ec 2f       	mov	r30, r28
     822:	ee 23       	and	r30, r30
     824:	49 f4       	brne	.+18     	; 0x838 <angle_rotate+0x90>
     826:	4f 2f       	mov	r20, r31
     828:	08 17       	cp	r16, r24
     82a:	19 07       	cpc	r17, r25
     82c:	2a 07       	cpc	r18, r26
     82e:	3b 07       	cpc	r19, r27
     830:	08 f4       	brcc	.+2      	; 0x834 <angle_rotate+0x8c>
     832:	4c 2f       	mov	r20, r28
     834:	44 23       	and	r20, r20
     836:	f1 f2       	breq	.-68     	; 0x7f4 <angle_rotate+0x4c>
		break;
	}
	stop(); //Stop robot
     838:	0e 94 49 03 	call	0x692	; 0x692 <stop>
}
     83c:	cf 91       	pop	r28
     83e:	1f 91       	pop	r17
     840:	0f 91       	pop	r16
     842:	08 95       	ret

00000844 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
	{
		float ReqdShaftCount = 0;
		unsigned long int ReqdShaftCountInt = 0;

		ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     844:	bc 01       	movw	r22, r24
     846:	80 e0       	ldi	r24, 0x00	; 0
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatunsisf>
     84e:	25 ee       	ldi	r18, 0xE5	; 229
     850:	30 ed       	ldi	r19, 0xD0	; 208
     852:	4a ea       	ldi	r20, 0xAA	; 170
     854:	50 e4       	ldi	r21, 0x40	; 64
     856:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__divsf3>
		ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     85a:	0e 94 4e 14 	call	0x289c	; 0x289c <__fixunssfsi>
     85e:	46 2f       	mov	r20, r22
     860:	57 2f       	mov	r21, r23
     862:	68 2f       	mov	r22, r24
     864:	79 2f       	mov	r23, r25
		ShaftCountRight = 0;
     866:	10 92 3a 03 	sts	0x033A, r1
     86a:	10 92 3b 03 	sts	0x033B, r1
     86e:	10 92 3c 03 	sts	0x033C, r1
     872:	10 92 3d 03 	sts	0x033D, r1
		ShaftCountLeft = 0;
     876:	10 92 3e 03 	sts	0x033E, r1
     87a:	10 92 3f 03 	sts	0x033F, r1
     87e:	10 92 40 03 	sts	0x0340, r1
     882:	10 92 41 03 	sts	0x0341, r1
		while(1)
		{
			if(ShaftCountLeft > ReqdShaftCountInt)
     886:	80 91 3e 03 	lds	r24, 0x033E
     88a:	90 91 3f 03 	lds	r25, 0x033F
     88e:	a0 91 40 03 	lds	r26, 0x0340
     892:	b0 91 41 03 	lds	r27, 0x0341
     896:	48 17       	cp	r20, r24
     898:	59 07       	cpc	r21, r25
     89a:	6a 07       	cpc	r22, r26
     89c:	7b 07       	cpc	r23, r27
     89e:	98 f7       	brcc	.-26     	; 0x886 <linear_distance_mm+0x42>
			{  break;
			}
		}
		stop(); //Stop robot
     8a0:	0e 94 49 03 	call	0x692	; 0x692 <stop>
	}
     8a4:	08 95       	ret

000008a6 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
	{
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29
     8aa:	ec 01       	movw	r28, r24
		forward();
     8ac:	0e 94 39 03 	call	0x672	; 0x672 <forward>
		linear_distance_mm(DistanceInMM);
     8b0:	ce 01       	movw	r24, r28
     8b2:	0e 94 22 04 	call	0x844	; 0x844 <linear_distance_mm>
	}
     8b6:	df 91       	pop	r29
     8b8:	cf 91       	pop	r28
     8ba:	08 95       	ret

000008bc <back_mm>:

void back_mm(unsigned int DistanceInMM)
	{
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	ec 01       	movw	r28, r24
		back();
     8c2:	0e 94 3d 03 	call	0x67a	; 0x67a <back>
		linear_distance_mm(DistanceInMM);
     8c6:	ce 01       	movw	r24, r28
     8c8:	0e 94 22 04 	call	0x844	; 0x844 <linear_distance_mm>
	}
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
     8d0:	08 95       	ret

000008d2 <left_degrees>:

void left_degrees(unsigned int Degrees)
	{
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	ec 01       	movw	r28, r24
		// 88 pulses for 360 degrees rotation 4.090 degrees per count
		left(); //Turn left
     8d8:	0e 94 41 03 	call	0x682	; 0x682 <left>
		angle_rotate(Degrees);
     8dc:	ce 01       	movw	r24, r28
     8de:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <angle_rotate>
	}
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	08 95       	ret

000008e8 <right_degrees>:



void right_degrees(unsigned int Degrees)
	{
     8e8:	cf 93       	push	r28
     8ea:	df 93       	push	r29
     8ec:	ec 01       	movw	r28, r24
		// 88 pulses for 360 degrees rotation 4.090 degrees per count
		right(); //Turn right
     8ee:	0e 94 45 03 	call	0x68a	; 0x68a <right>
		angle_rotate(Degrees);
     8f2:	ce 01       	movw	r24, r28
     8f4:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <angle_rotate>
	}
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	08 95       	ret

000008fe <lcd_port_config>:



void lcd_port_config (void)
	{
	 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     8fe:	87 b1       	in	r24, 0x07	; 7
     900:	87 6f       	ori	r24, 0xF7	; 247
     902:	87 b9       	out	0x07, r24	; 7
	 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     904:	88 b1       	in	r24, 0x08	; 8
     906:	80 78       	andi	r24, 0x80	; 128
     908:	88 b9       	out	0x08, r24	; 8
	}
     90a:	08 95       	ret

0000090c <servo1_pin_config>:

// Servo pin Configuration
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     90c:	25 9a       	sbi	0x04, 5	; 4
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     90e:	2d 9a       	sbi	0x05, 5	; 5
}
     910:	08 95       	ret

00000912 <servo2_pin_config>:

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
	DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
     912:	26 9a       	sbi	0x04, 6	; 4
	PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     914:	2e 9a       	sbi	0x05, 6	; 5
}
     916:	08 95       	ret

00000918 <servo3_pin_config>:

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
	DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
     918:	27 9a       	sbi	0x04, 7	; 4
	PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
     91a:	2f 9a       	sbi	0x05, 7	; 5
}
     91c:	08 95       	ret

0000091e <timer1_init>:

void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     91e:	e1 e8       	ldi	r30, 0x81	; 129
     920:	f0 e0       	ldi	r31, 0x00	; 0
     922:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     924:	8c ef       	ldi	r24, 0xFC	; 252
     926:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
     930:	93 e0       	ldi	r25, 0x03	; 3
     932:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
     936:	8f ef       	ldi	r24, 0xFF	; 255
     938:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
     93c:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
     940:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
     944:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
     948:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
     94c:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
     950:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     954:	8b ea       	ldi	r24, 0xAB	; 171
     956:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
     95a:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     95e:	8c e0       	ldi	r24, 0x0C	; 12
     960:	80 83       	st	Z, r24
}
     962:	08 95       	ret

00000964 <buzzer_pin_config>:

void buzzer_pin_config (void)
	{
	 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     964:	3b 9a       	sbi	0x07, 3	; 7
	 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     966:	43 98       	cbi	0x08, 3	; 8
	}
     968:	08 95       	ret

0000096a <buzzer_on>:

void buzzer_on (void)
	{
		unsigned char port_restore = 0;
		port_restore = PINC;
     96a:	86 b1       	in	r24, 0x06	; 6
		port_restore = port_restore | 0x08;
     96c:	88 60       	ori	r24, 0x08	; 8
		PORTC = port_restore;
     96e:	88 b9       	out	0x08, r24	; 8
	}	 
     970:	08 95       	ret

00000972 <buzzer_off>:

void buzzer_off (void)
	{
		unsigned char port_restore = 0;
		port_restore = PINC;
     972:	86 b1       	in	r24, 0x06	; 6
		port_restore = port_restore & 0xF7;
     974:	87 7f       	andi	r24, 0xF7	; 247
		PORTC = port_restore;
     976:	88 b9       	out	0x08, r24	; 8
	}
     978:	08 95       	ret

0000097a <ADC_init>:

void ADC_init (void)
	{
		 DDRF = 0x00;
     97a:	10 ba       	out	0x10, r1	; 16
		 PORTF =  0x00;
     97c:	11 ba       	out	0x11, r1	; 17
		 ADCSRA = 0x00;
     97e:	ea e7       	ldi	r30, 0x7A	; 122
     980:	f0 e0       	ldi	r31, 0x00	; 0
     982:	10 82       	st	Z, r1
	     ADCSRB = 0x00;		//MUX5 = 0
     984:	10 92 7b 00 	sts	0x007B, r1
		 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     988:	80 e2       	ldi	r24, 0x20	; 32
     98a:	80 93 7c 00 	sts	0x007C, r24
	     ACSR = 0x80;
     98e:	80 e8       	ldi	r24, 0x80	; 128
     990:	80 bf       	out	0x30, r24	; 48
		 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     992:	86 e8       	ldi	r24, 0x86	; 134
     994:	80 83       	st	Z, r24
	}	
     996:	08 95       	ret

00000998 <ADC_Conversion>:

unsigned char ADC_Conversion(unsigned char Ch)
	{
		unsigned char a;
		if(Ch>7)
     998:	88 30       	cpi	r24, 0x08	; 8
     99a:	18 f0       	brcs	.+6      	; 0x9a2 <ADC_Conversion+0xa>
		{
			ADCSRB = 0x08;
     99c:	98 e0       	ldi	r25, 0x08	; 8
     99e:	90 93 7b 00 	sts	0x007B, r25
		}
		Ch = Ch & 0x07;
     9a2:	87 70       	andi	r24, 0x07	; 7
		ADMUX= 0x20| Ch;
     9a4:	80 62       	ori	r24, 0x20	; 32
     9a6:	80 93 7c 00 	sts	0x007C, r24
		ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     9aa:	ea e7       	ldi	r30, 0x7A	; 122
     9ac:	f0 e0       	ldi	r31, 0x00	; 0
     9ae:	80 81       	ld	r24, Z
     9b0:	80 64       	ori	r24, 0x40	; 64
     9b2:	80 83       	st	Z, r24
		while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     9b4:	80 81       	ld	r24, Z
     9b6:	84 ff       	sbrs	r24, 4
     9b8:	fd cf       	rjmp	.-6      	; 0x9b4 <ADC_Conversion+0x1c>
		a=ADCH;
     9ba:	80 91 79 00 	lds	r24, 0x0079
		ADCSRA = ADCSRA|0x10;       //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     9be:	ea e7       	ldi	r30, 0x7A	; 122
     9c0:	f0 e0       	ldi	r31, 0x00	; 0
     9c2:	90 81       	ld	r25, Z
     9c4:	90 61       	ori	r25, 0x10	; 16
     9c6:	90 83       	st	Z, r25
		ADCSRB = 0x00;
     9c8:	10 92 7b 00 	sts	0x007B, r1
		return a;
	}
     9cc:	08 95       	ret

000009ce <line_scan>:
	
// Scan for black lines
// Put values in global variables S[3] 
//  if 1 sensor on white
void line_scan(void)
{   unsigned int s[3];
     9ce:	cf 93       	push	r28
     9d0:	df 93       	push	r29

 	s[1]=ADC_Conversion(3);  // Value of sensor 1
     9d2:	83 e0       	ldi	r24, 0x03	; 3
     9d4:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
     9d8:	d8 2f       	mov	r29, r24
	s[2]=ADC_Conversion(2);
     9da:	82 e0       	ldi	r24, 0x02	; 2
     9dc:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
     9e0:	c8 2f       	mov	r28, r24
	s[3]=ADC_Conversion(1);
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
	
	
					if (s[1]<20)
     9e8:	d4 31       	cpi	r29, 0x14	; 20
     9ea:	38 f4       	brcc	.+14     	; 0x9fa <line_scan+0x2c>
							{ S[1]=1; } //variable is set to 1 ,if white
     9ec:	21 e0       	ldi	r18, 0x01	; 1
     9ee:	30 e0       	ldi	r19, 0x00	; 0
     9f0:	30 93 ff 03 	sts	0x03FF, r19
     9f4:	20 93 fe 03 	sts	0x03FE, r18
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <line_scan+0x34>
					else
							{ S[1]=0;  }  //if black
     9fa:	10 92 ff 03 	sts	0x03FF, r1
     9fe:	10 92 fe 03 	sts	0x03FE, r1
					
				 if (s[2]<20)
     a02:	c4 31       	cpi	r28, 0x14	; 20
     a04:	38 f4       	brcc	.+14     	; 0xa14 <line_scan+0x46>
				         { S[2]=1; } //variable is set to 1 ,if white
     a06:	21 e0       	ldi	r18, 0x01	; 1
     a08:	30 e0       	ldi	r19, 0x00	; 0
     a0a:	30 93 01 04 	sts	0x0401, r19
     a0e:	20 93 00 04 	sts	0x0400, r18
     a12:	04 c0       	rjmp	.+8      	; 0xa1c <line_scan+0x4e>
				 else
				         { S[2]=0;  }  //if black
     a14:	10 92 01 04 	sts	0x0401, r1
     a18:	10 92 00 04 	sts	0x0400, r1
							   
							   
			    if (s[3]<20)
     a1c:	84 31       	cpi	r24, 0x14	; 20
     a1e:	38 f4       	brcc	.+14     	; 0xa2e <line_scan+0x60>
				         { S[3]=1; } //variable is set to 1 ,if white
     a20:	81 e0       	ldi	r24, 0x01	; 1
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	90 93 03 04 	sts	0x0403, r25
     a28:	80 93 02 04 	sts	0x0402, r24
     a2c:	04 c0       	rjmp	.+8      	; 0xa36 <line_scan+0x68>
			    else
			          	{ S[3]=0;  }  //if black
     a2e:	10 92 03 04 	sts	0x0403, r1
     a32:	10 92 02 04 	sts	0x0402, r1
	
}	
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <Sharp>:



void Sharp (void)
	{
	DDRK = 0x00; //set PORTK direction as input
     a3c:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00; //set PORTK pins floating
     a40:	10 92 08 01 	sts	0x0108, r1
	}
     a44:	08 95       	ret

00000a46 <buzzer_init>:

void buzzer_init (void)
	{
		DDRC = DDRC | 0x08;		    //Setting PORTC 3 as output
     a46:	3b 9a       	sbi	0x07, 3	; 7
		PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer	
     a48:	43 98       	cbi	0x08, 3	; 8
	}
     a4a:	08 95       	ret

00000a4c <print_sensor>:

void print_sensor(char row, char coloumn,unsigned char channel)
	{
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	d8 2f       	mov	r29, r24
     a52:	c6 2f       	mov	r28, r22
     a54:	84 2f       	mov	r24, r20
		
		ADC_Value = ADC_Conversion(channel);
     a56:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
     a5a:	48 2f       	mov	r20, r24
     a5c:	80 93 b0 04 	sts	0x04B0, r24
		lcd_print(row, coloumn, ADC_Value, 3);
     a60:	8d 2f       	mov	r24, r29
     a62:	6c 2f       	mov	r22, r28
     a64:	50 e0       	ldi	r21, 0x00	; 0
     a66:	23 e0       	ldi	r18, 0x03	; 3
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
	}
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <Sharp_GP2D12_estimation>:


unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     a74:	0f 93       	push	r16
     a76:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     a78:	68 2f       	mov	r22, r24
     a7a:	70 e0       	ldi	r23, 0x00	; 0
     a7c:	80 e0       	ldi	r24, 0x00	; 0
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatunsisf>
     a84:	2f ee       	ldi	r18, 0xEF	; 239
     a86:	39 ec       	ldi	r19, 0xC9	; 201
     a88:	43 e9       	ldi	r20, 0x93	; 147
     a8a:	5f e3       	ldi	r21, 0x3F	; 63
     a8c:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <pow>
     a90:	b6 2f       	mov	r27, r22
     a92:	a7 2f       	mov	r26, r23
     a94:	38 2f       	mov	r19, r24
     a96:	29 2f       	mov	r18, r25
     a98:	60 e0       	ldi	r22, 0x00	; 0
     a9a:	70 e0       	ldi	r23, 0x00	; 0
     a9c:	80 e8       	ldi	r24, 0x80	; 128
     a9e:	9f e3       	ldi	r25, 0x3F	; 63
     aa0:	42 2f       	mov	r20, r18
     aa2:	0b 2f       	mov	r16, r27
     aa4:	1a 2f       	mov	r17, r26
     aa6:	23 2f       	mov	r18, r19
     aa8:	34 2f       	mov	r19, r20
     aaa:	a9 01       	movw	r20, r18
     aac:	98 01       	movw	r18, r16
     aae:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__divsf3>
     ab2:	2a e9       	ldi	r18, 0x9A	; 154
     ab4:	39 ef       	ldi	r19, 0xF9	; 249
     ab6:	4e e2       	ldi	r20, 0x2E	; 46
     ab8:	55 e4       	ldi	r21, 0x45	; 69
     aba:	0e 94 08 15 	call	0x2a10	; 0x2a10 <__mulsf3>
     abe:	20 e0       	ldi	r18, 0x00	; 0
     ac0:	30 e0       	ldi	r19, 0x00	; 0
     ac2:	40 e2       	ldi	r20, 0x20	; 32
     ac4:	51 e4       	ldi	r21, 0x41	; 65
     ac6:	0e 94 08 15 	call	0x2a10	; 0x2a10 <__mulsf3>
     aca:	0e 94 49 14 	call	0x2892	; 0x2892 <__fixsfsi>
     ace:	88 27       	eor	r24, r24
     ad0:	77 fd       	sbrc	r23, 7
     ad2:	80 95       	com	r24
     ad4:	98 2f       	mov	r25, r24
     ad6:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <__floatsisf>
	distanceInt = (int)distance;
     ada:	0e 94 49 14 	call	0x2892	; 0x2892 <__fixsfsi>

	if(distanceInt>800)
			{
				distanceInt=800;
			}
	return distanceInt;
     ade:	86 2f       	mov	r24, r22
     ae0:	97 2f       	mov	r25, r23
     ae2:	23 e0       	ldi	r18, 0x03	; 3
     ae4:	81 32       	cpi	r24, 0x21	; 33
     ae6:	92 07       	cpc	r25, r18
     ae8:	10 f0       	brcs	.+4      	; 0xaee <Sharp_GP2D12_estimation+0x7a>
     aea:	80 e2       	ldi	r24, 0x20	; 32
     aec:	93 e0       	ldi	r25, 0x03	; 3
}
     aee:	1f 91       	pop	r17
     af0:	0f 91       	pop	r16
     af2:	08 95       	ret

00000af4 <color_sensor_pin_config>:

//Color sensor and rgb LED
void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
     af4:	8a b1       	in	r24, 0x0a	; 10
     af6:	8e 6f       	ori	r24, 0xFE	; 254
     af8:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
     afa:	58 9a       	sbi	0x0b, 0	; 11
}
     afc:	08 95       	ret

00000afe <rgb_off>:

void rgb_off(void)
{
	PORTH= PORTH &~ 0x60;
     afe:	e2 e0       	ldi	r30, 0x02	; 2
     b00:	f1 e0       	ldi	r31, 0x01	; 1
     b02:	80 81       	ld	r24, Z
     b04:	8f 79       	andi	r24, 0x9F	; 159
     b06:	80 83       	st	Z, r24
	PORTG= PORTG &~ 0x02;
     b08:	a1 98       	cbi	0x14, 1	; 20
	PORTL= PORTL &~ 0x80;
     b0a:	eb e0       	ldi	r30, 0x0B	; 11
     b0c:	f1 e0       	ldi	r31, 0x01	; 1
     b0e:	80 81       	ld	r24, Z
     b10:	8f 77       	andi	r24, 0x7F	; 127
     b12:	80 83       	st	Z, r24
}
     b14:	08 95       	ret

00000b16 <rgb_config>:

void rgb_config (void)
{
	DDRH = DDRH | 0x60; //Setting PortH 5,6 as output
     b16:	e1 e0       	ldi	r30, 0x01	; 1
     b18:	f1 e0       	ldi	r31, 0x01	; 1
     b1a:	80 81       	ld	r24, Z
     b1c:	80 66       	ori	r24, 0x60	; 96
     b1e:	80 83       	st	Z, r24
	DDRG = DDRG | 0x02;  // Setting PortG 1 as output
     b20:	99 9a       	sbi	0x13, 1	; 19
	DDRL = DDRL | 0x80;
     b22:	ea e0       	ldi	r30, 0x0A	; 10
     b24:	f1 e0       	ldi	r31, 0x01	; 1
     b26:	80 81       	ld	r24, Z
     b28:	80 68       	ori	r24, 0x80	; 128
     b2a:	80 83       	st	Z, r24
	rgb_off();	
     b2c:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
}
     b30:	08 95       	ret

00000b32 <red_on>:

void red_on (void)  //rph6 gph5 bpg1
{
	rgb_off();
     b32:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
	PORTH = PORTH | 0x20;
     b36:	e2 e0       	ldi	r30, 0x02	; 2
     b38:	f1 e0       	ldi	r31, 0x01	; 1
     b3a:	80 81       	ld	r24, Z
     b3c:	80 62       	ori	r24, 0x20	; 32
     b3e:	80 83       	st	Z, r24
}
     b40:	08 95       	ret

00000b42 <green_on>:

void green_on (void)
{
	rgb_off();
     b42:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
	PORTH = PORTH | 0x40;
     b46:	e2 e0       	ldi	r30, 0x02	; 2
     b48:	f1 e0       	ldi	r31, 0x01	; 1
     b4a:	80 81       	ld	r24, Z
     b4c:	80 64       	ori	r24, 0x40	; 64
     b4e:	80 83       	st	Z, r24
}
     b50:	08 95       	ret

00000b52 <patient_led>:
	}  
}

void patient_led (void)
{
	if (color==1) //red_patient
     b52:	80 91 c4 04 	lds	r24, 0x04C4
     b56:	90 91 c5 04 	lds	r25, 0x04C5
     b5a:	81 30       	cpi	r24, 0x01	; 1
     b5c:	91 05       	cpc	r25, r1
     b5e:	69 f4       	brne	.+26     	; 0xb7a <patient_led+0x28>
	{	
	red_on();
     b60:	0e 94 99 05 	call	0xb32	; 0xb32 <red_on>
     b64:	8f ef       	ldi	r24, 0xFF	; 255
     b66:	9f ef       	ldi	r25, 0xFF	; 255
     b68:	ac e2       	ldi	r26, 0x2C	; 44
     b6a:	81 50       	subi	r24, 0x01	; 1
     b6c:	90 40       	sbci	r25, 0x00	; 0
     b6e:	a0 40       	sbci	r26, 0x00	; 0
     b70:	e1 f7       	brne	.-8      	; 0xb6a <patient_led+0x18>
     b72:	00 c0       	rjmp	.+0      	; 0xb74 <patient_led+0x22>
     b74:	00 00       	nop
	_delay_ms(1000);
	rgb_off();
     b76:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
	}	
	
	if (color==2) // greeen_patient
     b7a:	80 91 c4 04 	lds	r24, 0x04C4
     b7e:	90 91 c5 04 	lds	r25, 0x04C5
     b82:	82 30       	cpi	r24, 0x02	; 2
     b84:	91 05       	cpc	r25, r1
     b86:	69 f4       	brne	.+26     	; 0xba2 <patient_led+0x50>
	{
	 green_on();
     b88:	0e 94 a1 05 	call	0xb42	; 0xb42 <green_on>
     b8c:	8f ef       	ldi	r24, 0xFF	; 255
     b8e:	9f ef       	ldi	r25, 0xFF	; 255
     b90:	ac e2       	ldi	r26, 0x2C	; 44
     b92:	81 50       	subi	r24, 0x01	; 1
     b94:	90 40       	sbci	r25, 0x00	; 0
     b96:	a0 40       	sbci	r26, 0x00	; 0
     b98:	e1 f7       	brne	.-8      	; 0xb92 <patient_led+0x40>
     b9a:	00 c0       	rjmp	.+0      	; 0xb9c <patient_led+0x4a>
     b9c:	00 00       	nop
	 _delay_ms(1000);
	 rgb_off();	
     b9e:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
     ba2:	08 95       	ret

00000ba4 <blue_on>:
	PORTH = PORTH | 0x40;
}

void blue_on (void)
{
	rgb_off();
     ba4:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
	PORTL = PORTL | 0x80;
     ba8:	eb e0       	ldi	r30, 0x0B	; 11
     baa:	f1 e0       	ldi	r31, 0x01	; 1
     bac:	80 81       	ld	r24, Z
     bae:	80 68       	ori	r24, 0x80	; 128
     bb0:	80 83       	st	Z, r24
}
     bb2:	08 95       	ret

00000bb4 <uart0_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     bb4:	e1 ec       	ldi	r30, 0xC1	; 193
     bb6:	f0 e0       	ldi	r31, 0x00	; 0
     bb8:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     bba:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
     bbe:	86 e0       	ldi	r24, 0x06	; 6
     bc0:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x5F; //set baud rate lo
     bc4:	8f e5       	ldi	r24, 0x5F	; 95
     bc6:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     bca:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
     bce:	88 e9       	ldi	r24, 0x98	; 152
     bd0:	80 83       	st	Z, r24
}
     bd2:	08 95       	ret

00000bd4 <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     bd4:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
     bd6:	e9 e6       	ldi	r30, 0x69	; 105
     bd8:	f0 e0       	ldi	r31, 0x00	; 0
     bda:	80 81       	ld	r24, Z
     bdc:	82 60       	ori	r24, 0x02	; 2
     bde:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
     be0:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
     be2:	78 94       	sei
}
     be4:	08 95       	ret

00000be6 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     be6:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     be8:	5f 98       	cbi	0x0b, 7	; 11
}
     bea:	08 95       	ret

00000bec <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     bec:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     bee:	5f 9a       	sbi	0x0b, 7	; 11
}
     bf0:	08 95       	ret

00000bf2 <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
     bf2:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     bf4:	5f 9a       	sbi	0x0b, 7	; 11
}
     bf6:	08 95       	ret

00000bf8 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;n
	PORTD = PORTD | 0x10; //set S0 high
     bf8:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
     bfa:	5d 9a       	sbi	0x0b, 5	; 11
}
     bfc:	08 95       	ret

00000bfe <rgb_test>:
void rgb_test (void)
{
	while(1)
	{
		
	red_on();
     bfe:	0e 94 99 05 	call	0xb32	; 0xb32 <red_on>
     c02:	8f ef       	ldi	r24, 0xFF	; 255
     c04:	9f ef       	ldi	r25, 0xFF	; 255
     c06:	ac e2       	ldi	r26, 0x2C	; 44
     c08:	81 50       	subi	r24, 0x01	; 1
     c0a:	90 40       	sbci	r25, 0x00	; 0
     c0c:	a0 40       	sbci	r26, 0x00	; 0
     c0e:	e1 f7       	brne	.-8      	; 0xc08 <rgb_test+0xa>
     c10:	00 c0       	rjmp	.+0      	; 0xc12 <rgb_test+0x14>
     c12:	00 00       	nop
	_delay_ms(1000);
	green_on();
     c14:	0e 94 a1 05 	call	0xb42	; 0xb42 <green_on>
     c18:	8f ef       	ldi	r24, 0xFF	; 255
     c1a:	9f ef       	ldi	r25, 0xFF	; 255
     c1c:	ac e2       	ldi	r26, 0x2C	; 44
     c1e:	81 50       	subi	r24, 0x01	; 1
     c20:	90 40       	sbci	r25, 0x00	; 0
     c22:	a0 40       	sbci	r26, 0x00	; 0
     c24:	e1 f7       	brne	.-8      	; 0xc1e <rgb_test+0x20>
     c26:	00 c0       	rjmp	.+0      	; 0xc28 <rgb_test+0x2a>
     c28:	00 00       	nop
	_delay_ms(1000);
	blue_on();
     c2a:	0e 94 d2 05 	call	0xba4	; 0xba4 <blue_on>
     c2e:	8f ef       	ldi	r24, 0xFF	; 255
     c30:	9f ef       	ldi	r25, 0xFF	; 255
     c32:	ac e2       	ldi	r26, 0x2C	; 44
     c34:	81 50       	subi	r24, 0x01	; 1
     c36:	90 40       	sbci	r25, 0x00	; 0
     c38:	a0 40       	sbci	r26, 0x00	; 0
     c3a:	e1 f7       	brne	.-8      	; 0xc34 <rgb_test+0x36>
     c3c:	00 c0       	rjmp	.+0      	; 0xc3e <rgb_test+0x40>
     c3e:	00 00       	nop
     c40:	de cf       	rjmp	.-68     	; 0xbfe <rgb_test>

00000c42 <port_init>:
/************************************************************************/
/* Ports are initialized here, after it function are for specific purpose*/                                                         
/************************************************************************/
void port_init()
		{  
			motor_init(); //robot motion pins config
     c42:	0e 94 08 03 	call	0x610	; 0x610 <motor_init>
			buzzer_init();	
     c46:	0e 94 23 05 	call	0xa46	; 0xa46 <buzzer_init>
			left_encoder_pin_config(); //left encoder pin config
     c4a:	0e 94 4d 03 	call	0x69a	; 0x69a <left_encoder_pin_config>
			right_encoder_pin_config(); //right encoder pin config
     c4e:	0e 94 50 03 	call	0x6a0	; 0x6a0 <right_encoder_pin_config>
			left_position_encoder_interrupt_init();
     c52:	0e 94 53 03 	call	0x6a6	; 0x6a6 <left_position_encoder_interrupt_init>
			right_position_encoder_interrupt_init();
     c56:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <right_position_encoder_interrupt_init>
			
			ADC_init();
     c5a:	0e 94 bd 04 	call	0x97a	; 0x97a <ADC_init>
			lcd_port_config();
     c5e:	0e 94 7f 04 	call	0x8fe	; 0x8fe <lcd_port_config>
			timer5_init();
     c62:	0e 94 19 03 	call	0x632	; 0x632 <timer5_init>
			
			color_sensor_pin_config();//color sensor pin configuration
     c66:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <color_sensor_pin_config>
			color_sensor_pin_interrupt_init();
     c6a:	0e 94 ea 05 	call	0xbd4	; 0xbd4 <color_sensor_pin_interrupt_init>
			rgb_config();
     c6e:	0e 94 8b 05 	call	0xb16	; 0xb16 <rgb_config>
			uart0_init(); //Initailize UART0 for serial communiaction
     c72:	0e 94 da 05 	call	0xbb4	; 0xbb4 <uart0_init>
			
			servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     c76:	0e 94 86 04 	call	0x90c	; 0x90c <servo1_pin_config>
			servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation
     c7a:	0e 94 89 04 	call	0x912	; 0x912 <servo2_pin_config>
			servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation
     c7e:	0e 94 8c 04 	call	0x918	; 0x918 <servo3_pin_config>
			timer1_init(); //For servo PWM
     c82:	0e 94 8f 04 	call	0x91e	; 0x91e <timer1_init>
		}
     c86:	08 95       	ret

00000c88 <red_read>:


void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     c88:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <filter_red>
	pulse=0; //reset the count to 0
     c8c:	10 92 16 03 	sts	0x0316, r1
     c90:	10 92 17 03 	sts	0x0317, r1
     c94:	10 92 18 03 	sts	0x0318, r1
     c98:	10 92 19 03 	sts	0x0319, r1
     c9c:	8f ef       	ldi	r24, 0xFF	; 255
     c9e:	9f e7       	ldi	r25, 0x7F	; 127
     ca0:	a4 e0       	ldi	r26, 0x04	; 4
     ca2:	81 50       	subi	r24, 0x01	; 1
     ca4:	90 40       	sbci	r25, 0x00	; 0
     ca6:	a0 40       	sbci	r26, 0x00	; 0
     ca8:	e1 f7       	brne	.-8      	; 0xca2 <red_read+0x1a>
     caa:	00 c0       	rjmp	.+0      	; 0xcac <red_read+0x24>
     cac:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     cae:	80 91 16 03 	lds	r24, 0x0316
     cb2:	90 91 17 03 	lds	r25, 0x0317
     cb6:	a0 91 18 03 	lds	r26, 0x0318
     cba:	b0 91 19 03 	lds	r27, 0x0319
     cbe:	80 93 0a 04 	sts	0x040A, r24
     cc2:	90 93 0b 04 	sts	0x040B, r25
     cc6:	a0 93 0c 04 	sts	0x040C, r26
     cca:	b0 93 0d 04 	sts	0x040D, r27
// 	  	lcd_cursor(1,1);  //set the cursor on row 1, column 1
// 	  	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
// 	  	lcd_print(2,1,red,5);  //Print the count on second row
// 	  	_delay_ms(1000);	// Display for 1000ms or 1 second
// 	  	lcd_wr_command(0x01); //Clear the LCD
}
     cce:	08 95       	ret

00000cd0 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     cd0:	0e 94 f6 05 	call	0xbec	; 0xbec <filter_green>
	pulse=0; //reset the count to 0
     cd4:	10 92 16 03 	sts	0x0316, r1
     cd8:	10 92 17 03 	sts	0x0317, r1
     cdc:	10 92 18 03 	sts	0x0318, r1
     ce0:	10 92 19 03 	sts	0x0319, r1
     ce4:	8f ef       	ldi	r24, 0xFF	; 255
     ce6:	9f e7       	ldi	r25, 0x7F	; 127
     ce8:	a4 e0       	ldi	r26, 0x04	; 4
     cea:	81 50       	subi	r24, 0x01	; 1
     cec:	90 40       	sbci	r25, 0x00	; 0
     cee:	a0 40       	sbci	r26, 0x00	; 0
     cf0:	e1 f7       	brne	.-8      	; 0xcea <green_read+0x1a>
     cf2:	00 c0       	rjmp	.+0      	; 0xcf4 <green_read+0x24>
     cf4:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     cf6:	80 91 16 03 	lds	r24, 0x0316
     cfa:	90 91 17 03 	lds	r25, 0x0317
     cfe:	a0 91 18 03 	lds	r26, 0x0318
     d02:	b0 91 19 03 	lds	r27, 0x0319
     d06:	80 93 02 04 	sts	0x0402, r24
     d0a:	90 93 03 04 	sts	0x0403, r25
     d0e:	a0 93 04 04 	sts	0x0404, r26
     d12:	b0 93 05 04 	sts	0x0405, r27
// 	 	lcd_cursor(1,1);  //set the cursor on row 1, column 1
// 	  	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
// 	  	lcd_print(2,1,green,5);  //Print the count on second row
// 	  	_delay_ms(1000);	// Display for 1000ms or 1 second
// 	  	lcd_wr_command(0x01); //Clear the LCD
}
     d16:	08 95       	ret

00000d18 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
     d18:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <filter_blue>
	pulse=0; //reset the count to 0
     d1c:	10 92 16 03 	sts	0x0316, r1
     d20:	10 92 17 03 	sts	0x0317, r1
     d24:	10 92 18 03 	sts	0x0318, r1
     d28:	10 92 19 03 	sts	0x0319, r1
     d2c:	8f ef       	ldi	r24, 0xFF	; 255
     d2e:	9f e7       	ldi	r25, 0x7F	; 127
     d30:	a4 e0       	ldi	r26, 0x04	; 4
     d32:	81 50       	subi	r24, 0x01	; 1
     d34:	90 40       	sbci	r25, 0x00	; 0
     d36:	a0 40       	sbci	r26, 0x00	; 0
     d38:	e1 f7       	brne	.-8      	; 0xd32 <blue_read+0x1a>
     d3a:	00 c0       	rjmp	.+0      	; 0xd3c <blue_read+0x24>
     d3c:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     d3e:	80 91 16 03 	lds	r24, 0x0316
     d42:	90 91 17 03 	lds	r25, 0x0317
     d46:	a0 91 18 03 	lds	r26, 0x0318
     d4a:	b0 91 19 03 	lds	r27, 0x0319
     d4e:	80 93 48 03 	sts	0x0348, r24
     d52:	90 93 49 03 	sts	0x0349, r25
     d56:	a0 93 4a 03 	sts	0x034A, r26
     d5a:	b0 93 4b 03 	sts	0x034B, r27
// 	 	lcd_cursor(1,1);  //set the cursor on row 1, column 1
// 	 	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
// 	 	lcd_print(2,1,blue,5);  //Print the count on second row
// 	 	_delay_ms(1000);	// Display for 1000ms or 1 second
// 	 	lcd_wr_command(0x01); //Clear the LCD
}
     d5e:	08 95       	ret

00000d60 <color_read>:

unsigned int color_read (void)
{ int i=0;
	red_read(); //display the pulse count when red filter is selected
     d60:	0e 94 44 06 	call	0xc88	; 0xc88 <red_read>
	//	_delay_ms(1000);
	green_read(); //display the pulse count when green filter is selected
     d64:	0e 94 68 06 	call	0xcd0	; 0xcd0 <green_read>
	 //  _delay_ms(1000);
	blue_read(); //display the pulse count when blue filter is selected
     d68:	0e 94 8c 06 	call	0xd18	; 0xd18 <blue_read>
// 	if(green+red<1500 )
// 	{
// 		return 0;  //color is black
// 	}
	
	if((green>red) && (green>blue))
     d6c:	40 91 02 04 	lds	r20, 0x0402
     d70:	50 91 03 04 	lds	r21, 0x0403
     d74:	60 91 04 04 	lds	r22, 0x0404
     d78:	70 91 05 04 	lds	r23, 0x0405
     d7c:	80 91 0a 04 	lds	r24, 0x040A
     d80:	90 91 0b 04 	lds	r25, 0x040B
     d84:	a0 91 0c 04 	lds	r26, 0x040C
     d88:	b0 91 0d 04 	lds	r27, 0x040D
     d8c:	84 17       	cp	r24, r20
     d8e:	95 07       	cpc	r25, r21
     d90:	a6 07       	cpc	r26, r22
     d92:	b7 07       	cpc	r27, r23
     d94:	a8 f4       	brcc	.+42     	; 0xdc0 <color_read+0x60>
     d96:	40 91 02 04 	lds	r20, 0x0402
     d9a:	50 91 03 04 	lds	r21, 0x0403
     d9e:	60 91 04 04 	lds	r22, 0x0404
     da2:	70 91 05 04 	lds	r23, 0x0405
     da6:	80 91 48 03 	lds	r24, 0x0348
     daa:	90 91 49 03 	lds	r25, 0x0349
     dae:	a0 91 4a 03 	lds	r26, 0x034A
     db2:	b0 91 4b 03 	lds	r27, 0x034B
     db6:	84 17       	cp	r24, r20
     db8:	95 07       	cpc	r25, r21
     dba:	a6 07       	cpc	r26, r22
     dbc:	b7 07       	cpc	r27, r23
     dbe:	58 f1       	brcs	.+86     	; 0xe16 <color_read+0xb6>
	{
		return 2;  //color is green
	}
	
	
    if ((red>green)&&(red>blue))
     dc0:	40 91 0a 04 	lds	r20, 0x040A
     dc4:	50 91 0b 04 	lds	r21, 0x040B
     dc8:	60 91 0c 04 	lds	r22, 0x040C
     dcc:	70 91 0d 04 	lds	r23, 0x040D
     dd0:	80 91 02 04 	lds	r24, 0x0402
     dd4:	90 91 03 04 	lds	r25, 0x0403
     dd8:	a0 91 04 04 	lds	r26, 0x0404
     ddc:	b0 91 05 04 	lds	r27, 0x0405
     de0:	84 17       	cp	r24, r20
     de2:	95 07       	cpc	r25, r21
     de4:	a6 07       	cpc	r26, r22
     de6:	b7 07       	cpc	r27, r23
     de8:	a8 f4       	brcc	.+42     	; 0xe14 <color_read+0xb4>
     dea:	40 91 0a 04 	lds	r20, 0x040A
     dee:	50 91 0b 04 	lds	r21, 0x040B
     df2:	60 91 0c 04 	lds	r22, 0x040C
     df6:	70 91 0d 04 	lds	r23, 0x040D
     dfa:	80 91 48 03 	lds	r24, 0x0348
     dfe:	90 91 49 03 	lds	r25, 0x0349
     e02:	a0 91 4a 03 	lds	r26, 0x034A
     e06:	b0 91 4b 03 	lds	r27, 0x034B
     e0a:	84 17       	cp	r24, r20
     e0c:	95 07       	cpc	r25, r21
     e0e:	a6 07       	cpc	r26, r22
     e10:	b7 07       	cpc	r27, r23
     e12:	20 f0       	brcs	.+8      	; 0xe1c <color_read+0xbc>
     e14:	08 95       	ret
// 		return 0;  //color is black
// 	}
	
	if((green>red) && (green>blue))
	{
		return 2;  //color is green
     e16:	22 e0       	ldi	r18, 0x02	; 2
     e18:	30 e0       	ldi	r19, 0x00	; 0
     e1a:	02 c0       	rjmp	.+4      	; 0xe20 <color_read+0xc0>
	}
	
	
    if ((red>green)&&(red>blue))
	{
		return 1;  // color is red    // rph6 gph5 bpg1
     e1c:	21 e0       	ldi	r18, 0x01	; 1
     e1e:	30 e0       	ldi	r19, 0x00	; 0
	}
}
     e20:	82 2f       	mov	r24, r18
     e22:	93 2f       	mov	r25, r19
     e24:	08 95       	ret

00000e26 <servo_1>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     e26:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     e2a:	68 2f       	mov	r22, r24
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatunsisf>
     e36:	2b e7       	ldi	r18, 0x7B	; 123
     e38:	34 e1       	ldi	r19, 0x14	; 20
     e3a:	4e ee       	ldi	r20, 0xEE	; 238
     e3c:	5f e3       	ldi	r21, 0x3F	; 63
     e3e:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__divsf3>
     e42:	20 e0       	ldi	r18, 0x00	; 0
     e44:	30 e0       	ldi	r19, 0x00	; 0
     e46:	4c e0       	ldi	r20, 0x0C	; 12
     e48:	52 e4       	ldi	r21, 0x42	; 66
     e4a:	0e 94 7d 13 	call	0x26fa	; 0x26fa <__addsf3>
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
     e4e:	0e 94 4e 14 	call	0x289c	; 0x289c <__fixunssfsi>
     e52:	60 93 88 00 	sts	0x0088, r22
}
     e56:	08 95       	ret

00000e58 <servo_2>:
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     e58:	10 92 8b 00 	sts	0x008B, r1

//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
     e5c:	68 2f       	mov	r22, r24
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	80 e0       	ldi	r24, 0x00	; 0
     e62:	90 e0       	ldi	r25, 0x00	; 0
     e64:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatunsisf>
     e68:	2b e7       	ldi	r18, 0x7B	; 123
     e6a:	34 e1       	ldi	r19, 0x14	; 20
     e6c:	4e ee       	ldi	r20, 0xEE	; 238
     e6e:	5f e3       	ldi	r21, 0x3F	; 63
     e70:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__divsf3>
     e74:	20 e0       	ldi	r18, 0x00	; 0
     e76:	30 e0       	ldi	r19, 0x00	; 0
     e78:	4c e0       	ldi	r20, 0x0C	; 12
     e7a:	52 e4       	ldi	r21, 0x42	; 66
     e7c:	0e 94 7d 13 	call	0x26fa	; 0x26fa <__addsf3>
	OCR1BH = 0x00;
	OCR1BL = (unsigned char) PositionTiltServo;
     e80:	0e 94 4e 14 	call	0x289c	; 0x289c <__fixunssfsi>
     e84:	60 93 8a 00 	sts	0x008A, r22
}
     e88:	08 95       	ret

00000e8a <servo_3>:
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     e8a:	10 92 8d 00 	sts	0x008D, r1

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
     e8e:	68 2f       	mov	r22, r24
     e90:	70 e0       	ldi	r23, 0x00	; 0
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	90 e0       	ldi	r25, 0x00	; 0
     e96:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatunsisf>
     e9a:	2b e7       	ldi	r18, 0x7B	; 123
     e9c:	34 e1       	ldi	r19, 0x14	; 20
     e9e:	4e ee       	ldi	r20, 0xEE	; 238
     ea0:	5f e3       	ldi	r21, 0x3F	; 63
     ea2:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__divsf3>
     ea6:	20 e0       	ldi	r18, 0x00	; 0
     ea8:	30 e0       	ldi	r19, 0x00	; 0
     eaa:	4c e0       	ldi	r20, 0x0C	; 12
     eac:	52 e4       	ldi	r21, 0x42	; 66
     eae:	0e 94 7d 13 	call	0x26fa	; 0x26fa <__addsf3>
	OCR1CH = 0x00;
	OCR1CL = (unsigned char) PositionServo;
     eb2:	0e 94 4e 14 	call	0x289c	; 0x289c <__fixunssfsi>
     eb6:	60 93 8c 00 	sts	0x008C, r22
}
     eba:	08 95       	ret

00000ebc <servo_1_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void) //makes servo 1 free rotating
{
	OCR1AH = 0x03;
     ebc:	83 e0       	ldi	r24, 0x03	; 3
     ebe:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = 0xFF; //Servo 1 off
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	80 93 88 00 	sts	0x0088, r24
}
     ec8:	08 95       	ret

00000eca <servo_2_free>:

void servo_2_free (void) //makes servo 2 free rotating
{
	OCR1BH = 0x03;
     eca:	83 e0       	ldi	r24, 0x03	; 3
     ecc:	80 93 8b 00 	sts	0x008B, r24
	OCR1BL = 0xFF; //Servo 2 off
     ed0:	8f ef       	ldi	r24, 0xFF	; 255
     ed2:	80 93 8a 00 	sts	0x008A, r24
}
     ed6:	08 95       	ret

00000ed8 <servo_3_free>:

void servo_3_free (void) //makes servo 3 free rotating
{
	OCR1CH = 0x03;
     ed8:	83 e0       	ldi	r24, 0x03	; 3
     eda:	80 93 8d 00 	sts	0x008D, r24
	OCR1CL = 0xFF; //Servo 3 off
     ede:	8f ef       	ldi	r24, 0xFF	; 255
     ee0:	80 93 8c 00 	sts	0x008C, r24
}
     ee4:	08 95       	ret

00000ee6 <block_buzzer>:

// 2sec buzzer for block detection
void block_buzzer (void)
{
	buzzer_on();                // Making buzzer sound for two seconds
     ee6:	0e 94 b5 04 	call	0x96a	; 0x96a <buzzer_on>
     eea:	8f ef       	ldi	r24, 0xFF	; 255
     eec:	9f ef       	ldi	r25, 0xFF	; 255
     eee:	ac e2       	ldi	r26, 0x2C	; 44
     ef0:	81 50       	subi	r24, 0x01	; 1
     ef2:	90 40       	sbci	r25, 0x00	; 0
     ef4:	a0 40       	sbci	r26, 0x00	; 0
     ef6:	e1 f7       	brne	.-8      	; 0xef0 <block_buzzer+0xa>
     ef8:	00 c0       	rjmp	.+0      	; 0xefa <block_buzzer+0x14>
     efa:	00 00       	nop
	_delay_ms(1000);
	buzzer_off();
     efc:	0e 94 b9 04 	call	0x972	; 0x972 <buzzer_off>
}
     f00:	08 95       	ret

00000f02 <block_buzzer2>:

void block_buzzer2 (void)
{
	buzzer_on();                // Making buzzer sound for two seconds
     f02:	0e 94 b5 04 	call	0x96a	; 0x96a <buzzer_on>
     f06:	8f ef       	ldi	r24, 0xFF	; 255
     f08:	9f ef       	ldi	r25, 0xFF	; 255
     f0a:	a9 e5       	ldi	r26, 0x59	; 89
     f0c:	81 50       	subi	r24, 0x01	; 1
     f0e:	90 40       	sbci	r25, 0x00	; 0
     f10:	a0 40       	sbci	r26, 0x00	; 0
     f12:	e1 f7       	brne	.-8      	; 0xf0c <block_buzzer2+0xa>
     f14:	00 c0       	rjmp	.+0      	; 0xf16 <block_buzzer2+0x14>
     f16:	00 00       	nop
	_delay_ms(2000);
	buzzer_off();
     f18:	0e 94 b9 04 	call	0x972	; 0x972 <buzzer_off>
}
     f1c:	08 95       	ret

00000f1e <no_block>:



void no_block (void)
{
	blue_on();
     f1e:	0e 94 d2 05 	call	0xba4	; 0xba4 <blue_on>
	block_buzzer2();
     f22:	0e 94 81 07 	call	0xf02	; 0xf02 <block_buzzer2>
	rgb_off();
     f26:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
}
     f2a:	08 95       	ret

00000f2c <end_buzzer>:
}

// 10 sec buzzer for ending 
void end_buzzer (void)
{
	buzzer_on();                // Making buzzer sound for two seconds
     f2c:	0e 94 b5 04 	call	0x96a	; 0x96a <buzzer_on>
     f30:	8f ef       	ldi	r24, 0xFF	; 255
     f32:	9f ef       	ldi	r25, 0xFF	; 255
     f34:	a6 e7       	ldi	r26, 0x76	; 118
     f36:	b1 e0       	ldi	r27, 0x01	; 1
     f38:	81 50       	subi	r24, 0x01	; 1
     f3a:	90 40       	sbci	r25, 0x00	; 0
     f3c:	a0 40       	sbci	r26, 0x00	; 0
     f3e:	b0 40       	sbci	r27, 0x00	; 0
     f40:	d9 f7       	brne	.-10     	; 0xf38 <end_buzzer+0xc>
     f42:	00 c0       	rjmp	.+0      	; 0xf44 <end_buzzer+0x18>
     f44:	00 00       	nop
	_delay_ms(10000);
	buzzer_off() ;
     f46:	0e 94 b9 04 	call	0x972	; 0x972 <buzzer_off>
}
     f4a:	08 95       	ret

00000f4c <align_right_1>:


// Align with black line present in right <alternate>
void align_right_1(void)
		{   
     f4c:	0f 93       	push	r16
     f4e:	1f 93       	push	r17
     f50:	cf 93       	push	r28
     f52:	df 93       	push	r29
			velocity (190, 190);
     f54:	8e eb       	ldi	r24, 0xBE	; 190
     f56:	6e eb       	ldi	r22, 0xBE	; 190
     f58:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
			 right();
     f5c:	0e 94 45 03 	call	0x68a	; 0x68a <right>
			 line_scan();
     f60:	c7 ee       	ldi	r28, 0xE7	; 231
     f62:	d4 e0       	ldi	r29, 0x04	; 4
     f64:	fe 01       	movw	r30, r28
     f66:	19 95       	eicall
			
				while (S[2]==1)
     f68:	80 91 00 04 	lds	r24, 0x0400
     f6c:	90 91 01 04 	lds	r25, 0x0401
     f70:	81 30       	cpi	r24, 0x01	; 1
     f72:	91 05       	cpc	r25, r1
     f74:	51 f4       	brne	.+20     	; 0xf8a <align_right_1+0x3e>
     f76:	00 e0       	ldi	r16, 0x00	; 0
     f78:	14 e0       	ldi	r17, 0x04	; 4
         				{    
							 line_scan();
     f7a:	fe 01       	movw	r30, r28
     f7c:	19 95       	eicall
		{   
			velocity (190, 190);
			 right();
			 line_scan();
			
				while (S[2]==1)
     f7e:	f8 01       	movw	r30, r16
     f80:	80 81       	ld	r24, Z
     f82:	91 81       	ldd	r25, Z+1	; 0x01
     f84:	81 30       	cpi	r24, 0x01	; 1
     f86:	91 05       	cpc	r25, r1
     f88:	c1 f3       	breq	.-16     	; 0xf7a <align_right_1+0x2e>
         				{    
							 line_scan();
						}
	
			velocity (255, 255);
     f8a:	8f ef       	ldi	r24, 0xFF	; 255
     f8c:	6f ef       	ldi	r22, 0xFF	; 255
     f8e:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
			stop();
     f92:	0e 94 49 03 	call	0x692	; 0x692 <stop>
		}
     f96:	df 91       	pop	r29
     f98:	cf 91       	pop	r28
     f9a:	1f 91       	pop	r17
     f9c:	0f 91       	pop	r16
     f9e:	08 95       	ret

00000fa0 <align_left_1>:

//Align with black line present in left <alternate>
void align_left_1(void)
{		
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
		     velocity (150,190);
     fa8:	86 e9       	ldi	r24, 0x96	; 150
     faa:	6e eb       	ldi	r22, 0xBE	; 190
     fac:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
		   left();
     fb0:	0e 94 41 03 	call	0x682	; 0x682 <left>
		   line_scan();
     fb4:	c7 ee       	ldi	r28, 0xE7	; 231
     fb6:	d4 e0       	ldi	r29, 0x04	; 4
     fb8:	fe 01       	movw	r30, r28
     fba:	19 95       	eicall
		   
		  while (S[2]==1)
     fbc:	80 91 00 04 	lds	r24, 0x0400
     fc0:	90 91 01 04 	lds	r25, 0x0401
     fc4:	81 30       	cpi	r24, 0x01	; 1
     fc6:	91 05       	cpc	r25, r1
     fc8:	51 f4       	brne	.+20     	; 0xfde <align_left_1+0x3e>
     fca:	00 e0       	ldi	r16, 0x00	; 0
     fcc:	14 e0       	ldi	r17, 0x04	; 4
					{
					  line_scan();
     fce:	fe 01       	movw	r30, r28
     fd0:	19 95       	eicall
{		
		     velocity (150,190);
		   left();
		   line_scan();
		   
		  while (S[2]==1)
     fd2:	f8 01       	movw	r30, r16
     fd4:	80 81       	ld	r24, Z
     fd6:	91 81       	ldd	r25, Z+1	; 0x01
     fd8:	81 30       	cpi	r24, 0x01	; 1
     fda:	91 05       	cpc	r25, r1
     fdc:	c1 f3       	breq	.-16     	; 0xfce <align_left_1+0x2e>
					{
					  line_scan();
                     }
	
  velocity (255, 255);
     fde:	8f ef       	ldi	r24, 0xFF	; 255
     fe0:	6f ef       	ldi	r22, 0xFF	; 255
     fe2:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
  stop();
     fe6:	0e 94 49 03 	call	0x692	; 0x692 <stop>
 
}
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	1f 91       	pop	r17
     ff0:	0f 91       	pop	r16
     ff2:	08 95       	ret

00000ff4 <right_90_1>:


// 90 degree right turn at intersection  <alternate>
void right_90_1(void)
{
	right_degrees(40);
     ff4:	88 e2       	ldi	r24, 0x28	; 40
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	0e 94 74 04 	call	0x8e8	; 0x8e8 <right_degrees>
	
	align_right_1();
     ffc:	0e 94 a6 07 	call	0xf4c	; 0xf4c <align_right_1>
	
}
    1000:	08 95       	ret

00001002 <left_90_1>:

//90 degree lest turn at intersection <alternate>
void  left_90_1 (void)
{   left_degrees(40);
    1002:	88 e2       	ldi	r24, 0x28	; 40
    1004:	90 e0       	ldi	r25, 0x00	; 0
    1006:	0e 94 69 04 	call	0x8d2	; 0x8d2 <left_degrees>
	
	align_left_1();	
    100a:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <align_left_1>
}
    100e:	08 95       	ret

00001010 <scan_block>:
  
  

// if block is in range it return 1 otherwise zero
int scan_block (void)
{  unsigned int yes=0;
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	c6 e0       	ldi	r28, 0x06	; 6
    1016:	d0 e0       	ldi	r29, 0x00	; 0
	for(int i=0;i<=5;i++)
	{	sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    1018:	8b e0       	ldi	r24, 0x0B	; 11
    101a:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
    101e:	80 93 d0 04 	sts	0x04D0, r24
		value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calculated in a variable "value".
    1022:	0e 94 3a 05 	call	0xa74	; 0xa74 <Sharp_GP2D12_estimation>
    1026:	ac 01       	movw	r20, r24
    1028:	90 93 d8 04 	sts	0x04D8, r25
    102c:	80 93 d7 04 	sts	0x04D7, r24
		lcd_print(2,1,value,3);	
    1030:	82 e0       	ldi	r24, 0x02	; 2
    1032:	61 e0       	ldi	r22, 0x01	; 1
    1034:	23 e0       	ldi	r18, 0x03	; 3
    1036:	30 e0       	ldi	r19, 0x00	; 0
    1038:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
    103c:	21 97       	sbiw	r28, 0x01	; 1
  

// if block is in range it return 1 otherwise zero
int scan_block (void)
{  unsigned int yes=0;
	for(int i=0;i<=5;i++)
    103e:	61 f7       	brne	.-40     	; 0x1018 <scan_block+0x8>
	{	sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
		value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calculated in a variable "value".
		lcd_print(2,1,value,3);	
	}
		
	if(value<180 && value >50)   //Check for block in a plot by distance
    1040:	20 91 d7 04 	lds	r18, 0x04D7
    1044:	30 91 d8 04 	lds	r19, 0x04D8
    1048:	23 53       	subi	r18, 0x33	; 51
    104a:	30 40       	sbci	r19, 0x00	; 0
	{
		yes=1;                     // if yes=1 , block exist
 	}
	
	return yes;
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	90 e0       	ldi	r25, 0x00	; 0
    1050:	21 38       	cpi	r18, 0x81	; 129
    1052:	31 05       	cpc	r19, r1
    1054:	10 f0       	brcs	.+4      	; 0x105a <scan_block+0x4a>
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	90 e0       	ldi	r25, 0x00	; 0
}
    105a:	df 91       	pop	r29
    105c:	cf 91       	pop	r28
    105e:	08 95       	ret

00001060 <IDR>:

void IDR (void)
{  
	find_plot_pos();
    1060:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <find_plot_pos>
	//block_buzzer();
    forward_mm(mid-90);
    1064:	80 91 08 03 	lds	r24, 0x0308
    1068:	90 91 09 03 	lds	r25, 0x0309
    106c:	8a 55       	subi	r24, 0x5A	; 90
    106e:	90 40       	sbci	r25, 0x00	; 0
    1070:	0e 94 53 04 	call	0x8a6	; 0x8a6 <forward_mm>
	connection=0;
    1074:	10 92 15 03 	sts	0x0315, r1
    1078:	10 92 14 03 	sts	0x0314, r1
	back_mm(10);
    107c:	8a e0       	ldi	r24, 0x0A	; 10
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	0e 94 5e 04 	call	0x8bc	; 0x8bc <back_mm>
	left_degrees(25);
    1084:	89 e1       	ldi	r24, 0x19	; 25
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	0e 94 69 04 	call	0x8d2	; 0x8d2 <left_degrees>
	color=color_read();
    108c:	0e 94 b0 06 	call	0xd60	; 0xd60 <color_read>
    1090:	90 93 c5 04 	sts	0x04C5, r25
    1094:	80 93 c4 04 	sts	0x04C4, r24
	patient_led();
    1098:	0e 94 a9 05 	call	0xb52	; 0xb52 <patient_led>
	send_data();
    109c:	0e 94 98 02 	call	0x530	; 0x530 <send_data>
	right_degrees(25);
    10a0:	89 e1       	ldi	r24, 0x19	; 25
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	0e 94 74 04 	call	0x8e8	; 0x8e8 <right_degrees>
    back_mm(mid-100);
    10a8:	80 91 08 03 	lds	r24, 0x0308
    10ac:	90 91 09 03 	lds	r25, 0x0309
    10b0:	84 56       	subi	r24, 0x64	; 100
    10b2:	90 40       	sbci	r25, 0x00	; 0
    10b4:	0e 94 5e 04 	call	0x8bc	; 0x8bc <back_mm>
	rgb_off(); 
    10b8:	0e 94 7f 05 	call	0xafe	; 0xafe <rgb_off>
}
    10bc:	08 95       	ret

000010be <right_block_scan>:

void right_block_scan (void)
{
	right_degrees(86);
    10be:	86 e5       	ldi	r24, 0x56	; 86
    10c0:	90 e0       	ldi	r25, 0x00	; 0
    10c2:	0e 94 74 04 	call	0x8e8	; 0x8e8 <right_degrees>
	r=scan_block(); 
    10c6:	0e 94 08 08 	call	0x1010	; 0x1010 <scan_block>
    10ca:	28 2f       	mov	r18, r24
    10cc:	39 2f       	mov	r19, r25
    10ce:	30 93 37 03 	sts	0x0337, r19
    10d2:	20 93 36 03 	sts	0x0336, r18
	if (r==1)
    10d6:	21 30       	cpi	r18, 0x01	; 1
    10d8:	31 05       	cpc	r19, r1
    10da:	19 f4       	brne	.+6      	; 0x10e2 <right_block_scan+0x24>
	{ 
		IDR();
    10dc:	0e 94 30 08 	call	0x1060	; 0x1060 <IDR>
    10e0:	02 c0       	rjmp	.+4      	; 0x10e6 <right_block_scan+0x28>
	}
	else
	{
		no_block();
    10e2:	0e 94 8f 07 	call	0xf1e	; 0xf1e <no_block>
	}
	left_90_1();
    10e6:	0e 94 01 08 	call	0x1002	; 0x1002 <left_90_1>
	num_plots++;
    10ea:	80 91 1a 03 	lds	r24, 0x031A
    10ee:	90 91 1b 03 	lds	r25, 0x031B
    10f2:	01 96       	adiw	r24, 0x01	; 1
    10f4:	90 93 1b 03 	sts	0x031B, r25
    10f8:	80 93 1a 03 	sts	0x031A, r24
	r=0;
    10fc:	10 92 37 03 	sts	0x0337, r1
    1100:	10 92 36 03 	sts	0x0336, r1
}
    1104:	08 95       	ret

00001106 <left_block_scan>:

// A scan for block present in left
void left_block_scan(void)
{
	left_degrees(88);
    1106:	88 e5       	ldi	r24, 0x58	; 88
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	0e 94 69 04 	call	0x8d2	; 0x8d2 <left_degrees>
	l=scan_block();
    110e:	0e 94 08 08 	call	0x1010	; 0x1010 <scan_block>
    1112:	28 2f       	mov	r18, r24
    1114:	39 2f       	mov	r19, r25
    1116:	30 93 39 03 	sts	0x0339, r19
    111a:	20 93 38 03 	sts	0x0338, r18
	if (l==1)
    111e:	21 30       	cpi	r18, 0x01	; 1
    1120:	31 05       	cpc	r19, r1
    1122:	19 f4       	brne	.+6      	; 0x112a <left_block_scan+0x24>
	{
		IDR();
    1124:	0e 94 30 08 	call	0x1060	; 0x1060 <IDR>
    1128:	02 c0       	rjmp	.+4      	; 0x112e <left_block_scan+0x28>
	}
	else
	{
	no_block();
    112a:	0e 94 8f 07 	call	0xf1e	; 0xf1e <no_block>
	}
	right_90_1();
    112e:	0e 94 fa 07 	call	0xff4	; 0xff4 <right_90_1>
		num_plots++;
    1132:	80 91 1a 03 	lds	r24, 0x031A
    1136:	90 91 1b 03 	lds	r25, 0x031B
    113a:	01 96       	adiw	r24, 0x01	; 1
    113c:	90 93 1b 03 	sts	0x031B, r25
    1140:	80 93 1a 03 	sts	0x031A, r24
	l=0;
    1144:	10 92 39 03 	sts	0x0339, r1
    1148:	10 92 38 03 	sts	0x0338, r1
}
    114c:	08 95       	ret

0000114e <scan_plot>:

// Scan for block using sharp in front of bot
//This function make sure that a plot is scanned only once
void scan_plot (void)
{  
		if (x_counter%2==0)
    114e:	80 91 fa 02 	lds	r24, 0x02FA
    1152:	90 91 fb 02 	lds	r25, 0x02FB
    1156:	80 fd       	sbrc	r24, 0
    1158:	ee c1       	rjmp	.+988    	; 0x1536 <scan_plot+0x3e8>
		{
		      //orientation =2 <==  bot
			  if (orientation ==3) 
    115a:	20 91 34 03 	lds	r18, 0x0334
    115e:	30 91 35 03 	lds	r19, 0x0335
    1162:	23 30       	cpi	r18, 0x03	; 3
    1164:	31 05       	cpc	r19, r1
    1166:	09 f0       	breq	.+2      	; 0x116a <scan_plot+0x1c>
    1168:	ed c0       	rjmp	.+474    	; 0x1344 <scan_plot+0x1f6>
					{	if ( (y_counter<9) && (y_counter>1) ) //somewhere in between
    116a:	20 91 2c 03 	lds	r18, 0x032C
    116e:	30 91 2d 03 	lds	r19, 0x032D
    1172:	a9 01       	movw	r20, r18
    1174:	42 50       	subi	r20, 0x02	; 2
    1176:	50 40       	sbci	r21, 0x00	; 0
    1178:	47 30       	cpi	r20, 0x07	; 7
    117a:	51 05       	cpc	r21, r1
    117c:	08 f0       	brcs	.+2      	; 0x1180 <scan_plot+0x32>
    117e:	6c c0       	rjmp	.+216    	; 0x1258 <scan_plot+0x10a>
						{
						  if(plot[x_counter][y_counter-1]==0)
    1180:	fc 01       	movw	r30, r24
    1182:	ee 0f       	add	r30, r30
    1184:	ff 1f       	adc	r31, r31
    1186:	ee 0f       	add	r30, r30
    1188:	ff 1f       	adc	r31, r31
    118a:	ee 0f       	add	r30, r30
    118c:	ff 1f       	adc	r31, r31
    118e:	8e 0f       	add	r24, r30
    1190:	9f 1f       	adc	r25, r31
    1192:	28 0f       	add	r18, r24
    1194:	39 1f       	adc	r19, r25
    1196:	f9 01       	movw	r30, r18
    1198:	ee 0f       	add	r30, r30
    119a:	ff 1f       	adc	r31, r31
    119c:	ec 5a       	subi	r30, 0xAC	; 172
    119e:	fc 4f       	sbci	r31, 0xFC	; 252
    11a0:	80 81       	ld	r24, Z
    11a2:	91 81       	ldd	r25, Z+1	; 0x01
    11a4:	00 97       	sbiw	r24, 0x00	; 0
    11a6:	f1 f4       	brne	.+60     	; 0x11e4 <scan_plot+0x96>
							  {
								  left_block_scan();
    11a8:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
								  plot[x_counter][y_counter-1]=1;
    11ac:	80 91 fa 02 	lds	r24, 0x02FA
    11b0:	90 91 fb 02 	lds	r25, 0x02FB
    11b4:	fc 01       	movw	r30, r24
    11b6:	ee 0f       	add	r30, r30
    11b8:	ff 1f       	adc	r31, r31
    11ba:	ee 0f       	add	r30, r30
    11bc:	ff 1f       	adc	r31, r31
    11be:	ee 0f       	add	r30, r30
    11c0:	ff 1f       	adc	r31, r31
    11c2:	8e 0f       	add	r24, r30
    11c4:	9f 1f       	adc	r25, r31
    11c6:	20 91 2c 03 	lds	r18, 0x032C
    11ca:	30 91 2d 03 	lds	r19, 0x032D
    11ce:	82 0f       	add	r24, r18
    11d0:	93 1f       	adc	r25, r19
    11d2:	fc 01       	movw	r30, r24
    11d4:	ee 0f       	add	r30, r30
    11d6:	ff 1f       	adc	r31, r31
    11d8:	ec 5a       	subi	r30, 0xAC	; 172
    11da:	fc 4f       	sbci	r31, 0xFC	; 252
    11dc:	81 e0       	ldi	r24, 0x01	; 1
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	91 83       	std	Z+1, r25	; 0x01
    11e2:	80 83       	st	Z, r24
							  }
		  
						  if (plot[x_counter][y_counter+1]==0)
    11e4:	80 91 fa 02 	lds	r24, 0x02FA
    11e8:	90 91 fb 02 	lds	r25, 0x02FB
    11ec:	fc 01       	movw	r30, r24
    11ee:	ee 0f       	add	r30, r30
    11f0:	ff 1f       	adc	r31, r31
    11f2:	ee 0f       	add	r30, r30
    11f4:	ff 1f       	adc	r31, r31
    11f6:	ee 0f       	add	r30, r30
    11f8:	ff 1f       	adc	r31, r31
    11fa:	8e 0f       	add	r24, r30
    11fc:	9f 1f       	adc	r25, r31
    11fe:	20 91 2c 03 	lds	r18, 0x032C
    1202:	30 91 2d 03 	lds	r19, 0x032D
    1206:	82 0f       	add	r24, r18
    1208:	93 1f       	adc	r25, r19
    120a:	fc 01       	movw	r30, r24
    120c:	ee 0f       	add	r30, r30
    120e:	ff 1f       	adc	r31, r31
    1210:	e8 5a       	subi	r30, 0xA8	; 168
    1212:	fc 4f       	sbci	r31, 0xFC	; 252
    1214:	80 81       	ld	r24, Z
    1216:	91 81       	ldd	r25, Z+1	; 0x01
    1218:	00 97       	sbiw	r24, 0x00	; 0
    121a:	f1 f4       	brne	.+60     	; 0x1258 <scan_plot+0x10a>
							  {
								right_block_scan();	  
    121c:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
							   	plot[x_counter][y_counter+1]=1;
    1220:	80 91 fa 02 	lds	r24, 0x02FA
    1224:	90 91 fb 02 	lds	r25, 0x02FB
    1228:	fc 01       	movw	r30, r24
    122a:	ee 0f       	add	r30, r30
    122c:	ff 1f       	adc	r31, r31
    122e:	ee 0f       	add	r30, r30
    1230:	ff 1f       	adc	r31, r31
    1232:	ee 0f       	add	r30, r30
    1234:	ff 1f       	adc	r31, r31
    1236:	8e 0f       	add	r24, r30
    1238:	9f 1f       	adc	r25, r31
    123a:	20 91 2c 03 	lds	r18, 0x032C
    123e:	30 91 2d 03 	lds	r19, 0x032D
    1242:	82 0f       	add	r24, r18
    1244:	93 1f       	adc	r25, r19
    1246:	fc 01       	movw	r30, r24
    1248:	ee 0f       	add	r30, r30
    124a:	ff 1f       	adc	r31, r31
    124c:	e8 5a       	subi	r30, 0xA8	; 168
    124e:	fc 4f       	sbci	r31, 0xFC	; 252
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	91 83       	std	Z+1, r25	; 0x01
    1256:	80 83       	st	Z, r24
							  }
	   
						}	   
	    
		 
						 if  (y_counter==9)  //top most line
    1258:	80 91 2c 03 	lds	r24, 0x032C
    125c:	90 91 2d 03 	lds	r25, 0x032D
    1260:	89 30       	cpi	r24, 0x09	; 9
    1262:	91 05       	cpc	r25, r1
    1264:	a1 f5       	brne	.+104    	; 0x12ce <scan_plot+0x180>
						{
							  if (plot[x_counter][y_counter-1]==0)
    1266:	80 91 fa 02 	lds	r24, 0x02FA
    126a:	90 91 fb 02 	lds	r25, 0x02FB
    126e:	88 0f       	add	r24, r24
    1270:	99 1f       	adc	r25, r25
    1272:	fc 01       	movw	r30, r24
    1274:	ee 0f       	add	r30, r30
    1276:	ff 1f       	adc	r31, r31
    1278:	ee 0f       	add	r30, r30
    127a:	ff 1f       	adc	r31, r31
    127c:	ee 0f       	add	r30, r30
    127e:	ff 1f       	adc	r31, r31
    1280:	8e 0f       	add	r24, r30
    1282:	9f 1f       	adc	r25, r31
    1284:	fc 01       	movw	r30, r24
    1286:	ea 5a       	subi	r30, 0xAA	; 170
    1288:	fc 4f       	sbci	r31, 0xFC	; 252
    128a:	80 89       	ldd	r24, Z+16	; 0x10
    128c:	91 89       	ldd	r25, Z+17	; 0x11
    128e:	00 97       	sbiw	r24, 0x00	; 0
    1290:	f1 f4       	brne	.+60     	; 0x12ce <scan_plot+0x180>
								  {
									  left_block_scan();
    1292:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
									  plot[x_counter][y_counter-1]=1;
    1296:	80 91 fa 02 	lds	r24, 0x02FA
    129a:	90 91 fb 02 	lds	r25, 0x02FB
    129e:	fc 01       	movw	r30, r24
    12a0:	ee 0f       	add	r30, r30
    12a2:	ff 1f       	adc	r31, r31
    12a4:	ee 0f       	add	r30, r30
    12a6:	ff 1f       	adc	r31, r31
    12a8:	ee 0f       	add	r30, r30
    12aa:	ff 1f       	adc	r31, r31
    12ac:	8e 0f       	add	r24, r30
    12ae:	9f 1f       	adc	r25, r31
    12b0:	20 91 2c 03 	lds	r18, 0x032C
    12b4:	30 91 2d 03 	lds	r19, 0x032D
    12b8:	82 0f       	add	r24, r18
    12ba:	93 1f       	adc	r25, r19
    12bc:	fc 01       	movw	r30, r24
    12be:	ee 0f       	add	r30, r30
    12c0:	ff 1f       	adc	r31, r31
    12c2:	ec 5a       	subi	r30, 0xAC	; 172
    12c4:	fc 4f       	sbci	r31, 0xFC	; 252
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	91 83       	std	Z+1, r25	; 0x01
    12cc:	80 83       	st	Z, r24
								  }
						}
	  
	  
	  					if  (y_counter==1)     //bottom line
    12ce:	80 91 2c 03 	lds	r24, 0x032C
    12d2:	90 91 2d 03 	lds	r25, 0x032D
    12d6:	81 30       	cpi	r24, 0x01	; 1
    12d8:	91 05       	cpc	r25, r1
    12da:	a1 f5       	brne	.+104    	; 0x1344 <scan_plot+0x1f6>
						{
							if (plot[x_counter][y_counter+1]==0)
    12dc:	80 91 fa 02 	lds	r24, 0x02FA
    12e0:	90 91 fb 02 	lds	r25, 0x02FB
    12e4:	88 0f       	add	r24, r24
    12e6:	99 1f       	adc	r25, r25
    12e8:	fc 01       	movw	r30, r24
    12ea:	ee 0f       	add	r30, r30
    12ec:	ff 1f       	adc	r31, r31
    12ee:	ee 0f       	add	r30, r30
    12f0:	ff 1f       	adc	r31, r31
    12f2:	ee 0f       	add	r30, r30
    12f4:	ff 1f       	adc	r31, r31
    12f6:	8e 0f       	add	r24, r30
    12f8:	9f 1f       	adc	r25, r31
    12fa:	fc 01       	movw	r30, r24
    12fc:	ea 5a       	subi	r30, 0xAA	; 170
    12fe:	fc 4f       	sbci	r31, 0xFC	; 252
    1300:	84 81       	ldd	r24, Z+4	; 0x04
    1302:	95 81       	ldd	r25, Z+5	; 0x05
    1304:	00 97       	sbiw	r24, 0x00	; 0
    1306:	f1 f4       	brne	.+60     	; 0x1344 <scan_plot+0x1f6>
							{  
								right_block_scan();
    1308:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
								plot[x_counter][y_counter+1]=1;
    130c:	80 91 fa 02 	lds	r24, 0x02FA
    1310:	90 91 fb 02 	lds	r25, 0x02FB
    1314:	fc 01       	movw	r30, r24
    1316:	ee 0f       	add	r30, r30
    1318:	ff 1f       	adc	r31, r31
    131a:	ee 0f       	add	r30, r30
    131c:	ff 1f       	adc	r31, r31
    131e:	ee 0f       	add	r30, r30
    1320:	ff 1f       	adc	r31, r31
    1322:	8e 0f       	add	r24, r30
    1324:	9f 1f       	adc	r25, r31
    1326:	20 91 2c 03 	lds	r18, 0x032C
    132a:	30 91 2d 03 	lds	r19, 0x032D
    132e:	82 0f       	add	r24, r18
    1330:	93 1f       	adc	r25, r19
    1332:	fc 01       	movw	r30, r24
    1334:	ee 0f       	add	r30, r30
    1336:	ff 1f       	adc	r31, r31
    1338:	e8 5a       	subi	r30, 0xA8	; 168
    133a:	fc 4f       	sbci	r31, 0xFC	; 252
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	91 83       	std	Z+1, r25	; 0x01
    1342:	80 83       	st	Z, r24
							}
						}
	 
					}	    
			 // if orientation=1 => bot
	          if(orientation==1)
    1344:	80 91 34 03 	lds	r24, 0x0334
    1348:	90 91 35 03 	lds	r25, 0x0335
    134c:	81 30       	cpi	r24, 0x01	; 1
    134e:	91 05       	cpc	r25, r1
    1350:	09 f0       	breq	.+2      	; 0x1354 <scan_plot+0x206>
    1352:	f1 c0       	rjmp	.+482    	; 0x1536 <scan_plot+0x3e8>
					 {  
					   if ( (y_counter<9) && (y_counter>1) ) //somewhere in between
    1354:	80 91 2c 03 	lds	r24, 0x032C
    1358:	90 91 2d 03 	lds	r25, 0x032D
    135c:	9c 01       	movw	r18, r24
    135e:	22 50       	subi	r18, 0x02	; 2
    1360:	30 40       	sbci	r19, 0x00	; 0
    1362:	27 30       	cpi	r18, 0x07	; 7
    1364:	31 05       	cpc	r19, r1
    1366:	08 f0       	brcs	.+2      	; 0x136a <scan_plot+0x21c>
    1368:	70 c0       	rjmp	.+224    	; 0x144a <scan_plot+0x2fc>
					   {
						   if(plot[x_counter][y_counter-1]==0)
    136a:	20 91 fa 02 	lds	r18, 0x02FA
    136e:	30 91 fb 02 	lds	r19, 0x02FB
    1372:	f9 01       	movw	r30, r18
    1374:	ee 0f       	add	r30, r30
    1376:	ff 1f       	adc	r31, r31
    1378:	ee 0f       	add	r30, r30
    137a:	ff 1f       	adc	r31, r31
    137c:	ee 0f       	add	r30, r30
    137e:	ff 1f       	adc	r31, r31
    1380:	2e 0f       	add	r18, r30
    1382:	3f 1f       	adc	r19, r31
    1384:	82 0f       	add	r24, r18
    1386:	93 1f       	adc	r25, r19
    1388:	fc 01       	movw	r30, r24
    138a:	ee 0f       	add	r30, r30
    138c:	ff 1f       	adc	r31, r31
    138e:	ec 5a       	subi	r30, 0xAC	; 172
    1390:	fc 4f       	sbci	r31, 0xFC	; 252
    1392:	80 81       	ld	r24, Z
    1394:	91 81       	ldd	r25, Z+1	; 0x01
    1396:	00 97       	sbiw	r24, 0x00	; 0
    1398:	f1 f4       	brne	.+60     	; 0x13d6 <scan_plot+0x288>
						   {
							   right_block_scan();
    139a:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
							   plot[x_counter][y_counter-1]=1;
    139e:	80 91 fa 02 	lds	r24, 0x02FA
    13a2:	90 91 fb 02 	lds	r25, 0x02FB
    13a6:	fc 01       	movw	r30, r24
    13a8:	ee 0f       	add	r30, r30
    13aa:	ff 1f       	adc	r31, r31
    13ac:	ee 0f       	add	r30, r30
    13ae:	ff 1f       	adc	r31, r31
    13b0:	ee 0f       	add	r30, r30
    13b2:	ff 1f       	adc	r31, r31
    13b4:	8e 0f       	add	r24, r30
    13b6:	9f 1f       	adc	r25, r31
    13b8:	20 91 2c 03 	lds	r18, 0x032C
    13bc:	30 91 2d 03 	lds	r19, 0x032D
    13c0:	82 0f       	add	r24, r18
    13c2:	93 1f       	adc	r25, r19
    13c4:	fc 01       	movw	r30, r24
    13c6:	ee 0f       	add	r30, r30
    13c8:	ff 1f       	adc	r31, r31
    13ca:	ec 5a       	subi	r30, 0xAC	; 172
    13cc:	fc 4f       	sbci	r31, 0xFC	; 252
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	91 83       	std	Z+1, r25	; 0x01
    13d4:	80 83       	st	Z, r24
						   }
		   
						   if (plot[x_counter][y_counter+1]==0)
    13d6:	80 91 fa 02 	lds	r24, 0x02FA
    13da:	90 91 fb 02 	lds	r25, 0x02FB
    13de:	fc 01       	movw	r30, r24
    13e0:	ee 0f       	add	r30, r30
    13e2:	ff 1f       	adc	r31, r31
    13e4:	ee 0f       	add	r30, r30
    13e6:	ff 1f       	adc	r31, r31
    13e8:	ee 0f       	add	r30, r30
    13ea:	ff 1f       	adc	r31, r31
    13ec:	8e 0f       	add	r24, r30
    13ee:	9f 1f       	adc	r25, r31
    13f0:	20 91 2c 03 	lds	r18, 0x032C
    13f4:	30 91 2d 03 	lds	r19, 0x032D
    13f8:	82 0f       	add	r24, r18
    13fa:	93 1f       	adc	r25, r19
    13fc:	fc 01       	movw	r30, r24
    13fe:	ee 0f       	add	r30, r30
    1400:	ff 1f       	adc	r31, r31
    1402:	e8 5a       	subi	r30, 0xA8	; 168
    1404:	fc 4f       	sbci	r31, 0xFC	; 252
    1406:	80 81       	ld	r24, Z
    1408:	91 81       	ldd	r25, Z+1	; 0x01
    140a:	00 97       	sbiw	r24, 0x00	; 0
    140c:	f1 f4       	brne	.+60     	; 0x144a <scan_plot+0x2fc>
						   {
							   left_block_scan();
    140e:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
						       plot[x_counter][y_counter+1]=1;
    1412:	80 91 fa 02 	lds	r24, 0x02FA
    1416:	90 91 fb 02 	lds	r25, 0x02FB
    141a:	fc 01       	movw	r30, r24
    141c:	ee 0f       	add	r30, r30
    141e:	ff 1f       	adc	r31, r31
    1420:	ee 0f       	add	r30, r30
    1422:	ff 1f       	adc	r31, r31
    1424:	ee 0f       	add	r30, r30
    1426:	ff 1f       	adc	r31, r31
    1428:	8e 0f       	add	r24, r30
    142a:	9f 1f       	adc	r25, r31
    142c:	20 91 2c 03 	lds	r18, 0x032C
    1430:	30 91 2d 03 	lds	r19, 0x032D
    1434:	82 0f       	add	r24, r18
    1436:	93 1f       	adc	r25, r19
    1438:	fc 01       	movw	r30, r24
    143a:	ee 0f       	add	r30, r30
    143c:	ff 1f       	adc	r31, r31
    143e:	e8 5a       	subi	r30, 0xA8	; 168
    1440:	fc 4f       	sbci	r31, 0xFC	; 252
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	91 83       	std	Z+1, r25	; 0x01
    1448:	80 83       	st	Z, r24
						   }
		   
					   }
	   
	   
					   if  (y_counter==9)   //top most line
    144a:	80 91 2c 03 	lds	r24, 0x032C
    144e:	90 91 2d 03 	lds	r25, 0x032D
    1452:	89 30       	cpi	r24, 0x09	; 9
    1454:	91 05       	cpc	r25, r1
    1456:	a1 f5       	brne	.+104    	; 0x14c0 <scan_plot+0x372>
					   {
						   if (plot[x_counter][y_counter-1]==0)
    1458:	80 91 fa 02 	lds	r24, 0x02FA
    145c:	90 91 fb 02 	lds	r25, 0x02FB
    1460:	88 0f       	add	r24, r24
    1462:	99 1f       	adc	r25, r25
    1464:	fc 01       	movw	r30, r24
    1466:	ee 0f       	add	r30, r30
    1468:	ff 1f       	adc	r31, r31
    146a:	ee 0f       	add	r30, r30
    146c:	ff 1f       	adc	r31, r31
    146e:	ee 0f       	add	r30, r30
    1470:	ff 1f       	adc	r31, r31
    1472:	8e 0f       	add	r24, r30
    1474:	9f 1f       	adc	r25, r31
    1476:	fc 01       	movw	r30, r24
    1478:	ea 5a       	subi	r30, 0xAA	; 170
    147a:	fc 4f       	sbci	r31, 0xFC	; 252
    147c:	80 89       	ldd	r24, Z+16	; 0x10
    147e:	91 89       	ldd	r25, Z+17	; 0x11
    1480:	00 97       	sbiw	r24, 0x00	; 0
    1482:	f1 f4       	brne	.+60     	; 0x14c0 <scan_plot+0x372>
						   {
							  right_block_scan();
    1484:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
							  plot[x_counter][y_counter-1]=1;
    1488:	80 91 fa 02 	lds	r24, 0x02FA
    148c:	90 91 fb 02 	lds	r25, 0x02FB
    1490:	fc 01       	movw	r30, r24
    1492:	ee 0f       	add	r30, r30
    1494:	ff 1f       	adc	r31, r31
    1496:	ee 0f       	add	r30, r30
    1498:	ff 1f       	adc	r31, r31
    149a:	ee 0f       	add	r30, r30
    149c:	ff 1f       	adc	r31, r31
    149e:	8e 0f       	add	r24, r30
    14a0:	9f 1f       	adc	r25, r31
    14a2:	20 91 2c 03 	lds	r18, 0x032C
    14a6:	30 91 2d 03 	lds	r19, 0x032D
    14aa:	82 0f       	add	r24, r18
    14ac:	93 1f       	adc	r25, r19
    14ae:	fc 01       	movw	r30, r24
    14b0:	ee 0f       	add	r30, r30
    14b2:	ff 1f       	adc	r31, r31
    14b4:	ec 5a       	subi	r30, 0xAC	; 172
    14b6:	fc 4f       	sbci	r31, 0xFC	; 252
    14b8:	81 e0       	ldi	r24, 0x01	; 1
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	91 83       	std	Z+1, r25	; 0x01
    14be:	80 83       	st	Z, r24
						   }
					   }
	   
	   
					   if  (y_counter==1) // bottom line
    14c0:	80 91 2c 03 	lds	r24, 0x032C
    14c4:	90 91 2d 03 	lds	r25, 0x032D
    14c8:	81 30       	cpi	r24, 0x01	; 1
    14ca:	91 05       	cpc	r25, r1
    14cc:	a1 f5       	brne	.+104    	; 0x1536 <scan_plot+0x3e8>
					   {
						   if (plot[x_counter][y_counter+1]==0)
    14ce:	80 91 fa 02 	lds	r24, 0x02FA
    14d2:	90 91 fb 02 	lds	r25, 0x02FB
    14d6:	88 0f       	add	r24, r24
    14d8:	99 1f       	adc	r25, r25
    14da:	fc 01       	movw	r30, r24
    14dc:	ee 0f       	add	r30, r30
    14de:	ff 1f       	adc	r31, r31
    14e0:	ee 0f       	add	r30, r30
    14e2:	ff 1f       	adc	r31, r31
    14e4:	ee 0f       	add	r30, r30
    14e6:	ff 1f       	adc	r31, r31
    14e8:	8e 0f       	add	r24, r30
    14ea:	9f 1f       	adc	r25, r31
    14ec:	fc 01       	movw	r30, r24
    14ee:	ea 5a       	subi	r30, 0xAA	; 170
    14f0:	fc 4f       	sbci	r31, 0xFC	; 252
    14f2:	84 81       	ldd	r24, Z+4	; 0x04
    14f4:	95 81       	ldd	r25, Z+5	; 0x05
    14f6:	00 97       	sbiw	r24, 0x00	; 0
    14f8:	f1 f4       	brne	.+60     	; 0x1536 <scan_plot+0x3e8>
						   {
							   left_block_scan();
    14fa:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
							   plot[x_counter][y_counter+1]=1;
    14fe:	80 91 fa 02 	lds	r24, 0x02FA
    1502:	90 91 fb 02 	lds	r25, 0x02FB
    1506:	fc 01       	movw	r30, r24
    1508:	ee 0f       	add	r30, r30
    150a:	ff 1f       	adc	r31, r31
    150c:	ee 0f       	add	r30, r30
    150e:	ff 1f       	adc	r31, r31
    1510:	ee 0f       	add	r30, r30
    1512:	ff 1f       	adc	r31, r31
    1514:	8e 0f       	add	r24, r30
    1516:	9f 1f       	adc	r25, r31
    1518:	20 91 2c 03 	lds	r18, 0x032C
    151c:	30 91 2d 03 	lds	r19, 0x032D
    1520:	82 0f       	add	r24, r18
    1522:	93 1f       	adc	r25, r19
    1524:	fc 01       	movw	r30, r24
    1526:	ee 0f       	add	r30, r30
    1528:	ff 1f       	adc	r31, r31
    152a:	e8 5a       	subi	r30, 0xA8	; 168
    152c:	fc 4f       	sbci	r31, 0xFC	; 252
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	91 83       	std	Z+1, r25	; 0x01
    1534:	80 83       	st	Z, r24
						   }
					   }
		    }	      
	   }	  
	
 if (y_counter%2==0)
    1536:	80 91 2c 03 	lds	r24, 0x032C
    153a:	90 91 2d 03 	lds	r25, 0x032D
    153e:	80 fd       	sbrc	r24, 0
    1540:	d3 c1       	rjmp	.+934    	; 0x18e8 <scan_plot+0x79a>
	{
		//orientation =1   bot
		if (orientation ==0)
    1542:	20 91 34 03 	lds	r18, 0x0334
    1546:	30 91 35 03 	lds	r19, 0x0335
    154a:	21 15       	cp	r18, r1
    154c:	31 05       	cpc	r19, r1
    154e:	09 f0       	breq	.+2      	; 0x1552 <scan_plot+0x404>
    1550:	e0 c0       	rjmp	.+448    	; 0x1712 <scan_plot+0x5c4>
		{	if ( (x_counter<9) && (x_counter>1) ) //somewhere in between
    1552:	20 91 fa 02 	lds	r18, 0x02FA
    1556:	30 91 fb 02 	lds	r19, 0x02FB
    155a:	a9 01       	movw	r20, r18
    155c:	42 50       	subi	r20, 0x02	; 2
    155e:	50 40       	sbci	r21, 0x00	; 0
    1560:	47 30       	cpi	r20, 0x07	; 7
    1562:	51 05       	cpc	r21, r1
    1564:	08 f0       	brcs	.+2      	; 0x1568 <scan_plot+0x41a>
    1566:	71 c0       	rjmp	.+226    	; 0x164a <scan_plot+0x4fc>
			{
				if(plot[x_counter-1][y_counter]==0)
    1568:	21 50       	subi	r18, 0x01	; 1
    156a:	30 40       	sbci	r19, 0x00	; 0
    156c:	f9 01       	movw	r30, r18
    156e:	ee 0f       	add	r30, r30
    1570:	ff 1f       	adc	r31, r31
    1572:	ee 0f       	add	r30, r30
    1574:	ff 1f       	adc	r31, r31
    1576:	ee 0f       	add	r30, r30
    1578:	ff 1f       	adc	r31, r31
    157a:	2e 0f       	add	r18, r30
    157c:	3f 1f       	adc	r19, r31
    157e:	82 0f       	add	r24, r18
    1580:	93 1f       	adc	r25, r19
    1582:	fc 01       	movw	r30, r24
    1584:	ee 0f       	add	r30, r30
    1586:	ff 1f       	adc	r31, r31
    1588:	ea 5a       	subi	r30, 0xAA	; 170
    158a:	fc 4f       	sbci	r31, 0xFC	; 252
    158c:	80 81       	ld	r24, Z
    158e:	91 81       	ldd	r25, Z+1	; 0x01
    1590:	00 97       	sbiw	r24, 0x00	; 0
    1592:	f9 f4       	brne	.+62     	; 0x15d2 <scan_plot+0x484>
				{
					left_block_scan();
    1594:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
					plot[x_counter-1][y_counter]=1;
    1598:	80 91 fa 02 	lds	r24, 0x02FA
    159c:	90 91 fb 02 	lds	r25, 0x02FB
    15a0:	01 97       	sbiw	r24, 0x01	; 1
    15a2:	fc 01       	movw	r30, r24
    15a4:	ee 0f       	add	r30, r30
    15a6:	ff 1f       	adc	r31, r31
    15a8:	ee 0f       	add	r30, r30
    15aa:	ff 1f       	adc	r31, r31
    15ac:	ee 0f       	add	r30, r30
    15ae:	ff 1f       	adc	r31, r31
    15b0:	8e 0f       	add	r24, r30
    15b2:	9f 1f       	adc	r25, r31
    15b4:	20 91 2c 03 	lds	r18, 0x032C
    15b8:	30 91 2d 03 	lds	r19, 0x032D
    15bc:	82 0f       	add	r24, r18
    15be:	93 1f       	adc	r25, r19
    15c0:	fc 01       	movw	r30, r24
    15c2:	ee 0f       	add	r30, r30
    15c4:	ff 1f       	adc	r31, r31
    15c6:	ea 5a       	subi	r30, 0xAA	; 170
    15c8:	fc 4f       	sbci	r31, 0xFC	; 252
    15ca:	81 e0       	ldi	r24, 0x01	; 1
    15cc:	90 e0       	ldi	r25, 0x00	; 0
    15ce:	91 83       	std	Z+1, r25	; 0x01
    15d0:	80 83       	st	Z, r24
					
				}
				
				if (plot[x_counter+1][y_counter]==0)
    15d2:	80 91 fa 02 	lds	r24, 0x02FA
    15d6:	90 91 fb 02 	lds	r25, 0x02FB
    15da:	01 96       	adiw	r24, 0x01	; 1
    15dc:	fc 01       	movw	r30, r24
    15de:	ee 0f       	add	r30, r30
    15e0:	ff 1f       	adc	r31, r31
    15e2:	ee 0f       	add	r30, r30
    15e4:	ff 1f       	adc	r31, r31
    15e6:	ee 0f       	add	r30, r30
    15e8:	ff 1f       	adc	r31, r31
    15ea:	8e 0f       	add	r24, r30
    15ec:	9f 1f       	adc	r25, r31
    15ee:	20 91 2c 03 	lds	r18, 0x032C
    15f2:	30 91 2d 03 	lds	r19, 0x032D
    15f6:	82 0f       	add	r24, r18
    15f8:	93 1f       	adc	r25, r19
    15fa:	fc 01       	movw	r30, r24
    15fc:	ee 0f       	add	r30, r30
    15fe:	ff 1f       	adc	r31, r31
    1600:	ea 5a       	subi	r30, 0xAA	; 170
    1602:	fc 4f       	sbci	r31, 0xFC	; 252
    1604:	80 81       	ld	r24, Z
    1606:	91 81       	ldd	r25, Z+1	; 0x01
    1608:	00 97       	sbiw	r24, 0x00	; 0
    160a:	f9 f4       	brne	.+62     	; 0x164a <scan_plot+0x4fc>
				{
					right_block_scan();
    160c:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
				    plot[x_counter+1][y_counter]=1;
    1610:	80 91 fa 02 	lds	r24, 0x02FA
    1614:	90 91 fb 02 	lds	r25, 0x02FB
    1618:	01 96       	adiw	r24, 0x01	; 1
    161a:	fc 01       	movw	r30, r24
    161c:	ee 0f       	add	r30, r30
    161e:	ff 1f       	adc	r31, r31
    1620:	ee 0f       	add	r30, r30
    1622:	ff 1f       	adc	r31, r31
    1624:	ee 0f       	add	r30, r30
    1626:	ff 1f       	adc	r31, r31
    1628:	8e 0f       	add	r24, r30
    162a:	9f 1f       	adc	r25, r31
    162c:	20 91 2c 03 	lds	r18, 0x032C
    1630:	30 91 2d 03 	lds	r19, 0x032D
    1634:	82 0f       	add	r24, r18
    1636:	93 1f       	adc	r25, r19
    1638:	fc 01       	movw	r30, r24
    163a:	ee 0f       	add	r30, r30
    163c:	ff 1f       	adc	r31, r31
    163e:	ea 5a       	subi	r30, 0xAA	; 170
    1640:	fc 4f       	sbci	r31, 0xFC	; 252
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	91 83       	std	Z+1, r25	; 0x01
    1648:	80 83       	st	Z, r24
				}
				
			}
			  
			
			if  (x_counter==9)  //right most line
    164a:	80 91 fa 02 	lds	r24, 0x02FA
    164e:	90 91 fb 02 	lds	r25, 0x02FB
    1652:	89 30       	cpi	r24, 0x09	; 9
    1654:	91 05       	cpc	r25, r1
    1656:	59 f5       	brne	.+86     	; 0x16ae <scan_plot+0x560>
			{
				if (plot[x_counter-1][y_counter]==0)
    1658:	e0 91 2c 03 	lds	r30, 0x032C
    165c:	f0 91 2d 03 	lds	r31, 0x032D
    1660:	ee 0f       	add	r30, r30
    1662:	ff 1f       	adc	r31, r31
    1664:	ea 51       	subi	r30, 0x1A	; 26
    1666:	fc 4f       	sbci	r31, 0xFC	; 252
    1668:	80 81       	ld	r24, Z
    166a:	91 81       	ldd	r25, Z+1	; 0x01
    166c:	00 97       	sbiw	r24, 0x00	; 0
    166e:	f9 f4       	brne	.+62     	; 0x16ae <scan_plot+0x560>
				{
					left_block_scan();
    1670:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
				    plot[x_counter-1][y_counter]=1;
    1674:	80 91 fa 02 	lds	r24, 0x02FA
    1678:	90 91 fb 02 	lds	r25, 0x02FB
    167c:	01 97       	sbiw	r24, 0x01	; 1
    167e:	fc 01       	movw	r30, r24
    1680:	ee 0f       	add	r30, r30
    1682:	ff 1f       	adc	r31, r31
    1684:	ee 0f       	add	r30, r30
    1686:	ff 1f       	adc	r31, r31
    1688:	ee 0f       	add	r30, r30
    168a:	ff 1f       	adc	r31, r31
    168c:	8e 0f       	add	r24, r30
    168e:	9f 1f       	adc	r25, r31
    1690:	20 91 2c 03 	lds	r18, 0x032C
    1694:	30 91 2d 03 	lds	r19, 0x032D
    1698:	82 0f       	add	r24, r18
    169a:	93 1f       	adc	r25, r19
    169c:	fc 01       	movw	r30, r24
    169e:	ee 0f       	add	r30, r30
    16a0:	ff 1f       	adc	r31, r31
    16a2:	ea 5a       	subi	r30, 0xAA	; 170
    16a4:	fc 4f       	sbci	r31, 0xFC	; 252
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	91 83       	std	Z+1, r25	; 0x01
    16ac:	80 83       	st	Z, r24
				}
			}
			
			
			if  (x_counter==1)     //left  most line
    16ae:	80 91 fa 02 	lds	r24, 0x02FA
    16b2:	90 91 fb 02 	lds	r25, 0x02FB
    16b6:	81 30       	cpi	r24, 0x01	; 1
    16b8:	91 05       	cpc	r25, r1
    16ba:	59 f5       	brne	.+86     	; 0x1712 <scan_plot+0x5c4>
			{
				if (plot[x_counter+1][y_counter]==0)
    16bc:	e0 91 2c 03 	lds	r30, 0x032C
    16c0:	f0 91 2d 03 	lds	r31, 0x032D
    16c4:	ee 0f       	add	r30, r30
    16c6:	ff 1f       	adc	r31, r31
    16c8:	e6 58       	subi	r30, 0x86	; 134
    16ca:	fc 4f       	sbci	r31, 0xFC	; 252
    16cc:	80 81       	ld	r24, Z
    16ce:	91 81       	ldd	r25, Z+1	; 0x01
    16d0:	00 97       	sbiw	r24, 0x00	; 0
    16d2:	f9 f4       	brne	.+62     	; 0x1712 <scan_plot+0x5c4>
				{
					right_block_scan();
    16d4:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
				    plot[x_counter+1][y_counter]=1;
    16d8:	80 91 fa 02 	lds	r24, 0x02FA
    16dc:	90 91 fb 02 	lds	r25, 0x02FB
    16e0:	01 96       	adiw	r24, 0x01	; 1
    16e2:	fc 01       	movw	r30, r24
    16e4:	ee 0f       	add	r30, r30
    16e6:	ff 1f       	adc	r31, r31
    16e8:	ee 0f       	add	r30, r30
    16ea:	ff 1f       	adc	r31, r31
    16ec:	ee 0f       	add	r30, r30
    16ee:	ff 1f       	adc	r31, r31
    16f0:	8e 0f       	add	r24, r30
    16f2:	9f 1f       	adc	r25, r31
    16f4:	20 91 2c 03 	lds	r18, 0x032C
    16f8:	30 91 2d 03 	lds	r19, 0x032D
    16fc:	82 0f       	add	r24, r18
    16fe:	93 1f       	adc	r25, r19
    1700:	fc 01       	movw	r30, r24
    1702:	ee 0f       	add	r30, r30
    1704:	ff 1f       	adc	r31, r31
    1706:	ea 5a       	subi	r30, 0xAA	; 170
    1708:	fc 4f       	sbci	r31, 0xFC	; 252
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	91 83       	std	Z+1, r25	; 0x01
    1710:	80 83       	st	Z, r24
				}
			}
			
		}
		// if orientation=1 => bot
		if(orientation==2)
    1712:	80 91 34 03 	lds	r24, 0x0334
    1716:	90 91 35 03 	lds	r25, 0x0335
    171a:	82 30       	cpi	r24, 0x02	; 2
    171c:	91 05       	cpc	r25, r1
    171e:	09 f0       	breq	.+2      	; 0x1722 <scan_plot+0x5d4>
    1720:	e3 c0       	rjmp	.+454    	; 0x18e8 <scan_plot+0x79a>
		{
			if ( (x_counter<9) && (x_counter>1) ) //somewhere in between
    1722:	80 91 fa 02 	lds	r24, 0x02FA
    1726:	90 91 fb 02 	lds	r25, 0x02FB
    172a:	9c 01       	movw	r18, r24
    172c:	22 50       	subi	r18, 0x02	; 2
    172e:	30 40       	sbci	r19, 0x00	; 0
    1730:	27 30       	cpi	r18, 0x07	; 7
    1732:	31 05       	cpc	r19, r1
    1734:	08 f0       	brcs	.+2      	; 0x1738 <scan_plot+0x5ea>
    1736:	74 c0       	rjmp	.+232    	; 0x1820 <scan_plot+0x6d2>
			{
				if(plot[x_counter-1][y_counter]==0)
    1738:	01 97       	sbiw	r24, 0x01	; 1
    173a:	fc 01       	movw	r30, r24
    173c:	ee 0f       	add	r30, r30
    173e:	ff 1f       	adc	r31, r31
    1740:	ee 0f       	add	r30, r30
    1742:	ff 1f       	adc	r31, r31
    1744:	ee 0f       	add	r30, r30
    1746:	ff 1f       	adc	r31, r31
    1748:	8e 0f       	add	r24, r30
    174a:	9f 1f       	adc	r25, r31
    174c:	20 91 2c 03 	lds	r18, 0x032C
    1750:	30 91 2d 03 	lds	r19, 0x032D
    1754:	82 0f       	add	r24, r18
    1756:	93 1f       	adc	r25, r19
    1758:	fc 01       	movw	r30, r24
    175a:	ee 0f       	add	r30, r30
    175c:	ff 1f       	adc	r31, r31
    175e:	ea 5a       	subi	r30, 0xAA	; 170
    1760:	fc 4f       	sbci	r31, 0xFC	; 252
    1762:	80 81       	ld	r24, Z
    1764:	91 81       	ldd	r25, Z+1	; 0x01
    1766:	00 97       	sbiw	r24, 0x00	; 0
    1768:	f9 f4       	brne	.+62     	; 0x17a8 <scan_plot+0x65a>
				{
					right_block_scan();
    176a:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
					plot[x_counter-1][y_counter]=1;
    176e:	80 91 fa 02 	lds	r24, 0x02FA
    1772:	90 91 fb 02 	lds	r25, 0x02FB
    1776:	01 97       	sbiw	r24, 0x01	; 1
    1778:	fc 01       	movw	r30, r24
    177a:	ee 0f       	add	r30, r30
    177c:	ff 1f       	adc	r31, r31
    177e:	ee 0f       	add	r30, r30
    1780:	ff 1f       	adc	r31, r31
    1782:	ee 0f       	add	r30, r30
    1784:	ff 1f       	adc	r31, r31
    1786:	8e 0f       	add	r24, r30
    1788:	9f 1f       	adc	r25, r31
    178a:	20 91 2c 03 	lds	r18, 0x032C
    178e:	30 91 2d 03 	lds	r19, 0x032D
    1792:	82 0f       	add	r24, r18
    1794:	93 1f       	adc	r25, r19
    1796:	fc 01       	movw	r30, r24
    1798:	ee 0f       	add	r30, r30
    179a:	ff 1f       	adc	r31, r31
    179c:	ea 5a       	subi	r30, 0xAA	; 170
    179e:	fc 4f       	sbci	r31, 0xFC	; 252
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	90 e0       	ldi	r25, 0x00	; 0
    17a4:	91 83       	std	Z+1, r25	; 0x01
    17a6:	80 83       	st	Z, r24
				}
				
				if (plot[x_counter+1][y_counter]==0)
    17a8:	80 91 fa 02 	lds	r24, 0x02FA
    17ac:	90 91 fb 02 	lds	r25, 0x02FB
    17b0:	01 96       	adiw	r24, 0x01	; 1
    17b2:	fc 01       	movw	r30, r24
    17b4:	ee 0f       	add	r30, r30
    17b6:	ff 1f       	adc	r31, r31
    17b8:	ee 0f       	add	r30, r30
    17ba:	ff 1f       	adc	r31, r31
    17bc:	ee 0f       	add	r30, r30
    17be:	ff 1f       	adc	r31, r31
    17c0:	8e 0f       	add	r24, r30
    17c2:	9f 1f       	adc	r25, r31
    17c4:	20 91 2c 03 	lds	r18, 0x032C
    17c8:	30 91 2d 03 	lds	r19, 0x032D
    17cc:	82 0f       	add	r24, r18
    17ce:	93 1f       	adc	r25, r19
    17d0:	fc 01       	movw	r30, r24
    17d2:	ee 0f       	add	r30, r30
    17d4:	ff 1f       	adc	r31, r31
    17d6:	ea 5a       	subi	r30, 0xAA	; 170
    17d8:	fc 4f       	sbci	r31, 0xFC	; 252
    17da:	80 81       	ld	r24, Z
    17dc:	91 81       	ldd	r25, Z+1	; 0x01
    17de:	00 97       	sbiw	r24, 0x00	; 0
    17e0:	f9 f4       	brne	.+62     	; 0x1820 <scan_plot+0x6d2>
				{
					left_block_scan();
    17e2:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
					plot[x_counter+1][y_counter]=1;
    17e6:	80 91 fa 02 	lds	r24, 0x02FA
    17ea:	90 91 fb 02 	lds	r25, 0x02FB
    17ee:	01 96       	adiw	r24, 0x01	; 1
    17f0:	fc 01       	movw	r30, r24
    17f2:	ee 0f       	add	r30, r30
    17f4:	ff 1f       	adc	r31, r31
    17f6:	ee 0f       	add	r30, r30
    17f8:	ff 1f       	adc	r31, r31
    17fa:	ee 0f       	add	r30, r30
    17fc:	ff 1f       	adc	r31, r31
    17fe:	8e 0f       	add	r24, r30
    1800:	9f 1f       	adc	r25, r31
    1802:	20 91 2c 03 	lds	r18, 0x032C
    1806:	30 91 2d 03 	lds	r19, 0x032D
    180a:	82 0f       	add	r24, r18
    180c:	93 1f       	adc	r25, r19
    180e:	fc 01       	movw	r30, r24
    1810:	ee 0f       	add	r30, r30
    1812:	ff 1f       	adc	r31, r31
    1814:	ea 5a       	subi	r30, 0xAA	; 170
    1816:	fc 4f       	sbci	r31, 0xFC	; 252
    1818:	81 e0       	ldi	r24, 0x01	; 1
    181a:	90 e0       	ldi	r25, 0x00	; 0
    181c:	91 83       	std	Z+1, r25	; 0x01
    181e:	80 83       	st	Z, r24
				}
				
			}
			
			
			if  (x_counter==9)  //right most line
    1820:	80 91 fa 02 	lds	r24, 0x02FA
    1824:	90 91 fb 02 	lds	r25, 0x02FB
    1828:	89 30       	cpi	r24, 0x09	; 9
    182a:	91 05       	cpc	r25, r1
    182c:	59 f5       	brne	.+86     	; 0x1884 <scan_plot+0x736>
			{
				if (plot[x_counter-1][y_counter]==0)
    182e:	e0 91 2c 03 	lds	r30, 0x032C
    1832:	f0 91 2d 03 	lds	r31, 0x032D
    1836:	ee 0f       	add	r30, r30
    1838:	ff 1f       	adc	r31, r31
    183a:	ea 51       	subi	r30, 0x1A	; 26
    183c:	fc 4f       	sbci	r31, 0xFC	; 252
    183e:	80 81       	ld	r24, Z
    1840:	91 81       	ldd	r25, Z+1	; 0x01
    1842:	00 97       	sbiw	r24, 0x00	; 0
    1844:	f9 f4       	brne	.+62     	; 0x1884 <scan_plot+0x736>
				{
					right_block_scan();
    1846:	0e 94 5f 08 	call	0x10be	; 0x10be <right_block_scan>
					plot[x_counter-1][y_counter]=1;
    184a:	80 91 fa 02 	lds	r24, 0x02FA
    184e:	90 91 fb 02 	lds	r25, 0x02FB
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	fc 01       	movw	r30, r24
    1856:	ee 0f       	add	r30, r30
    1858:	ff 1f       	adc	r31, r31
    185a:	ee 0f       	add	r30, r30
    185c:	ff 1f       	adc	r31, r31
    185e:	ee 0f       	add	r30, r30
    1860:	ff 1f       	adc	r31, r31
    1862:	8e 0f       	add	r24, r30
    1864:	9f 1f       	adc	r25, r31
    1866:	20 91 2c 03 	lds	r18, 0x032C
    186a:	30 91 2d 03 	lds	r19, 0x032D
    186e:	82 0f       	add	r24, r18
    1870:	93 1f       	adc	r25, r19
    1872:	fc 01       	movw	r30, r24
    1874:	ee 0f       	add	r30, r30
    1876:	ff 1f       	adc	r31, r31
    1878:	ea 5a       	subi	r30, 0xAA	; 170
    187a:	fc 4f       	sbci	r31, 0xFC	; 252
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	91 83       	std	Z+1, r25	; 0x01
    1882:	80 83       	st	Z, r24
				}
			}
			
			
			if  (x_counter==1)     //left  most line
    1884:	80 91 fa 02 	lds	r24, 0x02FA
    1888:	90 91 fb 02 	lds	r25, 0x02FB
    188c:	81 30       	cpi	r24, 0x01	; 1
    188e:	91 05       	cpc	r25, r1
    1890:	59 f5       	brne	.+86     	; 0x18e8 <scan_plot+0x79a>
			{
				if (plot[x_counter+1][y_counter]==0)
    1892:	e0 91 2c 03 	lds	r30, 0x032C
    1896:	f0 91 2d 03 	lds	r31, 0x032D
    189a:	ee 0f       	add	r30, r30
    189c:	ff 1f       	adc	r31, r31
    189e:	e6 58       	subi	r30, 0x86	; 134
    18a0:	fc 4f       	sbci	r31, 0xFC	; 252
    18a2:	80 81       	ld	r24, Z
    18a4:	91 81       	ldd	r25, Z+1	; 0x01
    18a6:	00 97       	sbiw	r24, 0x00	; 0
    18a8:	f9 f4       	brne	.+62     	; 0x18e8 <scan_plot+0x79a>
				{
					left_block_scan();
    18aa:	0e 94 83 08 	call	0x1106	; 0x1106 <left_block_scan>
					plot[x_counter+1][y_counter]=1;
    18ae:	80 91 fa 02 	lds	r24, 0x02FA
    18b2:	90 91 fb 02 	lds	r25, 0x02FB
    18b6:	01 96       	adiw	r24, 0x01	; 1
    18b8:	fc 01       	movw	r30, r24
    18ba:	ee 0f       	add	r30, r30
    18bc:	ff 1f       	adc	r31, r31
    18be:	ee 0f       	add	r30, r30
    18c0:	ff 1f       	adc	r31, r31
    18c2:	ee 0f       	add	r30, r30
    18c4:	ff 1f       	adc	r31, r31
    18c6:	8e 0f       	add	r24, r30
    18c8:	9f 1f       	adc	r25, r31
    18ca:	20 91 2c 03 	lds	r18, 0x032C
    18ce:	30 91 2d 03 	lds	r19, 0x032D
    18d2:	82 0f       	add	r24, r18
    18d4:	93 1f       	adc	r25, r19
    18d6:	fc 01       	movw	r30, r24
    18d8:	ee 0f       	add	r30, r30
    18da:	ff 1f       	adc	r31, r31
    18dc:	ea 5a       	subi	r30, 0xAA	; 170
    18de:	fc 4f       	sbci	r31, 0xFC	; 252
    18e0:	81 e0       	ldi	r24, 0x01	; 1
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	91 83       	std	Z+1, r25	; 0x01
    18e6:	80 83       	st	Z, r24
    18e8:	08 95       	ret

000018ea <scan_black_block>:
	}
	

int scan_black_block (void)
{  int k;
	k=scan_block(); 
    18ea:	0e 94 08 08 	call	0x1010	; 0x1010 <scan_block>
    return k;
}
    18ee:	08 95       	ret

000018f0 <align_right>:
	
}	

// Align with black line present in right
void align_right(void)
{
    18f0:	cf 93       	push	r28
    18f2:	df 93       	push	r29
	velocity (180, 180);//150
    18f4:	84 eb       	ldi	r24, 0xB4	; 180
    18f6:	64 eb       	ldi	r22, 0xB4	; 180
    18f8:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
	right();
    18fc:	0e 94 45 03 	call	0x68a	; 0x68a <right>
	line_scan();
    1900:	0e 94 e7 04 	call	0x9ce	; 0x9ce <line_scan>
	
	while (S[2]==1)
    1904:	80 91 00 04 	lds	r24, 0x0400
    1908:	90 91 01 04 	lds	r25, 0x0401
    190c:	81 30       	cpi	r24, 0x01	; 1
    190e:	91 05       	cpc	r25, r1
    1910:	49 f4       	brne	.+18     	; 0x1924 <align_right+0x34>
    1912:	c0 e0       	ldi	r28, 0x00	; 0
    1914:	d4 e0       	ldi	r29, 0x04	; 4
	{
		line_scan();
    1916:	0e 94 e7 04 	call	0x9ce	; 0x9ce <line_scan>
{
	velocity (180, 180);//150
	right();
	line_scan();
	
	while (S[2]==1)
    191a:	88 81       	ld	r24, Y
    191c:	99 81       	ldd	r25, Y+1	; 0x01
    191e:	81 30       	cpi	r24, 0x01	; 1
    1920:	91 05       	cpc	r25, r1
    1922:	c9 f3       	breq	.-14     	; 0x1916 <align_right+0x26>
	{
		line_scan();
	}
	
	velocity (255, 255);
    1924:	8f ef       	ldi	r24, 0xFF	; 255
    1926:	6f ef       	ldi	r22, 0xFF	; 255
    1928:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
	stop();
    192c:	0e 94 49 03 	call	0x692	; 0x692 <stop>
}
    1930:	df 91       	pop	r29
    1932:	cf 91       	pop	r28
    1934:	08 95       	ret

00001936 <align_left>:

//Align with black line present in left
void align_left(void)
{
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
	velocity (180,180);
    193a:	84 eb       	ldi	r24, 0xB4	; 180
    193c:	64 eb       	ldi	r22, 0xB4	; 180
    193e:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
	left();
    1942:	0e 94 41 03 	call	0x682	; 0x682 <left>
	line_scan();
    1946:	0e 94 e7 04 	call	0x9ce	; 0x9ce <line_scan>
	
	while (S[2]==1)
    194a:	80 91 00 04 	lds	r24, 0x0400
    194e:	90 91 01 04 	lds	r25, 0x0401
    1952:	81 30       	cpi	r24, 0x01	; 1
    1954:	91 05       	cpc	r25, r1
    1956:	49 f4       	brne	.+18     	; 0x196a <align_left+0x34>
    1958:	c0 e0       	ldi	r28, 0x00	; 0
    195a:	d4 e0       	ldi	r29, 0x04	; 4
	{
		line_scan();
    195c:	0e 94 e7 04 	call	0x9ce	; 0x9ce <line_scan>
{
	velocity (180,180);
	left();
	line_scan();
	
	while (S[2]==1)
    1960:	88 81       	ld	r24, Y
    1962:	99 81       	ldd	r25, Y+1	; 0x01
    1964:	81 30       	cpi	r24, 0x01	; 1
    1966:	91 05       	cpc	r25, r1
    1968:	c9 f3       	breq	.-14     	; 0x195c <align_left+0x26>
	{
		line_scan();
		
	}
	
	velocity (255, 255);
    196a:	8f ef       	ldi	r24, 0xFF	; 255
    196c:	6f ef       	ldi	r22, 0xFF	; 255
    196e:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
	stop();
    1972:	0e 94 49 03 	call	0x692	; 0x692 <stop>
	
}
    1976:	df 91       	pop	r29
    1978:	cf 91       	pop	r28
    197a:	08 95       	ret

0000197c <right_90>:
 

// 90 degree right at grid lines
 void right_90(void)
	 { 
		 right_degrees(40);
    197c:	88 e2       	ldi	r24, 0x28	; 40
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	0e 94 74 04 	call	0x8e8	; 0x8e8 <right_degrees>

		 align_right();
    1984:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <align_right>
		
	  
	     
	      right_turns++;
    1988:	80 91 28 03 	lds	r24, 0x0328
    198c:	90 91 29 03 	lds	r25, 0x0329
    1990:	01 96       	adiw	r24, 0x01	; 1
    1992:	90 93 29 03 	sts	0x0329, r25
    1996:	80 93 28 03 	sts	0x0328, r24
	  
	  }
    199a:	08 95       	ret

0000199c <left_90>:
 

//90 degree turn left on grid lines
void  left_90 (void)
{   left_degrees(40);
    199c:	88 e2       	ldi	r24, 0x28	; 40
    199e:	90 e0       	ldi	r25, 0x00	; 0
    19a0:	0e 94 69 04 	call	0x8d2	; 0x8d2 <left_degrees>

	align_left();
    19a4:	0e 94 9b 0c 	call	0x1936	; 0x1936 <align_left>

  
   left_turns++;
    19a8:	80 91 26 03 	lds	r24, 0x0326
    19ac:	90 91 27 03 	lds	r25, 0x0327
    19b0:	01 96       	adiw	r24, 0x01	; 1
    19b2:	90 93 27 03 	sts	0x0327, r25
    19b6:	80 93 26 03 	sts	0x0326, r24
}
    19ba:	08 95       	ret

000019bc <increase_counter>:
// An alternate is provided for each condition


//  Increase x,y cordinates as per position of bot
void increase_counter (void)   
 { direction = right_turns-left_turns;
    19bc:	80 91 28 03 	lds	r24, 0x0328
    19c0:	90 91 29 03 	lds	r25, 0x0329
    19c4:	20 91 26 03 	lds	r18, 0x0326
    19c8:	30 91 27 03 	lds	r19, 0x0327
    19cc:	82 1b       	sub	r24, r18
    19ce:	93 0b       	sbc	r25, r19
    19d0:	90 93 25 03 	sts	0x0325, r25
    19d4:	80 93 24 03 	sts	0x0324, r24
	if ( (direction==0 ) || (direction==4) || (direction == -4))
    19d8:	00 97       	sbiw	r24, 0x00	; 0
    19da:	39 f0       	breq	.+14     	; 0x19ea <increase_counter+0x2e>
    19dc:	84 30       	cpi	r24, 0x04	; 4
    19de:	91 05       	cpc	r25, r1
    19e0:	21 f0       	breq	.+8      	; 0x19ea <increase_counter+0x2e>
    19e2:	2f ef       	ldi	r18, 0xFF	; 255
    19e4:	8c 3f       	cpi	r24, 0xFC	; 252
    19e6:	92 07       	cpc	r25, r18
    19e8:	b1 f4       	brne	.+44     	; 0x1a16 <increase_counter+0x5a>
	{
		y_counter++;
    19ea:	20 91 2c 03 	lds	r18, 0x032C
    19ee:	30 91 2d 03 	lds	r19, 0x032D
    19f2:	2f 5f       	subi	r18, 0xFF	; 255
    19f4:	3f 4f       	sbci	r19, 0xFF	; 255
    19f6:	30 93 2d 03 	sts	0x032D, r19
    19fa:	20 93 2c 03 	sts	0x032C, r18
		right_turns=0;
    19fe:	10 92 29 03 	sts	0x0329, r1
    1a02:	10 92 28 03 	sts	0x0328, r1
		left_turns=0;
    1a06:	10 92 27 03 	sts	0x0327, r1
    1a0a:	10 92 26 03 	sts	0x0326, r1
	    orientation=0;  // +y axis
    1a0e:	10 92 35 03 	sts	0x0335, r1
    1a12:	10 92 34 03 	sts	0x0334, r1
	}
	
	 if ( (direction==1) || (direction== -3) )
    1a16:	81 30       	cpi	r24, 0x01	; 1
    1a18:	91 05       	cpc	r25, r1
    1a1a:	21 f0       	breq	.+8      	; 0x1a24 <increase_counter+0x68>
    1a1c:	2f ef       	ldi	r18, 0xFF	; 255
    1a1e:	8d 3f       	cpi	r24, 0xFD	; 253
    1a20:	92 07       	cpc	r25, r18
    1a22:	81 f4       	brne	.+32     	; 0x1a44 <increase_counter+0x88>
	{
		x_counter++;
    1a24:	20 91 fa 02 	lds	r18, 0x02FA
    1a28:	30 91 fb 02 	lds	r19, 0x02FB
    1a2c:	2f 5f       	subi	r18, 0xFF	; 255
    1a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a30:	30 93 fb 02 	sts	0x02FB, r19
    1a34:	20 93 fa 02 	sts	0x02FA, r18
		orientation=1;  // +x axis
    1a38:	21 e0       	ldi	r18, 0x01	; 1
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	30 93 35 03 	sts	0x0335, r19
    1a40:	20 93 34 03 	sts	0x0334, r18
	}
   
    if (direction== -1 || direction == 3)
    1a44:	2f ef       	ldi	r18, 0xFF	; 255
    1a46:	8f 3f       	cpi	r24, 0xFF	; 255
    1a48:	92 07       	cpc	r25, r18
    1a4a:	19 f0       	breq	.+6      	; 0x1a52 <increase_counter+0x96>
    1a4c:	83 30       	cpi	r24, 0x03	; 3
    1a4e:	91 05       	cpc	r25, r1
    1a50:	81 f4       	brne	.+32     	; 0x1a72 <increase_counter+0xb6>
       {
		   x_counter--;
    1a52:	20 91 fa 02 	lds	r18, 0x02FA
    1a56:	30 91 fb 02 	lds	r19, 0x02FB
    1a5a:	21 50       	subi	r18, 0x01	; 1
    1a5c:	30 40       	sbci	r19, 0x00	; 0
    1a5e:	30 93 fb 02 	sts	0x02FB, r19
    1a62:	20 93 fa 02 	sts	0x02FA, r18
		   orientation=3; // -x axis
    1a66:	23 e0       	ldi	r18, 0x03	; 3
    1a68:	30 e0       	ldi	r19, 0x00	; 0
    1a6a:	30 93 35 03 	sts	0x0335, r19
    1a6e:	20 93 34 03 	sts	0x0334, r18
	   }
 
    if ( (direction==-2) || (direction ==2) )
    1a72:	2f ef       	ldi	r18, 0xFF	; 255
    1a74:	8e 3f       	cpi	r24, 0xFE	; 254
    1a76:	92 07       	cpc	r25, r18
    1a78:	19 f0       	breq	.+6      	; 0x1a80 <increase_counter+0xc4>
    1a7a:	82 30       	cpi	r24, 0x02	; 2
    1a7c:	91 05       	cpc	r25, r1
    1a7e:	79 f4       	brne	.+30     	; 0x1a9e <increase_counter+0xe2>
       {
		 y_counter--;
    1a80:	80 91 2c 03 	lds	r24, 0x032C
    1a84:	90 91 2d 03 	lds	r25, 0x032D
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	90 93 2d 03 	sts	0x032D, r25
    1a8e:	80 93 2c 03 	sts	0x032C, r24
		 orientation=2;   //-y axis
    1a92:	82 e0       	ldi	r24, 0x02	; 2
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	90 93 35 03 	sts	0x0335, r25
    1a9a:	80 93 34 03 	sts	0x0334, r24
	   }
   lcd_cursor(1,2);
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	62 e0       	ldi	r22, 0x02	; 2
    1aa2:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <lcd_cursor>
   lcd_string("x");
    1aa6:	82 e0       	ldi	r24, 0x02	; 2
    1aa8:	92 e0       	ldi	r25, 0x02	; 2
    1aaa:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_string>
   lcd_print(1,1, x_counter,1 );
    1aae:	40 91 fa 02 	lds	r20, 0x02FA
    1ab2:	50 91 fb 02 	lds	r21, 0x02FB
    1ab6:	81 e0       	ldi	r24, 0x01	; 1
    1ab8:	61 e0       	ldi	r22, 0x01	; 1
    1aba:	21 e0       	ldi	r18, 0x01	; 1
    1abc:	30 e0       	ldi	r19, 0x00	; 0
    1abe:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
   
   lcd_cursor(1,4);
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	64 e0       	ldi	r22, 0x04	; 4
    1ac6:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <lcd_cursor>
   lcd_string("y");
    1aca:	84 e0       	ldi	r24, 0x04	; 4
    1acc:	92 e0       	ldi	r25, 0x02	; 2
    1ace:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_string>
   lcd_print(1,3, y_counter, 1);
    1ad2:	40 91 2c 03 	lds	r20, 0x032C
    1ad6:	50 91 2d 03 	lds	r21, 0x032D
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	63 e0       	ldi	r22, 0x03	; 3
    1ade:	21 e0       	ldi	r18, 0x01	; 1
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
   
   lcd_cursor(1,5);
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	65 e0       	ldi	r22, 0x05	; 5
    1aea:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <lcd_cursor>
   lcd_string("o");
    1aee:	86 e0       	ldi	r24, 0x06	; 6
    1af0:	92 e0       	ldi	r25, 0x02	; 2
    1af2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_string>
   lcd_print(1,6, orientation,1);
    1af6:	40 91 34 03 	lds	r20, 0x0334
    1afa:	50 91 35 03 	lds	r21, 0x0335
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	66 e0       	ldi	r22, 0x06	; 6
    1b02:	21 e0       	ldi	r18, 0x01	; 1
    1b04:	30 e0       	ldi	r19, 0x00	; 0
    1b06:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
   connection=1;
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	90 e0       	ldi	r25, 0x00	; 0
    1b0e:	90 93 15 03 	sts	0x0315, r25
    1b12:	80 93 14 03 	sts	0x0314, r24
   send_data();
    1b16:	0e 94 98 02 	call	0x530	; 0x530 <send_data>
 //  dont_leave_arena();       // Prevent bot to go outside the plot 
 }
    1b1a:	08 95       	ret

00001b1c <update_orientation>:

void update_orientation (void)
	{
		direction = right_turns-left_turns;
    1b1c:	80 91 28 03 	lds	r24, 0x0328
    1b20:	90 91 29 03 	lds	r25, 0x0329
    1b24:	20 91 26 03 	lds	r18, 0x0326
    1b28:	30 91 27 03 	lds	r19, 0x0327
    1b2c:	82 1b       	sub	r24, r18
    1b2e:	93 0b       	sbc	r25, r19
    1b30:	90 93 25 03 	sts	0x0325, r25
    1b34:	80 93 24 03 	sts	0x0324, r24
		if ( (direction==0 ) || (direction==4) || (direction == -4))
    1b38:	00 97       	sbiw	r24, 0x00	; 0
    1b3a:	39 f0       	breq	.+14     	; 0x1b4a <update_orientation+0x2e>
    1b3c:	84 30       	cpi	r24, 0x04	; 4
    1b3e:	91 05       	cpc	r25, r1
    1b40:	21 f0       	breq	.+8      	; 0x1b4a <update_orientation+0x2e>
    1b42:	2f ef       	ldi	r18, 0xFF	; 255
    1b44:	8c 3f       	cpi	r24, 0xFC	; 252
    1b46:	92 07       	cpc	r25, r18
    1b48:	61 f4       	brne	.+24     	; 0x1b62 <update_orientation+0x46>
		{
			right_turns=0;
    1b4a:	10 92 29 03 	sts	0x0329, r1
    1b4e:	10 92 28 03 	sts	0x0328, r1
			left_turns=0;
    1b52:	10 92 27 03 	sts	0x0327, r1
    1b56:	10 92 26 03 	sts	0x0326, r1
			orientation=0;  // +y axis
    1b5a:	10 92 35 03 	sts	0x0335, r1
    1b5e:	10 92 34 03 	sts	0x0334, r1
		}
		
		if ( (direction==1) || (direction== -3) )
    1b62:	81 30       	cpi	r24, 0x01	; 1
    1b64:	91 05       	cpc	r25, r1
    1b66:	21 f0       	breq	.+8      	; 0x1b70 <update_orientation+0x54>
    1b68:	2f ef       	ldi	r18, 0xFF	; 255
    1b6a:	8d 3f       	cpi	r24, 0xFD	; 253
    1b6c:	92 07       	cpc	r25, r18
    1b6e:	31 f4       	brne	.+12     	; 0x1b7c <update_orientation+0x60>
		{
			orientation=1;  // +x axis
    1b70:	21 e0       	ldi	r18, 0x01	; 1
    1b72:	30 e0       	ldi	r19, 0x00	; 0
    1b74:	30 93 35 03 	sts	0x0335, r19
    1b78:	20 93 34 03 	sts	0x0334, r18
		}
		
		if (direction== -1 || direction == 3)
    1b7c:	2f ef       	ldi	r18, 0xFF	; 255
    1b7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b80:	92 07       	cpc	r25, r18
    1b82:	19 f0       	breq	.+6      	; 0x1b8a <update_orientation+0x6e>
    1b84:	83 30       	cpi	r24, 0x03	; 3
    1b86:	91 05       	cpc	r25, r1
    1b88:	31 f4       	brne	.+12     	; 0x1b96 <update_orientation+0x7a>
		{
			orientation=3; // -x axis
    1b8a:	23 e0       	ldi	r18, 0x03	; 3
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	30 93 35 03 	sts	0x0335, r19
    1b92:	20 93 34 03 	sts	0x0334, r18
		}
		
		if ( (direction==-2) || (direction ==2) )
    1b96:	2f ef       	ldi	r18, 0xFF	; 255
    1b98:	8e 3f       	cpi	r24, 0xFE	; 254
    1b9a:	92 07       	cpc	r25, r18
    1b9c:	19 f0       	breq	.+6      	; 0x1ba4 <update_orientation+0x88>
    1b9e:	82 30       	cpi	r24, 0x02	; 2
    1ba0:	91 05       	cpc	r25, r1
    1ba2:	31 f4       	brne	.+12     	; 0x1bb0 <update_orientation+0x94>
		{
			orientation=2;   //-y axis
    1ba4:	82 e0       	ldi	r24, 0x02	; 2
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	90 93 35 03 	sts	0x0335, r25
    1bac:	80 93 34 03 	sts	0x0334, r24
    1bb0:	08 95       	ret

00001bb2 <follow_line>:
		}
	
	}
// Line following till node/Midpoint detected
void follow_line(void)   
	{       
    1bb2:	cf 93       	push	r28
    1bb4:	df 93       	push	r29
    1bb6:	c0 e0       	ldi	r28, 0x00	; 0
    1bb8:	d0 e0       	ldi	r29, 0x00	; 0
	
	    while(stayOnLine==1)
	
		{

			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    1bba:	83 e0       	ldi	r24, 0x03	; 3
    1bbc:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
    1bc0:	80 93 31 03 	sts	0x0331, r24
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    1bc4:	82 e0       	ldi	r24, 0x02	; 2
    1bc6:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
    1bca:	80 93 30 03 	sts	0x0330, r24
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	0e 94 cc 04 	call	0x998	; 0x998 <ADC_Conversion>
    1bd4:	80 93 2f 03 	sts	0x032F, r24

			flag=0;
    1bd8:	10 92 2e 03 	sts	0x032E, r1
		//	print_sensor(1,1,3);	//Prints value of White Line Sensor1
		//	print_sensor(1,5,2);	//Prints Value of White Line Sensor2
      	//	print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		
			if(Center_white_line>0x14)
    1bdc:	80 91 30 03 	lds	r24, 0x0330
    1be0:	85 31       	cpi	r24, 0x15	; 21
    1be2:	48 f0       	brcs	.+18     	; 0x1bf6 <follow_line+0x44>
			{
				flag=1;
    1be4:	81 e0       	ldi	r24, 0x01	; 1
    1be6:	80 93 2e 03 	sts	0x032E, r24
				forward();
    1bea:	0e 94 39 03 	call	0x672	; 0x672 <forward>
				velocity(250,250);
    1bee:	8a ef       	ldi	r24, 0xFA	; 250
    1bf0:	6a ef       	ldi	r22, 0xFA	; 250
    1bf2:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
			}

			if((Left_white_line<0x14) && (flag==0))
    1bf6:	80 91 31 03 	lds	r24, 0x0331
    1bfa:	84 31       	cpi	r24, 0x14	; 20
    1bfc:	68 f4       	brcc	.+26     	; 0x1c18 <follow_line+0x66>
    1bfe:	80 91 2e 03 	lds	r24, 0x032E
    1c02:	88 23       	and	r24, r24
    1c04:	49 f4       	brne	.+18     	; 0x1c18 <follow_line+0x66>
			{
				flag=1;
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	80 93 2e 03 	sts	0x032E, r24
				forward();                            // value<0x14 means sensor on white
    1c0c:	0e 94 39 03 	call	0x672	; 0x672 <forward>
				velocity(255,195);
    1c10:	8f ef       	ldi	r24, 0xFF	; 255
    1c12:	63 ec       	ldi	r22, 0xC3	; 195
    1c14:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
			}

			if((Right_white_line<0x14) && (flag==0))  
    1c18:	80 91 2f 03 	lds	r24, 0x032F
    1c1c:	84 31       	cpi	r24, 0x14	; 20
    1c1e:	68 f4       	brcc	.+26     	; 0x1c3a <follow_line+0x88>
    1c20:	80 91 2e 03 	lds	r24, 0x032E
    1c24:	88 23       	and	r24, r24
    1c26:	49 f4       	brne	.+18     	; 0x1c3a <follow_line+0x88>
			{
				flag=1;
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	80 93 2e 03 	sts	0x032E, r24
				forward();
    1c2e:	0e 94 39 03 	call	0x672	; 0x672 <forward>
				velocity(195,255);
    1c32:	83 ec       	ldi	r24, 0xC3	; 195
    1c34:	6f ef       	ldi	r22, 0xFF	; 255
    1c36:	0e 94 34 03 	call	0x668	; 0x668 <velocity>
			}

			if((Center_white_line>0x14 && Left_white_line>0x14 )||(Center_white_line>0x14 && Right_white_line>0x14))
    1c3a:	80 91 30 03 	lds	r24, 0x0330
    1c3e:	85 31       	cpi	r24, 0x15	; 21
    1c40:	48 f0       	brcs	.+18     	; 0x1c54 <follow_line+0xa2>
    1c42:	80 91 31 03 	lds	r24, 0x0331
    1c46:	85 31       	cpi	r24, 0x15	; 21
    1c48:	20 f4       	brcc	.+8      	; 0x1c52 <follow_line+0xa0>
    1c4a:	80 91 2f 03 	lds	r24, 0x032F
    1c4e:	85 31       	cpi	r24, 0x15	; 21
    1c50:	08 f0       	brcs	.+2      	; 0x1c54 <follow_line+0xa2>
			 { // _delay_ms(100);
				 flag1++;
    1c52:	21 96       	adiw	r28, 0x01	; 1
				// lcd_print(1,13,flag1,2);
				
			 }
	
	
			if (flag1==1)
    1c54:	c1 30       	cpi	r28, 0x01	; 1
    1c56:	d1 05       	cpc	r29, r1
    1c58:	09 f0       	breq	.+2      	; 0x1c5c <follow_line+0xaa>
    1c5a:	af cf       	rjmp	.-162    	; 0x1bba <follow_line+0x8>
						{
							stayOnLine=0;
							linear_distance_mm(95);
    1c5c:	8f e5       	ldi	r24, 0x5F	; 95
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	0e 94 22 04 	call	0x844	; 0x844 <linear_distance_mm>
							//stop();
							flag1=0;
						}
	
		}			
		increase_counter();
    1c64:	0e 94 de 0c 	call	0x19bc	; 0x19bc <increase_counter>
}
    1c68:	df 91       	pop	r29
    1c6a:	cf 91       	pop	r28
    1c6c:	08 95       	ret

00001c6e <clear_matrix>:

 void clear_matrix(void)   //for making all elements of matrix zero
  { int i,j;
 	for(i=0;i<=9;i++)
    1c6e:	20 e0       	ldi	r18, 0x00	; 0
    1c70:	30 e0       	ldi	r19, 0x00	; 0
	
		}			
		increase_counter();
}

 void clear_matrix(void)   //for making all elements of matrix zero
    1c72:	4a e0       	ldi	r20, 0x0A	; 10
    1c74:	50 e0       	ldi	r21, 0x00	; 0
    1c76:	09 c0       	rjmp	.+18     	; 0x1c8a <clear_matrix+0x1c>
  { int i,j;
 	for(i=0;i<=9;i++)
 	 {
 		 for (j=0;j<=9;j++)
 		 {
 			 plot[i][j]=0;
    1c78:	11 92       	st	Z+, r1
    1c7a:	11 92       	st	Z+, r1
    1c7c:	01 97       	sbiw	r24, 0x01	; 1

 void clear_matrix(void)   //for making all elements of matrix zero
  { int i,j;
 	for(i=0;i<=9;i++)
 	 {
 		 for (j=0;j<=9;j++)
    1c7e:	e1 f7       	brne	.-8      	; 0x1c78 <clear_matrix+0xa>
		increase_counter();
}

 void clear_matrix(void)   //for making all elements of matrix zero
  { int i,j;
 	for(i=0;i<=9;i++)
    1c80:	2f 5f       	subi	r18, 0xFF	; 255
    1c82:	3f 4f       	sbci	r19, 0xFF	; 255
    1c84:	2a 30       	cpi	r18, 0x0A	; 10
    1c86:	31 05       	cpc	r19, r1
    1c88:	81 f0       	breq	.+32     	; 0x1caa <clear_matrix+0x3c>
	
		}			
		increase_counter();
}

 void clear_matrix(void)   //for making all elements of matrix zero
    1c8a:	c9 01       	movw	r24, r18
    1c8c:	88 0f       	add	r24, r24
    1c8e:	99 1f       	adc	r25, r25
    1c90:	fc 01       	movw	r30, r24
    1c92:	ee 0f       	add	r30, r30
    1c94:	ff 1f       	adc	r31, r31
    1c96:	ee 0f       	add	r30, r30
    1c98:	ff 1f       	adc	r31, r31
    1c9a:	ee 0f       	add	r30, r30
    1c9c:	ff 1f       	adc	r31, r31
    1c9e:	e8 0f       	add	r30, r24
    1ca0:	f9 1f       	adc	r31, r25
    1ca2:	ea 5a       	subi	r30, 0xAA	; 170
    1ca4:	fc 4f       	sbci	r31, 0xFC	; 252
    1ca6:	ca 01       	movw	r24, r20
    1ca8:	e7 cf       	rjmp	.-50     	; 0x1c78 <clear_matrix+0xa>
    1caa:	08 95       	ret

00001cac <next_cordinate>:
 

 void next_cordinate (int my_orientation)
{  
	
	if(my_orientation==0)
    1cac:	00 97       	sbiw	r24, 0x00	; 0
    1cae:	99 f4       	brne	.+38     	; 0x1cd6 <next_cordinate+0x2a>
	{
		next_x=x_counter;
    1cb0:	20 91 fa 02 	lds	r18, 0x02FA
    1cb4:	30 91 fb 02 	lds	r19, 0x02FB
    1cb8:	30 93 21 03 	sts	0x0321, r19
    1cbc:	20 93 20 03 	sts	0x0320, r18
		next_y=y_counter+1;
    1cc0:	20 91 2c 03 	lds	r18, 0x032C
    1cc4:	30 91 2d 03 	lds	r19, 0x032D
    1cc8:	2f 5f       	subi	r18, 0xFF	; 255
    1cca:	3f 4f       	sbci	r19, 0xFF	; 255
    1ccc:	30 93 23 03 	sts	0x0323, r19
    1cd0:	20 93 22 03 	sts	0x0322, r18
    1cd4:	2a c0       	rjmp	.+84     	; 0x1d2a <next_cordinate+0x7e>
	}
	
	if(my_orientation==1)
    1cd6:	81 30       	cpi	r24, 0x01	; 1
    1cd8:	91 05       	cpc	r25, r1
    1cda:	91 f4       	brne	.+36     	; 0x1d00 <next_cordinate+0x54>
	{
	    next_x=x_counter+1;
    1cdc:	80 91 fa 02 	lds	r24, 0x02FA
    1ce0:	90 91 fb 02 	lds	r25, 0x02FB
    1ce4:	01 96       	adiw	r24, 0x01	; 1
    1ce6:	90 93 21 03 	sts	0x0321, r25
    1cea:	80 93 20 03 	sts	0x0320, r24
		next_y=y_counter;		
    1cee:	80 91 2c 03 	lds	r24, 0x032C
    1cf2:	90 91 2d 03 	lds	r25, 0x032D
    1cf6:	90 93 23 03 	sts	0x0323, r25
    1cfa:	80 93 22 03 	sts	0x0322, r24
    1cfe:	08 95       	ret
	}
	
	if(my_orientation==2)
    1d00:	82 30       	cpi	r24, 0x02	; 2
    1d02:	91 05       	cpc	r25, r1
    1d04:	91 f4       	brne	.+36     	; 0x1d2a <next_cordinate+0x7e>
	{
		next_x=x_counter;
    1d06:	80 91 fa 02 	lds	r24, 0x02FA
    1d0a:	90 91 fb 02 	lds	r25, 0x02FB
    1d0e:	90 93 21 03 	sts	0x0321, r25
    1d12:	80 93 20 03 	sts	0x0320, r24
		next_y=y_counter-1;
    1d16:	80 91 2c 03 	lds	r24, 0x032C
    1d1a:	90 91 2d 03 	lds	r25, 0x032D
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	90 93 23 03 	sts	0x0323, r25
    1d24:	80 93 22 03 	sts	0x0322, r24
    1d28:	08 95       	ret
	}
	
	if(my_orientation==3)
    1d2a:	83 30       	cpi	r24, 0x03	; 3
    1d2c:	91 05       	cpc	r25, r1
    1d2e:	89 f4       	brne	.+34     	; 0x1d52 <next_cordinate+0xa6>
	{
		next_x=x_counter-1;
    1d30:	80 91 fa 02 	lds	r24, 0x02FA
    1d34:	90 91 fb 02 	lds	r25, 0x02FB
    1d38:	01 97       	sbiw	r24, 0x01	; 1
    1d3a:	90 93 21 03 	sts	0x0321, r25
    1d3e:	80 93 20 03 	sts	0x0320, r24
		next_y=y_counter;
    1d42:	80 91 2c 03 	lds	r24, 0x032C
    1d46:	90 91 2d 03 	lds	r25, 0x032D
    1d4a:	90 93 23 03 	sts	0x0323, r25
    1d4e:	80 93 22 03 	sts	0x0322, r24
    1d52:	08 95       	ret

00001d54 <find_plot_pos>:


void find_plot_pos (void)
{
  int plot_orientation;
  if (r==1)
    1d54:	20 91 36 03 	lds	r18, 0x0336
    1d58:	30 91 37 03 	lds	r19, 0x0337
    1d5c:	21 30       	cpi	r18, 0x01	; 1
    1d5e:	31 05       	cpc	r19, r1
    1d60:	29 f4       	brne	.+10     	; 0x1d6c <find_plot_pos+0x18>
  {
  	plot_orientation=orientation+1;
    1d62:	80 91 34 03 	lds	r24, 0x0334
    1d66:	90 91 35 03 	lds	r25, 0x0335
    1d6a:	01 96       	adiw	r24, 0x01	; 1
  }  
   if (l==1)
    1d6c:	20 91 38 03 	lds	r18, 0x0338
    1d70:	30 91 39 03 	lds	r19, 0x0339
    1d74:	21 30       	cpi	r18, 0x01	; 1
    1d76:	31 05       	cpc	r19, r1
    1d78:	29 f4       	brne	.+10     	; 0x1d84 <find_plot_pos+0x30>
  {
	  plot_orientation=orientation-1;
    1d7a:	80 91 34 03 	lds	r24, 0x0334
    1d7e:	90 91 35 03 	lds	r25, 0x0335
    1d82:	01 97       	sbiw	r24, 0x01	; 1
  }
  
	if (plot_orientation==4)
    1d84:	84 30       	cpi	r24, 0x04	; 4
    1d86:	91 05       	cpc	r25, r1
    1d88:	29 f0       	breq	.+10     	; 0x1d94 <find_plot_pos+0x40>
	{
	   plot_orientation=0;
	}
	
	if (plot_orientation==-1)
    1d8a:	2f ef       	ldi	r18, 0xFF	; 255
    1d8c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d8e:	92 07       	cpc	r25, r18
    1d90:	21 f0       	breq	.+8      	; 0x1d9a <find_plot_pos+0x46>
    1d92:	05 c0       	rjmp	.+10     	; 0x1d9e <find_plot_pos+0x4a>
	  plot_orientation=orientation-1;
  }
  
	if (plot_orientation==4)
	{
	   plot_orientation=0;
    1d94:	80 e0       	ldi	r24, 0x00	; 0
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	02 c0       	rjmp	.+4      	; 0x1d9e <find_plot_pos+0x4a>
	}
	
	if (plot_orientation==-1)
	{
		plot_orientation=3;
    1d9a:	83 e0       	ldi	r24, 0x03	; 3
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
	}

  //plot_orientation=correct_orientation_overflow(plot_orientation);

  next_cordinate(plot_orientation);
    1d9e:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
  dest_x=next_x;
    1da2:	80 91 20 03 	lds	r24, 0x0320
    1da6:	90 91 21 03 	lds	r25, 0x0321
    1daa:	90 93 43 03 	sts	0x0343, r25
    1dae:	80 93 42 03 	sts	0x0342, r24
  dest_y=next_y;
    1db2:	80 91 22 03 	lds	r24, 0x0322
    1db6:	90 91 23 03 	lds	r25, 0x0323
    1dba:	90 93 c1 04 	sts	0x04C1, r25
    1dbe:	80 93 c0 04 	sts	0x04C0, r24
}
    1dc2:	08 95       	ret

00001dc4 <clear_path>:
void clear_path(void)   //for making all elements of matrix zero
{ int i,j;
	for(i=1;i<=9;i++)
    1dc4:	21 e0       	ldi	r18, 0x01	; 1
    1dc6:	30 e0       	ldi	r19, 0x00	; 0

  next_cordinate(plot_orientation);
  dest_x=next_x;
  dest_y=next_y;
}
void clear_path(void)   //for making all elements of matrix zero
    1dc8:	49 e0       	ldi	r20, 0x09	; 9
    1dca:	50 e0       	ldi	r21, 0x00	; 0
    1dcc:	09 c0       	rjmp	.+18     	; 0x1de0 <clear_path+0x1c>
{ int i,j;
	for(i=1;i<=9;i++)
	{
		for (j=1;j<=9;j++)
		{
			path_log[i][j]=0;
    1dce:	11 92       	st	Z+, r1
    1dd0:	11 92       	st	Z+, r1
    1dd2:	01 97       	sbiw	r24, 0x01	; 1
}
void clear_path(void)   //for making all elements of matrix zero
{ int i,j;
	for(i=1;i<=9;i++)
	{
		for (j=1;j<=9;j++)
    1dd4:	e1 f7       	brne	.-8      	; 0x1dce <clear_path+0xa>
  dest_x=next_x;
  dest_y=next_y;
}
void clear_path(void)   //for making all elements of matrix zero
{ int i,j;
	for(i=1;i<=9;i++)
    1dd6:	2f 5f       	subi	r18, 0xFF	; 255
    1dd8:	3f 4f       	sbci	r19, 0xFF	; 255
    1dda:	2a 30       	cpi	r18, 0x0A	; 10
    1ddc:	31 05       	cpc	r19, r1
    1dde:	a1 f0       	breq	.+40     	; 0x1e08 <clear_path+0x44>

  next_cordinate(plot_orientation);
  dest_x=next_x;
  dest_y=next_y;
}
void clear_path(void)   //for making all elements of matrix zero
    1de0:	c9 01       	movw	r24, r18
    1de2:	88 0f       	add	r24, r24
    1de4:	99 1f       	adc	r25, r25
    1de6:	82 0f       	add	r24, r18
    1de8:	93 1f       	adc	r25, r19
    1dea:	fc 01       	movw	r30, r24
    1dec:	ee 0f       	add	r30, r30
    1dee:	ff 1f       	adc	r31, r31
    1df0:	ee 0f       	add	r30, r30
    1df2:	ff 1f       	adc	r31, r31
    1df4:	ee 0f       	add	r30, r30
    1df6:	ff 1f       	adc	r31, r31
    1df8:	e8 1b       	sub	r30, r24
    1dfa:	f9 0b       	sbc	r31, r25
    1dfc:	e2 0f       	add	r30, r18
    1dfe:	f3 1f       	adc	r31, r19
    1e00:	e6 5f       	subi	r30, 0xF6	; 246
    1e02:	fd 4f       	sbci	r31, 0xFD	; 253
    1e04:	ca 01       	movw	r24, r20
    1e06:	e3 cf       	rjmp	.-58     	; 0x1dce <clear_path+0xa>
    1e08:	08 95       	ret

00001e0a <find_a_way>:
		}
	}
}

void find_a_way(void)
{ int i =0,p[4],prev=4,way, turns=0, o1, o2;
    1e0a:	8f 92       	push	r8
    1e0c:	9f 92       	push	r9
    1e0e:	af 92       	push	r10
    1e10:	bf 92       	push	r11
    1e12:	cf 92       	push	r12
    1e14:	df 92       	push	r13
    1e16:	ef 92       	push	r14
    1e18:	ff 92       	push	r15
    1e1a:	0f 93       	push	r16
    1e1c:	1f 93       	push	r17
    1e1e:	cf 93       	push	r28
    1e20:	df 93       	push	r29
    1e22:	cd b7       	in	r28, 0x3d	; 61
    1e24:	de b7       	in	r29, 0x3e	; 62
    1e26:	28 97       	sbiw	r28, 0x08	; 8
    1e28:	0f b6       	in	r0, 0x3f	; 63
    1e2a:	f8 94       	cli
    1e2c:	de bf       	out	0x3e, r29	; 62
    1e2e:	0f be       	out	0x3f, r0	; 63
    1e30:	cd bf       	out	0x3d, r28	; 61
			o1=0; 
		}
		
		if ( o2==-1)
		{
			o2=3;
    1e32:	6e 01       	movw	r12, r28
    1e34:	08 94       	sec
    1e36:	c1 1c       	adc	r12, r1
    1e38:	d1 1c       	adc	r13, r1
		}
	}
}

void find_a_way(void)
{ int i =0,p[4],prev=4,way, turns=0, o1, o2;
    1e3a:	76 01       	movw	r14, r12
  
	for (i=0;i<=3;i++)
    1e3c:	00 e0       	ldi	r16, 0x00	; 0
    1e3e:	10 e0       	ldi	r17, 0x00	; 0
	{
		next_cordinate(i);
		p[i]=path_log[next_x][next_y];
    1e40:	0f 2e       	mov	r0, r31
    1e42:	f8 e0       	ldi	r31, 0x08	; 8
    1e44:	af 2e       	mov	r10, r31
    1e46:	f2 e0       	ldi	r31, 0x02	; 2
    1e48:	bf 2e       	mov	r11, r31
    1e4a:	f0 2d       	mov	r31, r0
void find_a_way(void)
{ int i =0,p[4],prev=4,way, turns=0, o1, o2;
  
	for (i=0;i<=3;i++)
	{
		next_cordinate(i);
    1e4c:	c8 01       	movw	r24, r16
    1e4e:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
		p[i]=path_log[next_x][next_y];
    1e52:	40 91 20 03 	lds	r20, 0x0320
    1e56:	50 91 21 03 	lds	r21, 0x0321
    1e5a:	ca 01       	movw	r24, r20
    1e5c:	88 0f       	add	r24, r24
    1e5e:	99 1f       	adc	r25, r25
    1e60:	9a 01       	movw	r18, r20
    1e62:	22 0f       	add	r18, r18
    1e64:	33 1f       	adc	r19, r19
    1e66:	22 0f       	add	r18, r18
    1e68:	33 1f       	adc	r19, r19
    1e6a:	22 0f       	add	r18, r18
    1e6c:	33 1f       	adc	r19, r19
    1e6e:	82 0f       	add	r24, r18
    1e70:	93 1f       	adc	r25, r19
    1e72:	84 0f       	add	r24, r20
    1e74:	95 1f       	adc	r25, r21
    1e76:	20 91 22 03 	lds	r18, 0x0322
    1e7a:	30 91 23 03 	lds	r19, 0x0323
    1e7e:	82 0f       	add	r24, r18
    1e80:	93 1f       	adc	r25, r19
    1e82:	88 0f       	add	r24, r24
    1e84:	99 1f       	adc	r25, r25
    1e86:	8a 0d       	add	r24, r10
    1e88:	9b 1d       	adc	r25, r11
    1e8a:	fc 01       	movw	r30, r24
    1e8c:	40 81       	ld	r20, Z
    1e8e:	51 81       	ldd	r21, Z+1	; 0x01
    1e90:	f7 01       	movw	r30, r14
    1e92:	41 93       	st	Z+, r20
    1e94:	51 93       	st	Z+, r21
    1e96:	7f 01       	movw	r14, r30
			path_log[i][j]=0;
		}
	}
}

void find_a_way(void)
    1e98:	60 2f       	mov	r22, r16
    1e9a:	6b 5f       	subi	r22, 0xFB	; 251
  
	for (i=0;i<=3;i++)
	{
		next_cordinate(i);
		p[i]=path_log[next_x][next_y];
		lcd_print(2,5+i,p[i],1);
    1e9c:	82 e0       	ldi	r24, 0x02	; 2
    1e9e:	21 e0       	ldi	r18, 0x01	; 1
    1ea0:	30 e0       	ldi	r19, 0x00	; 0
    1ea2:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
}

void find_a_way(void)
{ int i =0,p[4],prev=4,way, turns=0, o1, o2;
  
	for (i=0;i<=3;i++)
    1ea6:	0f 5f       	subi	r16, 0xFF	; 255
    1ea8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eaa:	04 30       	cpi	r16, 0x04	; 4
    1eac:	11 05       	cpc	r17, r1
    1eae:	71 f6       	brne	.-100    	; 0x1e4c <find_a_way+0x42>
    1eb0:	44 e0       	ldi	r20, 0x04	; 4
    1eb2:	50 e0       	ldi	r21, 0x00	; 0
    1eb4:	80 e0       	ldi	r24, 0x00	; 0
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	
	for (i=0;i<=3;i++)
	{
		if (p[i]<prev)
    1eb8:	f6 01       	movw	r30, r12
    1eba:	21 91       	ld	r18, Z+
    1ebc:	31 91       	ld	r19, Z+
    1ebe:	6f 01       	movw	r12, r30
    1ec0:	24 17       	cp	r18, r20
    1ec2:	35 07       	cpc	r19, r21
    1ec4:	14 f4       	brge	.+4      	; 0x1eca <find_a_way+0xc0>
    1ec6:	4c 01       	movw	r8, r24
		{
			prev=p[i];
    1ec8:	a9 01       	movw	r20, r18
		p[i]=path_log[next_x][next_y];
		lcd_print(2,5+i,p[i],1);
	}
	
	
	for (i=0;i<=3;i++)
    1eca:	01 96       	adiw	r24, 0x01	; 1
    1ecc:	84 30       	cpi	r24, 0x04	; 4
    1ece:	91 05       	cpc	r25, r1
    1ed0:	99 f7       	brne	.-26     	; 0x1eb8 <find_a_way+0xae>
			prev=p[i];
			way=i;
		}
	}
	
	if (p[way]==p[orientation])
    1ed2:	80 91 34 03 	lds	r24, 0x0334
    1ed6:	90 91 35 03 	lds	r25, 0x0335
    1eda:	f4 01       	movw	r30, r8
    1edc:	ee 0f       	add	r30, r30
    1ede:	ff 1f       	adc	r31, r31
    1ee0:	21 e0       	ldi	r18, 0x01	; 1
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	2c 0f       	add	r18, r28
    1ee6:	3d 1f       	adc	r19, r29
    1ee8:	e2 0f       	add	r30, r18
    1eea:	f3 1f       	adc	r31, r19
    1eec:	dc 01       	movw	r26, r24
    1eee:	aa 0f       	add	r26, r26
    1ef0:	bb 1f       	adc	r27, r27
    1ef2:	a2 0f       	add	r26, r18
    1ef4:	b3 1f       	adc	r27, r19
    1ef6:	20 81       	ld	r18, Z
    1ef8:	31 81       	ldd	r19, Z+1	; 0x01
    1efa:	4d 91       	ld	r20, X+
    1efc:	5c 91       	ld	r21, X
    1efe:	11 97       	sbiw	r26, 0x01	; 1
    1f00:	24 17       	cp	r18, r20
    1f02:	35 07       	cpc	r19, r21
    1f04:	81 f1       	breq	.+96     	; 0x1f66 <find_a_way+0x15c>
		
	}
	
	else
	{
		o1=orientation+1;
    1f06:	9c 01       	movw	r18, r24
    1f08:	2f 5f       	subi	r18, 0xFF	; 255
    1f0a:	3f 4f       	sbci	r19, 0xFF	; 255
		o2=orientation-1;
    1f0c:	01 97       	sbiw	r24, 0x01	; 1
		if (o1==4)
    1f0e:	24 30       	cpi	r18, 0x04	; 4
    1f10:	31 05       	cpc	r19, r1
    1f12:	11 f4       	brne	.+4      	; 0x1f18 <find_a_way+0x10e>
		{
			o1=0; 
    1f14:	20 e0       	ldi	r18, 0x00	; 0
    1f16:	30 e0       	ldi	r19, 0x00	; 0
		}
		
		if ( o2==-1)
    1f18:	4f ef       	ldi	r20, 0xFF	; 255
    1f1a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f1c:	94 07       	cpc	r25, r20
    1f1e:	11 f4       	brne	.+4      	; 0x1f24 <find_a_way+0x11a>
		{
			o2=3;
    1f20:	83 e0       	ldi	r24, 0x03	; 3
    1f22:	90 e0       	ldi	r25, 0x00	; 0
		}
		
		if (p[o1]>p[o2])
    1f24:	f9 01       	movw	r30, r18
    1f26:	ee 0f       	add	r30, r30
    1f28:	ff 1f       	adc	r31, r31
    1f2a:	21 e0       	ldi	r18, 0x01	; 1
    1f2c:	30 e0       	ldi	r19, 0x00	; 0
    1f2e:	2c 0f       	add	r18, r28
    1f30:	3d 1f       	adc	r19, r29
    1f32:	e2 0f       	add	r30, r18
    1f34:	f3 1f       	adc	r31, r19
    1f36:	e0 80       	ld	r14, Z
    1f38:	f1 80       	ldd	r15, Z+1	; 0x01
    1f3a:	fc 01       	movw	r30, r24
    1f3c:	ee 0f       	add	r30, r30
    1f3e:	ff 1f       	adc	r31, r31
    1f40:	e2 0f       	add	r30, r18
    1f42:	f3 1f       	adc	r31, r19
    1f44:	00 81       	ld	r16, Z
    1f46:	11 81       	ldd	r17, Z+1	; 0x01
    1f48:	0e 15       	cp	r16, r14
    1f4a:	1f 05       	cpc	r17, r15
    1f4c:	14 f4       	brge	.+4      	; 0x1f52 <find_a_way+0x148>
		{
			left_90();
    1f4e:	0e 94 ce 0c 	call	0x199c	; 0x199c <left_90>
		}
		
		 if (p[o1]<p[o2])
    1f52:	e0 16       	cp	r14, r16
    1f54:	f1 06       	cpc	r15, r17
    1f56:	14 f4       	brge	.+4      	; 0x1f5c <find_a_way+0x152>
		{
			right_90();
    1f58:	0e 94 be 0c 	call	0x197c	; 0x197c <right_90>
		}
		
	     if (p[o1]==p[o2])
    1f5c:	e0 16       	cp	r14, r16
    1f5e:	f1 06       	cpc	r15, r17
    1f60:	11 f4       	brne	.+4      	; 0x1f66 <find_a_way+0x15c>
		{
			right_90();
    1f62:	0e 94 be 0c 	call	0x197c	; 0x197c <right_90>
			
		}
	}	
}
    1f66:	28 96       	adiw	r28, 0x08	; 8
    1f68:	0f b6       	in	r0, 0x3f	; 63
    1f6a:	f8 94       	cli
    1f6c:	de bf       	out	0x3e, r29	; 62
    1f6e:	0f be       	out	0x3f, r0	; 63
    1f70:	cd bf       	out	0x3d, r28	; 61
    1f72:	df 91       	pop	r29
    1f74:	cf 91       	pop	r28
    1f76:	1f 91       	pop	r17
    1f78:	0f 91       	pop	r16
    1f7a:	ff 90       	pop	r15
    1f7c:	ef 90       	pop	r14
    1f7e:	df 90       	pop	r13
    1f80:	cf 90       	pop	r12
    1f82:	bf 90       	pop	r11
    1f84:	af 90       	pop	r10
    1f86:	9f 90       	pop	r9
    1f88:	8f 90       	pop	r8
    1f8a:	08 95       	ret

00001f8c <path_log_entry>:

void path_log_entry (void)
{
	path_log[x_counter][y_counter]++;
    1f8c:	40 91 fa 02 	lds	r20, 0x02FA
    1f90:	50 91 fb 02 	lds	r21, 0x02FB
    1f94:	60 91 2c 03 	lds	r22, 0x032C
    1f98:	70 91 2d 03 	lds	r23, 0x032D
    1f9c:	9a 01       	movw	r18, r20
    1f9e:	22 0f       	add	r18, r18
    1fa0:	33 1f       	adc	r19, r19
    1fa2:	ca 01       	movw	r24, r20
    1fa4:	88 0f       	add	r24, r24
    1fa6:	99 1f       	adc	r25, r25
    1fa8:	88 0f       	add	r24, r24
    1faa:	99 1f       	adc	r25, r25
    1fac:	88 0f       	add	r24, r24
    1fae:	99 1f       	adc	r25, r25
    1fb0:	82 0f       	add	r24, r18
    1fb2:	93 1f       	adc	r25, r19
    1fb4:	48 0f       	add	r20, r24
    1fb6:	59 1f       	adc	r21, r25
    1fb8:	64 0f       	add	r22, r20
    1fba:	75 1f       	adc	r23, r21
    1fbc:	fb 01       	movw	r30, r22
    1fbe:	ee 0f       	add	r30, r30
    1fc0:	ff 1f       	adc	r31, r31
    1fc2:	e8 5f       	subi	r30, 0xF8	; 248
    1fc4:	fd 4f       	sbci	r31, 0xFD	; 253
    1fc6:	80 81       	ld	r24, Z
    1fc8:	91 81       	ldd	r25, Z+1	; 0x01
    1fca:	01 96       	adiw	r24, 0x01	; 1
    1fcc:	91 83       	std	Z+1, r25	; 0x01
    1fce:	80 83       	st	Z, r24
}	
    1fd0:	08 95       	ret

00001fd2 <nodeORmid>:

unsigned Iam_at=0 ;        //  0 start , 1 node , 2 mid_1

void nodeORmid (void)
{
	if( !(x_counter%2) && (y_counter%2) )
    1fd2:	80 91 fa 02 	lds	r24, 0x02FA
    1fd6:	80 fd       	sbrc	r24, 0
    1fd8:	0a c0       	rjmp	.+20     	; 0x1fee <nodeORmid+0x1c>
    1fda:	80 91 2c 03 	lds	r24, 0x032C
    1fde:	80 ff       	sbrs	r24, 0
    1fe0:	06 c0       	rjmp	.+12     	; 0x1fee <nodeORmid+0x1c>
      {
		  Iam_at= 2;      // midpoint and orientation x axis
    1fe2:	82 e0       	ldi	r24, 0x02	; 2
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	90 93 13 03 	sts	0x0313, r25
    1fea:	80 93 12 03 	sts	0x0312, r24
	  }
     if ((x_counter%2) && !(y_counter%2))
    1fee:	80 91 fa 02 	lds	r24, 0x02FA
    1ff2:	80 ff       	sbrs	r24, 0
    1ff4:	18 c0       	rjmp	.+48     	; 0x2026 <nodeORmid+0x54>
    1ff6:	80 91 2c 03 	lds	r24, 0x032C
    1ffa:	80 fd       	sbrc	r24, 0
    1ffc:	0a c0       	rjmp	.+20     	; 0x2012 <nodeORmid+0x40>
     {
		 Iam_at= 2;        // midpoint and orientation y axis
    1ffe:	82 e0       	ldi	r24, 0x02	; 2
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	90 93 13 03 	sts	0x0313, r25
    2006:	80 93 12 03 	sts	0x0312, r24
	 }
	 if ((x_counter%2) && (y_counter%2))
    200a:	80 91 fa 02 	lds	r24, 0x02FA
    200e:	80 ff       	sbrs	r24, 0
    2010:	0a c0       	rjmp	.+20     	; 0x2026 <nodeORmid+0x54>
    2012:	80 91 2c 03 	lds	r24, 0x032C
    2016:	80 ff       	sbrs	r24, 0
    2018:	06 c0       	rjmp	.+12     	; 0x2026 <nodeORmid+0x54>
	 {
		 Iam_at= 1;        // at node
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	90 93 13 03 	sts	0x0313, r25
    2022:	80 93 12 03 	sts	0x0312, r24
    2026:	08 95       	ret

00002028 <node_action>:
	 }	    
	 
}

void node_action (void)
{ int clear=1;
    2028:	0f 93       	push	r16
    202a:	1f 93       	push	r17
    202c:	cf 93       	push	r28
    202e:	df 93       	push	r29
	   black=scan_block();
	   if(black==1)
		   {
			   black=0;
			   next_cordinate(orientation);
			   path_log[next_x][next_y]=9;
    2030:	c8 e0       	ldi	r28, 0x08	; 8
    2032:	d2 e0       	ldi	r29, 0x02	; 2
    2034:	09 e0       	ldi	r16, 0x09	; 9
    2036:	10 e0       	ldi	r17, 0x00	; 0

void node_action (void)
{ int clear=1;
  while(clear)
    {
	   find_a_way();
    2038:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <find_a_way>
	   update_orientation();
    203c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <update_orientation>
	   black=scan_block();
    2040:	0e 94 08 08 	call	0x1010	; 0x1010 <scan_block>
    2044:	28 2f       	mov	r18, r24
    2046:	39 2f       	mov	r19, r25
    2048:	30 93 09 04 	sts	0x0409, r19
    204c:	20 93 08 04 	sts	0x0408, r18
	   if(black==1)
    2050:	21 30       	cpi	r18, 0x01	; 1
    2052:	31 05       	cpc	r19, r1
    2054:	51 f5       	brne	.+84     	; 0x20aa <node_action+0x82>
		   {
			   black=0;
    2056:	10 92 09 04 	sts	0x0409, r1
    205a:	10 92 08 04 	sts	0x0408, r1
			   next_cordinate(orientation);
    205e:	80 91 34 03 	lds	r24, 0x0334
    2062:	90 91 35 03 	lds	r25, 0x0335
    2066:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
			   path_log[next_x][next_y]=9;
    206a:	40 91 20 03 	lds	r20, 0x0320
    206e:	50 91 21 03 	lds	r21, 0x0321
    2072:	ca 01       	movw	r24, r20
    2074:	88 0f       	add	r24, r24
    2076:	99 1f       	adc	r25, r25
    2078:	9a 01       	movw	r18, r20
    207a:	22 0f       	add	r18, r18
    207c:	33 1f       	adc	r19, r19
    207e:	22 0f       	add	r18, r18
    2080:	33 1f       	adc	r19, r19
    2082:	22 0f       	add	r18, r18
    2084:	33 1f       	adc	r19, r19
    2086:	82 0f       	add	r24, r18
    2088:	93 1f       	adc	r25, r19
    208a:	48 0f       	add	r20, r24
    208c:	59 1f       	adc	r21, r25
    208e:	60 91 22 03 	lds	r22, 0x0322
    2092:	70 91 23 03 	lds	r23, 0x0323
    2096:	46 0f       	add	r20, r22
    2098:	57 1f       	adc	r21, r23
    209a:	fa 01       	movw	r30, r20
    209c:	ee 0f       	add	r30, r30
    209e:	ff 1f       	adc	r31, r31
    20a0:	ec 0f       	add	r30, r28
    20a2:	fd 1f       	adc	r31, r29
    20a4:	11 83       	std	Z+1, r17	; 0x01
    20a6:	00 83       	st	Z, r16
    20a8:	c7 cf       	rjmp	.-114    	; 0x2038 <node_action+0x10>
	   else
			{
			  clear=0;
			}
	}     
}
    20aa:	df 91       	pop	r29
    20ac:	cf 91       	pop	r28
    20ae:	1f 91       	pop	r17
    20b0:	0f 91       	pop	r16
    20b2:	08 95       	ret

000020b4 <__vector_25>:

// Zigbee connection starts here

unsigned int rescue_x,rescue_y,rescue_or;
SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{ 
    20b4:	1f 92       	push	r1
    20b6:	0f 92       	push	r0
    20b8:	0f b6       	in	r0, 0x3f	; 63
    20ba:	0f 92       	push	r0
    20bc:	0b b6       	in	r0, 0x3b	; 59
    20be:	0f 92       	push	r0
    20c0:	11 24       	eor	r1, r1
    20c2:	2f 93       	push	r18
    20c4:	3f 93       	push	r19
    20c6:	4f 93       	push	r20
    20c8:	5f 93       	push	r21
    20ca:	6f 93       	push	r22
    20cc:	7f 93       	push	r23
    20ce:	8f 93       	push	r24
    20d0:	9f 93       	push	r25
    20d2:	af 93       	push	r26
    20d4:	bf 93       	push	r27
    20d6:	ef 93       	push	r30
    20d8:	ff 93       	push	r31
	data=UDR0;
    20da:	20 91 c6 00 	lds	r18, 0x00C6
    20de:	20 93 bf 04 	sts	0x04BF, r18
	
	if (data/100==0)
    20e2:	24 36       	cpi	r18, 0x64	; 100
    20e4:	d8 f4       	brcc	.+54     	; 0x211c <__vector_25+0x68>
	{
		rescue_x=data%10;                   //y           // 0-dest_x-dest_y
    20e6:	82 2f       	mov	r24, r18
    20e8:	6a e0       	ldi	r22, 0x0A	; 10
    20ea:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <__udivmodqi4>
    20ee:	39 2f       	mov	r19, r25
    20f0:	90 93 b3 04 	sts	0x04B3, r25
    20f4:	10 92 b4 04 	sts	0x04B4, r1
		rescue_y=(data%100-data%10)/10;     //x
    20f8:	82 2f       	mov	r24, r18
    20fa:	64 e6       	ldi	r22, 0x64	; 100
    20fc:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <__udivmodqi4>
    2100:	89 2f       	mov	r24, r25
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	83 1b       	sub	r24, r19
    2106:	91 09       	sbc	r25, r1
    2108:	6a e0       	ldi	r22, 0x0A	; 10
    210a:	70 e0       	ldi	r23, 0x00	; 0
    210c:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <__divmodhi4>
    2110:	70 93 ba 04 	sts	0x04BA, r23
    2114:	60 93 b9 04 	sts	0x04B9, r22
		avoid_collision();
    2118:	0e 94 d6 00 	call	0x1ac	; 0x1ac <avoid_collision>
	}
	if (data/100==1)
    211c:	80 91 bf 04 	lds	r24, 0x04BF
    2120:	98 2f       	mov	r25, r24
    2122:	94 56       	subi	r25, 0x64	; 100
    2124:	94 36       	cpi	r25, 0x64	; 100
    2126:	38 f4       	brcc	.+14     	; 0x2136 <__vector_25+0x82>
	{
		rescue_or=data%10;
    2128:	6a e0       	ldi	r22, 0x0A	; 10
    212a:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <__udivmodqi4>
    212e:	90 93 b5 04 	sts	0x04B5, r25
    2132:	10 92 b6 04 	sts	0x04B6, r1
	}
	
		
}
    2136:	ff 91       	pop	r31
    2138:	ef 91       	pop	r30
    213a:	bf 91       	pop	r27
    213c:	af 91       	pop	r26
    213e:	9f 91       	pop	r25
    2140:	8f 91       	pop	r24
    2142:	7f 91       	pop	r23
    2144:	6f 91       	pop	r22
    2146:	5f 91       	pop	r21
    2148:	4f 91       	pop	r20
    214a:	3f 91       	pop	r19
    214c:	2f 91       	pop	r18
    214e:	0f 90       	pop	r0
    2150:	0b be       	out	0x3b, r0	; 59
    2152:	0f 90       	pop	r0
    2154:	0f be       	out	0x3f, r0	; 63
    2156:	0f 90       	pop	r0
    2158:	1f 90       	pop	r1
    215a:	18 95       	reti

0000215c <rescue_next_cordinate>:
int r_next_x,r_next_y,r_node_x,r_node_y;
unsigned int trigger=0,wait=0;
void rescue_next_cordinate (int x,int y,int my_orientation)
{
	
	if(my_orientation==0)
    215c:	41 15       	cp	r20, r1
    215e:	51 05       	cpc	r21, r1
    2160:	61 f4       	brne	.+24     	; 0x217a <rescue_next_cordinate+0x1e>
	{
		r_next_x=x;
    2162:	90 93 45 03 	sts	0x0345, r25
    2166:	80 93 44 03 	sts	0x0344, r24
		r_next_y=y+1;
    216a:	9b 01       	movw	r18, r22
    216c:	2f 5f       	subi	r18, 0xFF	; 255
    216e:	3f 4f       	sbci	r19, 0xFF	; 255
    2170:	30 93 c7 04 	sts	0x04C7, r19
    2174:	20 93 c6 04 	sts	0x04C6, r18
    2178:	1b c0       	rjmp	.+54     	; 0x21b0 <rescue_next_cordinate+0x54>
	}
	
	if(my_orientation==1)
    217a:	41 30       	cpi	r20, 0x01	; 1
    217c:	51 05       	cpc	r21, r1
    217e:	51 f4       	brne	.+20     	; 0x2194 <rescue_next_cordinate+0x38>
	{
		r_next_x=x+1;
    2180:	01 96       	adiw	r24, 0x01	; 1
    2182:	90 93 45 03 	sts	0x0345, r25
    2186:	80 93 44 03 	sts	0x0344, r24
		r_next_y=y;
    218a:	70 93 c7 04 	sts	0x04C7, r23
    218e:	60 93 c6 04 	sts	0x04C6, r22
    2192:	08 95       	ret
	}
	
	if(my_orientation==2)
    2194:	42 30       	cpi	r20, 0x02	; 2
    2196:	51 05       	cpc	r21, r1
    2198:	59 f4       	brne	.+22     	; 0x21b0 <rescue_next_cordinate+0x54>
	{
		r_next_x=x;
    219a:	90 93 45 03 	sts	0x0345, r25
    219e:	80 93 44 03 	sts	0x0344, r24
		r_next_y=y-1;
    21a2:	61 50       	subi	r22, 0x01	; 1
    21a4:	70 40       	sbci	r23, 0x00	; 0
    21a6:	70 93 c7 04 	sts	0x04C7, r23
    21aa:	60 93 c6 04 	sts	0x04C6, r22
    21ae:	08 95       	ret
	}
	
	if(my_orientation==3)
    21b0:	43 30       	cpi	r20, 0x03	; 3
    21b2:	51 05       	cpc	r21, r1
    21b4:	49 f4       	brne	.+18     	; 0x21c8 <rescue_next_cordinate+0x6c>
	{
		r_next_x=x-1;
    21b6:	01 97       	sbiw	r24, 0x01	; 1
    21b8:	90 93 45 03 	sts	0x0345, r25
    21bc:	80 93 44 03 	sts	0x0344, r24
		r_next_y=y;
    21c0:	70 93 c7 04 	sts	0x04C7, r23
    21c4:	60 93 c6 04 	sts	0x04C6, r22
    21c8:	08 95       	ret

000021ca <radar_rescue>:
	}
}

void radar_rescue (void)
{ unsigned int i;
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
	rescue_next_cordinate(rescue_x,rescue_y,rescue_or); //find next node
    21ce:	60 91 b9 04 	lds	r22, 0x04B9
    21d2:	70 91 ba 04 	lds	r23, 0x04BA
    21d6:	40 91 b5 04 	lds	r20, 0x04B5
    21da:	50 91 b6 04 	lds	r21, 0x04B6
    21de:	80 91 b3 04 	lds	r24, 0x04B3
    21e2:	90 91 b4 04 	lds	r25, 0x04B4
    21e6:	0e 94 ae 10 	call	0x215c	; 0x215c <rescue_next_cordinate>
	r_node_x=r_next_x;
    21ea:	80 91 44 03 	lds	r24, 0x0344
    21ee:	90 91 45 03 	lds	r25, 0x0345
    21f2:	90 93 b2 04 	sts	0x04B2, r25
    21f6:	80 93 b1 04 	sts	0x04B1, r24
	r_node_y=r_next_y;
    21fa:	80 91 c6 04 	lds	r24, 0x04C6
    21fe:	90 91 c7 04 	lds	r25, 0x04C7
    2202:	90 93 cd 04 	sts	0x04CD, r25
    2206:	80 93 cc 04 	sts	0x04CC, r24
	for (i=0;i<4;i++)
    220a:	c0 e0       	ldi	r28, 0x00	; 0
    220c:	d0 e0       	ldi	r29, 0x00	; 0
	{
		rescue_next_cordinate(r_node_x,r_node_y,i);
    220e:	60 91 cc 04 	lds	r22, 0x04CC
    2212:	70 91 cd 04 	lds	r23, 0x04CD
    2216:	80 91 b1 04 	lds	r24, 0x04B1
    221a:	90 91 b2 04 	lds	r25, 0x04B2
    221e:	ae 01       	movw	r20, r28
    2220:	0e 94 ae 10 	call	0x215c	; 0x215c <rescue_next_cordinate>
		 if ((r_next_x==x_counter) && (r_next_y==y_counter))
    2224:	20 91 44 03 	lds	r18, 0x0344
    2228:	30 91 45 03 	lds	r19, 0x0345
    222c:	80 91 fa 02 	lds	r24, 0x02FA
    2230:	90 91 fb 02 	lds	r25, 0x02FB
    2234:	28 17       	cp	r18, r24
    2236:	39 07       	cpc	r19, r25
    2238:	a1 f4       	brne	.+40     	; 0x2262 <__stack+0x63>
    223a:	20 91 c6 04 	lds	r18, 0x04C6
    223e:	30 91 c7 04 	lds	r19, 0x04C7
    2242:	80 91 2c 03 	lds	r24, 0x032C
    2246:	90 91 2d 03 	lds	r25, 0x032D
    224a:	28 17       	cp	r18, r24
    224c:	39 07       	cpc	r19, r25
    224e:	49 f4       	brne	.+18     	; 0x2262 <__stack+0x63>
	    {
			
			block_buzzer();
    2250:	0e 94 73 07 	call	0xee6	; 0xee6 <block_buzzer>
			wait=1;
    2254:	81 e0       	ldi	r24, 0x01	; 1
    2256:	90 e0       	ldi	r25, 0x00	; 0
    2258:	90 93 0d 03 	sts	0x030D, r25
    225c:	80 93 0c 03 	sts	0x030C, r24
			break;
    2260:	08 c0       	rjmp	.+16     	; 0x2272 <__stack+0x73>
	    }
		else
		{
			wait=0;
    2262:	10 92 0d 03 	sts	0x030D, r1
    2266:	10 92 0c 03 	sts	0x030C, r1
void radar_rescue (void)
{ unsigned int i;
	rescue_next_cordinate(rescue_x,rescue_y,rescue_or); //find next node
	r_node_x=r_next_x;
	r_node_y=r_next_y;
	for (i=0;i<4;i++)
    226a:	21 96       	adiw	r28, 0x01	; 1
    226c:	c4 30       	cpi	r28, 0x04	; 4
    226e:	d1 05       	cpc	r29, r1
    2270:	71 f6       	brne	.-100    	; 0x220e <__stack+0xf>
		{
			wait=0;
		}
	}
	
	connection=1;
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	90 93 15 03 	sts	0x0315, r25
    227a:	80 93 14 03 	sts	0x0314, r24
	send_data();
    227e:	0e 94 98 02 	call	0x530	; 0x530 <send_data>
	
}
    2282:	df 91       	pop	r29
    2284:	cf 91       	pop	r28
    2286:	08 95       	ret

00002288 <get_me_this_orientatoin>:
	}
}


void get_me_this_orientatoin (unsigned int wanted_orientation)
{ unsigned int clear=1, o1,o2, o1_log, o2_log;
    2288:	8f 92       	push	r8
    228a:	9f 92       	push	r9
    228c:	af 92       	push	r10
    228e:	bf 92       	push	r11
    2290:	cf 92       	push	r12
    2292:	df 92       	push	r13
    2294:	ef 92       	push	r14
    2296:	ff 92       	push	r15
    2298:	0f 93       	push	r16
    229a:	1f 93       	push	r17
    229c:	cf 93       	push	r28
    229e:	df 93       	push	r29
    22a0:	8c 01       	movw	r16, r24
	{
		o1=orientation+1;
		o2=orientation-1;
		if (o1==4)
		{
			o1=0;
    22a2:	aa 24       	eor	r10, r10
    22a4:	bb 24       	eor	r11, r11
			
		}
		
		if ( o2==-1)
		{
			o2=3;
    22a6:	0f 2e       	mov	r0, r31
    22a8:	f3 e0       	ldi	r31, 0x03	; 3
    22aa:	8f 2e       	mov	r8, r31
    22ac:	99 24       	eor	r9, r9
    22ae:	f0 2d       	mov	r31, r0
		}
		
		else
		{
			next_cordinate(o1);
			o1_log=path_log[next_x][next_y];
    22b0:	0f 2e       	mov	r0, r31
    22b2:	f8 e0       	ldi	r31, 0x08	; 8
    22b4:	cf 2e       	mov	r12, r31
    22b6:	f2 e0       	ldi	r31, 0x02	; 2
    22b8:	df 2e       	mov	r13, r31
    22ba:	f0 2d       	mov	r31, r0

void get_me_this_orientatoin (unsigned int wanted_orientation)
{ unsigned int clear=1, o1,o2, o1_log, o2_log;
	while(clear)
	{
		o1=orientation+1;
    22bc:	80 91 34 03 	lds	r24, 0x0334
    22c0:	90 91 35 03 	lds	r25, 0x0335
    22c4:	9c 01       	movw	r18, r24
    22c6:	2f 5f       	subi	r18, 0xFF	; 255
    22c8:	3f 4f       	sbci	r19, 0xFF	; 255
		o2=orientation-1;
    22ca:	ec 01       	movw	r28, r24
    22cc:	21 97       	sbiw	r28, 0x01	; 1
		if (o1==4)
    22ce:	24 30       	cpi	r18, 0x04	; 4
    22d0:	31 05       	cpc	r19, r1
    22d2:	09 f4       	brne	.+2      	; 0x22d6 <get_me_this_orientatoin+0x4e>
		{
			o1=0;
    22d4:	95 01       	movw	r18, r10
			
		}
		
		if ( o2==-1)
    22d6:	4f ef       	ldi	r20, 0xFF	; 255
    22d8:	cf 3f       	cpi	r28, 0xFF	; 255
    22da:	d4 07       	cpc	r29, r20
    22dc:	09 f4       	brne	.+2      	; 0x22e0 <get_me_this_orientatoin+0x58>
		{
			o2=3;
    22de:	e4 01       	movw	r28, r8
			
		}
		
		if (orientation==wanted_orientation)
    22e0:	80 17       	cp	r24, r16
    22e2:	91 07       	cpc	r25, r17
    22e4:	09 f4       	brne	.+2      	; 0x22e8 <get_me_this_orientatoin+0x60>
    22e6:	5b c0       	rjmp	.+182    	; 0x239e <get_me_this_orientatoin+0x116>
		{
			clear=0;
		}
		
		else if (o1==wanted_orientation)
    22e8:	20 17       	cp	r18, r16
    22ea:	31 07       	cpc	r19, r17
    22ec:	19 f4       	brne	.+6      	; 0x22f4 <get_me_this_orientatoin+0x6c>
		{
			right_90();
    22ee:	0e 94 be 0c 	call	0x197c	; 0x197c <right_90>
    22f2:	52 c0       	rjmp	.+164    	; 0x2398 <get_me_this_orientatoin+0x110>
		}
		
		else if (o2==wanted_orientation)
    22f4:	c0 17       	cp	r28, r16
    22f6:	d1 07       	cpc	r29, r17
    22f8:	19 f4       	brne	.+6      	; 0x2300 <get_me_this_orientatoin+0x78>
		{
			left_90();
    22fa:	0e 94 ce 0c 	call	0x199c	; 0x199c <left_90>
    22fe:	4c c0       	rjmp	.+152    	; 0x2398 <get_me_this_orientatoin+0x110>
		}
		
		else
		{
			next_cordinate(o1);
    2300:	c9 01       	movw	r24, r18
    2302:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
			o1_log=path_log[next_x][next_y];
    2306:	40 91 20 03 	lds	r20, 0x0320
    230a:	50 91 21 03 	lds	r21, 0x0321
    230e:	ca 01       	movw	r24, r20
    2310:	88 0f       	add	r24, r24
    2312:	99 1f       	adc	r25, r25
    2314:	9a 01       	movw	r18, r20
    2316:	22 0f       	add	r18, r18
    2318:	33 1f       	adc	r19, r19
    231a:	22 0f       	add	r18, r18
    231c:	33 1f       	adc	r19, r19
    231e:	22 0f       	add	r18, r18
    2320:	33 1f       	adc	r19, r19
    2322:	82 0f       	add	r24, r18
    2324:	93 1f       	adc	r25, r19
    2326:	84 0f       	add	r24, r20
    2328:	95 1f       	adc	r25, r21
    232a:	20 91 22 03 	lds	r18, 0x0322
    232e:	30 91 23 03 	lds	r19, 0x0323
    2332:	82 0f       	add	r24, r18
    2334:	93 1f       	adc	r25, r19
    2336:	88 0f       	add	r24, r24
    2338:	99 1f       	adc	r25, r25
    233a:	8c 0d       	add	r24, r12
    233c:	9d 1d       	adc	r25, r13
    233e:	fc 01       	movw	r30, r24
    2340:	e0 80       	ld	r14, Z
    2342:	f1 80       	ldd	r15, Z+1	; 0x01
			next_cordinate(o2);
    2344:	ce 01       	movw	r24, r28
    2346:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
			o2_log=path_log[next_x][next_y];
    234a:	40 91 20 03 	lds	r20, 0x0320
    234e:	50 91 21 03 	lds	r21, 0x0321
    2352:	ca 01       	movw	r24, r20
    2354:	88 0f       	add	r24, r24
    2356:	99 1f       	adc	r25, r25
    2358:	9a 01       	movw	r18, r20
    235a:	22 0f       	add	r18, r18
    235c:	33 1f       	adc	r19, r19
    235e:	22 0f       	add	r18, r18
    2360:	33 1f       	adc	r19, r19
    2362:	22 0f       	add	r18, r18
    2364:	33 1f       	adc	r19, r19
    2366:	82 0f       	add	r24, r18
    2368:	93 1f       	adc	r25, r19
    236a:	84 0f       	add	r24, r20
    236c:	95 1f       	adc	r25, r21
    236e:	20 91 22 03 	lds	r18, 0x0322
    2372:	30 91 23 03 	lds	r19, 0x0323
    2376:	82 0f       	add	r24, r18
    2378:	93 1f       	adc	r25, r19
    237a:	88 0f       	add	r24, r24
    237c:	99 1f       	adc	r25, r25
    237e:	8c 0d       	add	r24, r12
    2380:	9d 1d       	adc	r25, r13
			if(o1_log>o2_log)
    2382:	fc 01       	movw	r30, r24
    2384:	80 81       	ld	r24, Z
    2386:	91 81       	ldd	r25, Z+1	; 0x01
    2388:	8e 15       	cp	r24, r14
    238a:	9f 05       	cpc	r25, r15
    238c:	18 f4       	brcc	.+6      	; 0x2394 <get_me_this_orientatoin+0x10c>
	     	{ left_90(); }
    238e:	0e 94 ce 0c 	call	0x199c	; 0x199c <left_90>
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <get_me_this_orientatoin+0x110>
			else
			{
				right_90();
    2394:	0e 94 be 0c 	call	0x197c	; 0x197c <right_90>
			}
			
		}
		
		update_orientation();
    2398:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <update_orientation>
    239c:	8f cf       	rjmp	.-226    	; 0x22bc <get_me_this_orientatoin+0x34>
    239e:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <update_orientation>
	}
}
    23a2:	df 91       	pop	r29
    23a4:	cf 91       	pop	r28
    23a6:	1f 91       	pop	r17
    23a8:	0f 91       	pop	r16
    23aa:	ff 90       	pop	r15
    23ac:	ef 90       	pop	r14
    23ae:	df 90       	pop	r13
    23b0:	cf 90       	pop	r12
    23b2:	bf 90       	pop	r11
    23b4:	af 90       	pop	r10
    23b6:	9f 90       	pop	r9
    23b8:	8f 90       	pop	r8
    23ba:	08 95       	ret

000023bc <distance_of_safe_plce>:


int distance_of_safe_plce (int x,int y)
{ int b;
	b=abs(5-x)+abs(1-y);
    23bc:	25 e0       	ldi	r18, 0x05	; 5
    23be:	30 e0       	ldi	r19, 0x00	; 0
    23c0:	28 1b       	sub	r18, r24
    23c2:	39 0b       	sbc	r19, r25
    23c4:	1a f4       	brpl	.+6      	; 0x23cc <distance_of_safe_plce+0x10>
    23c6:	30 95       	com	r19
    23c8:	21 95       	neg	r18
    23ca:	3f 4f       	sbci	r19, 0xFF	; 255
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	90 e0       	ldi	r25, 0x00	; 0
    23d0:	86 1b       	sub	r24, r22
    23d2:	97 0b       	sbc	r25, r23
    23d4:	1a f4       	brpl	.+6      	; 0x23dc <distance_of_safe_plce+0x20>
    23d6:	90 95       	com	r25
    23d8:	81 95       	neg	r24
    23da:	9f 4f       	sbci	r25, 0xFF	; 255
    23dc:	82 0f       	add	r24, r18
    23de:	93 1f       	adc	r25, r19
	return b;
}
    23e0:	08 95       	ret

000023e2 <find_a_way_to_safe>:

void find_a_way_to_safe (void)
{  unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
    23e2:	4f 92       	push	r4
    23e4:	5f 92       	push	r5
    23e6:	6f 92       	push	r6
    23e8:	7f 92       	push	r7
    23ea:	8f 92       	push	r8
    23ec:	9f 92       	push	r9
    23ee:	af 92       	push	r10
    23f0:	bf 92       	push	r11
    23f2:	cf 92       	push	r12
    23f4:	df 92       	push	r13
    23f6:	ef 92       	push	r14
    23f8:	ff 92       	push	r15
    23fa:	0f 93       	push	r16
    23fc:	1f 93       	push	r17
    23fe:	cf 93       	push	r28
    2400:	df 93       	push	r29
    2402:	cd b7       	in	r28, 0x3d	; 61
    2404:	de b7       	in	r29, 0x3e	; 62
    2406:	28 97       	sbiw	r28, 0x08	; 8
    2408:	0f b6       	in	r0, 0x3f	; 63
    240a:	f8 94       	cli
    240c:	de bf       	out	0x3e, r29	; 62
    240e:	0f be       	out	0x3f, r0	; 63
    2410:	cd bf       	out	0x3d, r28	; 61
		}
		lcd_string("x");
		for (i=0;i<4;i++)
		{
			
			if (distance[i]<prev)
    2412:	4e 01       	movw	r8, r28
    2414:	08 94       	sec
    2416:	81 1c       	adc	r8, r1
    2418:	91 1c       	adc	r9, r1
	b=abs(5-x)+abs(1-y);
	return b;
}

void find_a_way_to_safe (void)
{  unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
    241a:	54 01       	movw	r10, r8
		for (i=0;i<4;i++)
    241c:	ee 24       	eor	r14, r14
    241e:	ff 24       	eor	r15, r15
		{
			next_cordinate(i);

			blockings=path_log[next_x][next_y];
    2420:	0f 2e       	mov	r0, r31
    2422:	f8 e0       	ldi	r31, 0x08	; 8
    2424:	6f 2e       	mov	r6, r31
    2426:	f2 e0       	ldi	r31, 0x02	; 2
    2428:	7f 2e       	mov	r7, r31
    242a:	f0 2d       	mov	r31, r0

void find_a_way_to_safe (void)
{  unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
		for (i=0;i<4;i++)
		{
			next_cordinate(i);
    242c:	8e 2d       	mov	r24, r14
    242e:	9f 2d       	mov	r25, r15
    2430:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>

			blockings=path_log[next_x][next_y];
    2434:	40 91 20 03 	lds	r20, 0x0320
    2438:	50 91 21 03 	lds	r21, 0x0321
    243c:	ca 01       	movw	r24, r20
    243e:	88 0f       	add	r24, r24
    2440:	99 1f       	adc	r25, r25
    2442:	9a 01       	movw	r18, r20
    2444:	22 0f       	add	r18, r18
    2446:	33 1f       	adc	r19, r19
    2448:	22 0f       	add	r18, r18
    244a:	33 1f       	adc	r19, r19
    244c:	22 0f       	add	r18, r18
    244e:	33 1f       	adc	r19, r19
    2450:	82 0f       	add	r24, r18
    2452:	93 1f       	adc	r25, r19
    2454:	84 0f       	add	r24, r20
    2456:	95 1f       	adc	r25, r21
    2458:	20 91 22 03 	lds	r18, 0x0322
    245c:	30 91 23 03 	lds	r19, 0x0323
    2460:	82 0f       	add	r24, r18
    2462:	93 1f       	adc	r25, r19
    2464:	fc 01       	movw	r30, r24
    2466:	ee 0f       	add	r30, r30
    2468:	ff 1f       	adc	r31, r31
    246a:	e6 0d       	add	r30, r6
    246c:	f7 1d       	adc	r31, r7
    246e:	00 81       	ld	r16, Z
    2470:	11 81       	ldd	r17, Z+1	; 0x01
			//lcd_print(2,11+i,blocnkings,1);
			if (blockings==0)
    2472:	01 15       	cp	r16, r1
    2474:	11 05       	cpc	r17, r1
    2476:	91 f4       	brne	.+36     	; 0x249c <find_a_way_to_safe+0xba>
			{
				next_cordinate(i);
    2478:	8e 2d       	mov	r24, r14
    247a:	9f 2d       	mov	r25, r15
    247c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
				distance[i]= distance_of_safe_plce(next_x,next_y);
    2480:	60 91 22 03 	lds	r22, 0x0322
    2484:	70 91 23 03 	lds	r23, 0x0323
    2488:	80 91 20 03 	lds	r24, 0x0320
    248c:	90 91 21 03 	lds	r25, 0x0321
    2490:	0e 94 de 11 	call	0x23bc	; 0x23bc <distance_of_safe_plce>
    2494:	f5 01       	movw	r30, r10
    2496:	91 83       	std	Z+1, r25	; 0x01
    2498:	80 83       	st	Z, r24
    249a:	18 c0       	rjmp	.+48     	; 0x24cc <find_a_way_to_safe+0xea>
			}
			else
			{
				next_cordinate(i);
    249c:	8e 2d       	mov	r24, r14
    249e:	9f 2d       	mov	r25, r15
    24a0:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
				distance_of_safe_plce(next_x,next_y);
				distance[i]= distance_of_safe_plce(next_x,next_y)+blockings*4;
    24a4:	60 91 22 03 	lds	r22, 0x0322
    24a8:	70 91 23 03 	lds	r23, 0x0323
    24ac:	80 91 20 03 	lds	r24, 0x0320
    24b0:	90 91 21 03 	lds	r25, 0x0321
    24b4:	0e 94 de 11 	call	0x23bc	; 0x23bc <distance_of_safe_plce>
    24b8:	98 01       	movw	r18, r16
    24ba:	22 0f       	add	r18, r18
    24bc:	33 1f       	adc	r19, r19
    24be:	22 0f       	add	r18, r18
    24c0:	33 1f       	adc	r19, r19
    24c2:	28 0f       	add	r18, r24
    24c4:	39 1f       	adc	r19, r25
    24c6:	f5 01       	movw	r30, r10
    24c8:	31 83       	std	Z+1, r19	; 0x01
    24ca:	20 83       	st	Z, r18
	return b;
}

void find_a_way_to_safe (void)
{  unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
		for (i=0;i<4;i++)
    24cc:	08 94       	sec
    24ce:	e1 1c       	adc	r14, r1
    24d0:	f1 1c       	adc	r15, r1
    24d2:	82 e0       	ldi	r24, 0x02	; 2
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	a8 0e       	add	r10, r24
    24d8:	b9 1e       	adc	r11, r25
    24da:	94 e0       	ldi	r25, 0x04	; 4
    24dc:	e9 16       	cp	r14, r25
    24de:	f1 04       	cpc	r15, r1
    24e0:	09 f0       	breq	.+2      	; 0x24e4 <find_a_way_to_safe+0x102>
    24e2:	a4 cf       	rjmp	.-184    	; 0x242c <find_a_way_to_safe+0x4a>
				distance_of_safe_plce(next_x,next_y);
				distance[i]= distance_of_safe_plce(next_x,next_y)+blockings*4;
			}
			
		}
		lcd_string("x");
    24e4:	82 e0       	ldi	r24, 0x02	; 2
    24e6:	92 e0       	ldi	r25, 0x02	; 2
    24e8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_string>
	b=abs(5-x)+abs(1-y);
	return b;
}

void find_a_way_to_safe (void)
{  unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
    24ec:	44 e6       	ldi	r20, 0x64	; 100
    24ee:	50 e0       	ldi	r21, 0x00	; 0
				distance[i]= distance_of_safe_plce(next_x,next_y)+blockings*4;
			}
			
		}
		lcd_string("x");
		for (i=0;i<4;i++)
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	90 e0       	ldi	r25, 0x00	; 0
		{
			
			if (distance[i]<prev)
    24f4:	f4 01       	movw	r30, r8
    24f6:	21 91       	ld	r18, Z+
    24f8:	31 91       	ld	r19, Z+
    24fa:	4f 01       	movw	r8, r30
    24fc:	24 17       	cp	r18, r20
    24fe:	35 07       	cpc	r19, r21
    2500:	18 f4       	brcc	.+6      	; 0x2508 <find_a_way_to_safe+0x126>
			{
				prev=distance[i];
    2502:	a9 01       	movw	r20, r18
		}
		lcd_string("x");
		for (i=0;i<4;i++)
		{
			
			if (distance[i]<prev)
    2504:	58 2e       	mov	r5, r24
    2506:	49 2e       	mov	r4, r25
				distance[i]= distance_of_safe_plce(next_x,next_y)+blockings*4;
			}
			
		}
		lcd_string("x");
		for (i=0;i<4;i++)
    2508:	01 96       	adiw	r24, 0x01	; 1
    250a:	84 30       	cpi	r24, 0x04	; 4
    250c:	91 05       	cpc	r25, r1
    250e:	91 f7       	brne	.-28     	; 0x24f4 <find_a_way_to_safe+0x112>
				result=i;
			}
		}
		
		wanted_orientation=result;
		get_me_this_orientatoin(wanted_orientation);
    2510:	85 2d       	mov	r24, r5
    2512:	94 2d       	mov	r25, r4
    2514:	0e 94 44 11 	call	0x2288	; 0x2288 <get_me_this_orientatoin>
		
		// 	 next_cordinate(result);
		// 	 distance_of_plot(next_x,next_y);

}
    2518:	28 96       	adiw	r28, 0x08	; 8
    251a:	0f b6       	in	r0, 0x3f	; 63
    251c:	f8 94       	cli
    251e:	de bf       	out	0x3e, r29	; 62
    2520:	0f be       	out	0x3f, r0	; 63
    2522:	cd bf       	out	0x3d, r28	; 61
    2524:	df 91       	pop	r29
    2526:	cf 91       	pop	r28
    2528:	1f 91       	pop	r17
    252a:	0f 91       	pop	r16
    252c:	ff 90       	pop	r15
    252e:	ef 90       	pop	r14
    2530:	df 90       	pop	r13
    2532:	cf 90       	pop	r12
    2534:	bf 90       	pop	r11
    2536:	af 90       	pop	r10
    2538:	9f 90       	pop	r9
    253a:	8f 90       	pop	r8
    253c:	7f 90       	pop	r7
    253e:	6f 90       	pop	r6
    2540:	5f 90       	pop	r5
    2542:	4f 90       	pop	r4
    2544:	08 95       	ret

00002546 <node_procedure>:


void node_procedure (void)
{ unsigned int clear=1;
    2546:	0f 93       	push	r16
    2548:	1f 93       	push	r17
    254a:	cf 93       	push	r28
    254c:	df 93       	push	r29
		
		black=scan_block();
		if(black==1)
		{	
			next_cordinate(orientation);
			path_log[next_x][next_y]=8;
    254e:	c8 e0       	ldi	r28, 0x08	; 8
    2550:	d2 e0       	ldi	r29, 0x02	; 2
    2552:	08 e0       	ldi	r16, 0x08	; 8
    2554:	10 e0       	ldi	r17, 0x00	; 0

void node_procedure (void)
{ unsigned int clear=1;
	while(clear)
	{  
		find_a_way_to_safe();
    2556:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <find_a_way_to_safe>
		
		black=scan_block();
    255a:	0e 94 08 08 	call	0x1010	; 0x1010 <scan_block>
    255e:	28 2f       	mov	r18, r24
    2560:	39 2f       	mov	r19, r25
    2562:	30 93 09 04 	sts	0x0409, r19
    2566:	20 93 08 04 	sts	0x0408, r18
		if(black==1)
    256a:	21 30       	cpi	r18, 0x01	; 1
    256c:	31 05       	cpc	r19, r1
    256e:	31 f5       	brne	.+76     	; 0x25bc <node_procedure+0x76>
		{	
			next_cordinate(orientation);
    2570:	80 91 34 03 	lds	r24, 0x0334
    2574:	90 91 35 03 	lds	r25, 0x0335
    2578:	0e 94 56 0e 	call	0x1cac	; 0x1cac <next_cordinate>
			path_log[next_x][next_y]=8;
    257c:	40 91 20 03 	lds	r20, 0x0320
    2580:	50 91 21 03 	lds	r21, 0x0321
    2584:	ca 01       	movw	r24, r20
    2586:	88 0f       	add	r24, r24
    2588:	99 1f       	adc	r25, r25
    258a:	9a 01       	movw	r18, r20
    258c:	22 0f       	add	r18, r18
    258e:	33 1f       	adc	r19, r19
    2590:	22 0f       	add	r18, r18
    2592:	33 1f       	adc	r19, r19
    2594:	22 0f       	add	r18, r18
    2596:	33 1f       	adc	r19, r19
    2598:	82 0f       	add	r24, r18
    259a:	93 1f       	adc	r25, r19
    259c:	48 0f       	add	r20, r24
    259e:	59 1f       	adc	r21, r25
    25a0:	60 91 22 03 	lds	r22, 0x0322
    25a4:	70 91 23 03 	lds	r23, 0x0323
    25a8:	46 0f       	add	r20, r22
    25aa:	57 1f       	adc	r21, r23
    25ac:	fa 01       	movw	r30, r20
    25ae:	ee 0f       	add	r30, r30
    25b0:	ff 1f       	adc	r31, r31
    25b2:	ec 0f       	add	r30, r28
    25b4:	fd 1f       	adc	r31, r29
    25b6:	11 83       	std	Z+1, r17	; 0x01
    25b8:	00 83       	st	Z, r16
    25ba:	cd cf       	rjmp	.-102    	; 0x2556 <node_procedure+0x10>
		else
		{
			clear=0;
		}
	}
}
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	1f 91       	pop	r17
    25c2:	0f 91       	pop	r16
    25c4:	08 95       	ret

000025c6 <go_to_safe_place>:

void go_to_safe_place (void)
{ int travel=1;
    25c6:	cf 93       	push	r28
    25c8:	df 93       	push	r29
	clear_path();
    25ca:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <clear_path>
		  
		  }
	  
	  if (Iam_at==2)
	  {
		  path_log[x_counter][y_counter]++;
    25ce:	c8 e0       	ldi	r28, 0x08	; 8
    25d0:	d2 e0       	ldi	r29, 0x02	; 2
}

void go_to_safe_place (void)
{ int travel=1;
	clear_path();
  while(travel)
    25d2:	3d c0       	rjmp	.+122    	; 0x264e <go_to_safe_place+0x88>
	{
	 nodeORmid();
	  if (Iam_at==1)
	  {
		  if ((x_counter==5) &&( y_counter==1))
    25d4:	80 91 fa 02 	lds	r24, 0x02FA
    25d8:	90 91 fb 02 	lds	r25, 0x02FB
    25dc:	85 30       	cpi	r24, 0x05	; 5
    25de:	91 05       	cpc	r25, r1
    25e0:	39 f4       	brne	.+14     	; 0x25f0 <go_to_safe_place+0x2a>
    25e2:	80 91 2c 03 	lds	r24, 0x032C
    25e6:	90 91 2d 03 	lds	r25, 0x032D
    25ea:	81 30       	cpi	r24, 0x01	; 1
    25ec:	91 05       	cpc	r25, r1
    25ee:	c9 f1       	breq	.+114    	; 0x2662 <go_to_safe_place+0x9c>
		  {
			  travel=0;
			  break;
		  }
		  node_procedure();
    25f0:	0e 94 a3 12 	call	0x2546	; 0x2546 <node_procedure>
		  follow_line();
    25f4:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <follow_line>
		  
		  }
	  
	  if (Iam_at==2)
    25f8:	80 91 12 03 	lds	r24, 0x0312
    25fc:	90 91 13 03 	lds	r25, 0x0313
    2600:	82 30       	cpi	r24, 0x02	; 2
    2602:	91 05       	cpc	r25, r1
    2604:	21 f5       	brne	.+72     	; 0x264e <go_to_safe_place+0x88>
	  {
		  path_log[x_counter][y_counter]++;
    2606:	40 91 fa 02 	lds	r20, 0x02FA
    260a:	50 91 fb 02 	lds	r21, 0x02FB
    260e:	60 91 2c 03 	lds	r22, 0x032C
    2612:	70 91 2d 03 	lds	r23, 0x032D
    2616:	ca 01       	movw	r24, r20
    2618:	88 0f       	add	r24, r24
    261a:	99 1f       	adc	r25, r25
    261c:	9a 01       	movw	r18, r20
    261e:	22 0f       	add	r18, r18
    2620:	33 1f       	adc	r19, r19
    2622:	22 0f       	add	r18, r18
    2624:	33 1f       	adc	r19, r19
    2626:	22 0f       	add	r18, r18
    2628:	33 1f       	adc	r19, r19
    262a:	82 0f       	add	r24, r18
    262c:	93 1f       	adc	r25, r19
    262e:	84 0f       	add	r24, r20
    2630:	95 1f       	adc	r25, r21
    2632:	68 0f       	add	r22, r24
    2634:	79 1f       	adc	r23, r25
    2636:	fb 01       	movw	r30, r22
    2638:	ee 0f       	add	r30, r30
    263a:	ff 1f       	adc	r31, r31
    263c:	ec 0f       	add	r30, r28
    263e:	fd 1f       	adc	r31, r29
    2640:	80 81       	ld	r24, Z
    2642:	91 81       	ldd	r25, Z+1	; 0x01
    2644:	01 96       	adiw	r24, 0x01	; 1
    2646:	91 83       	std	Z+1, r25	; 0x01
    2648:	80 83       	st	Z, r24
		  follow_line();
    264a:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <follow_line>
void go_to_safe_place (void)
{ int travel=1;
	clear_path();
  while(travel)
	{
	 nodeORmid();
    264e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <nodeORmid>
	  if (Iam_at==1)
    2652:	80 91 12 03 	lds	r24, 0x0312
    2656:	90 91 13 03 	lds	r25, 0x0313
    265a:	81 30       	cpi	r24, 0x01	; 1
    265c:	91 05       	cpc	r25, r1
    265e:	61 f6       	brne	.-104    	; 0x25f8 <go_to_safe_place+0x32>
    2660:	b9 cf       	rjmp	.-142    	; 0x25d4 <go_to_safe_place+0xe>
		  path_log[x_counter][y_counter]++;
		  follow_line();
	  }
	
	}  
}
    2662:	df 91       	pop	r29
    2664:	cf 91       	pop	r28
    2666:	08 95       	ret

00002668 <main>:
}

// Search robot
int main (void)
{ 
	cli();
    2668:	f8 94       	cli
	port_init();
    266a:	0e 94 21 06 	call	0xc42	; 0xc42 <port_init>
	sei();
    266e:	78 94       	sei

    clear_matrix();          // clear matrix of arena
    2670:	0e 94 37 0e 	call	0x1c6e	; 0x1c6e <clear_matrix>

    lcd_set_4bit();
    2674:	0e 94 34 01 	call	0x268	; 0x268 <lcd_set_4bit>
	lcd_init();
    2678:	0e 94 9c 01 	call	0x338	; 0x338 <lcd_init>


follow_line();
    267c:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <follow_line>


while (1)
   {
	   nodeORmid();
    2680:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <nodeORmid>
	  lcd_print(1,8,Iam_at,1);
    2684:	40 91 12 03 	lds	r20, 0x0312
    2688:	50 91 13 03 	lds	r21, 0x0313
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	68 e0       	ldi	r22, 0x08	; 8
    2690:	21 e0       	ldi	r18, 0x01	; 1
    2692:	30 e0       	ldi	r19, 0x00	; 0
    2694:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_print>
	  if (Iam_at==1)     // robot at node 
    2698:	80 91 12 03 	lds	r24, 0x0312
    269c:	90 91 13 03 	lds	r25, 0x0313
    26a0:	81 30       	cpi	r24, 0x01	; 1
    26a2:	91 05       	cpc	r25, r1
    26a4:	21 f4       	brne	.+8      	; 0x26ae <main+0x46>
	  {
		  node_action();
    26a6:	0e 94 14 10 	call	0x2028	; 0x2028 <node_action>
		  follow_line();
    26aa:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <follow_line>
	  }
	 if (Iam_at==2)     // robot at mid point
    26ae:	80 91 12 03 	lds	r24, 0x0312
    26b2:	90 91 13 03 	lds	r25, 0x0313
    26b6:	82 30       	cpi	r24, 0x02	; 2
    26b8:	91 05       	cpc	r25, r1
    26ba:	31 f4       	brne	.+12     	; 0x26c8 <main+0x60>
	 {
		 path_log_entry();
    26bc:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <path_log_entry>
	     scan_plot();
    26c0:	0e 94 a7 08 	call	0x114e	; 0x114e <scan_plot>
		// radar_rescue();
		
		 follow_line();
    26c4:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <follow_line>
		
	 }
	 
	 lcd_cursor(2,2);
    26c8:	82 e0       	ldi	r24, 0x02	; 2
    26ca:	62 e0       	ldi	r22, 0x02	; 2
    26cc:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <lcd_cursor>
	 lcd_string(n);
    26d0:	80 91 1c 03 	lds	r24, 0x031C
    26d4:	90 91 1d 03 	lds	r25, 0x031D
    26d8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_string>
	 if (num_plots==16)
    26dc:	80 91 1a 03 	lds	r24, 0x031A
    26e0:	90 91 1b 03 	lds	r25, 0x031B
    26e4:	80 31       	cpi	r24, 0x10	; 16
    26e6:	91 05       	cpc	r25, r1
    26e8:	59 f6       	brne	.-106    	; 0x2680 <main+0x18>
	 {   go_to_safe_place();
    26ea:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <go_to_safe_place>
		 stop();
    26ee:	0e 94 49 03 	call	0x692	; 0x692 <stop>
    //scan_white_block();    //Scan the required block
    //lcd_print(2,14,num_plots,2);   //Number of plots scanned on lcd
		
   
   }
}
    26f2:	80 e0       	ldi	r24, 0x00	; 0
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	08 95       	ret

000026f8 <__subsf3>:
    26f8:	50 58       	subi	r21, 0x80	; 128

000026fa <__addsf3>:
    26fa:	bb 27       	eor	r27, r27
    26fc:	aa 27       	eor	r26, r26
    26fe:	0e d0       	rcall	.+28     	; 0x271c <__addsf3x>
    2700:	4d c1       	rjmp	.+666    	; 0x299c <__fp_round>
    2702:	3e d1       	rcall	.+636    	; 0x2980 <__fp_pscA>
    2704:	30 f0       	brcs	.+12     	; 0x2712 <__addsf3+0x18>
    2706:	43 d1       	rcall	.+646    	; 0x298e <__fp_pscB>
    2708:	20 f0       	brcs	.+8      	; 0x2712 <__addsf3+0x18>
    270a:	31 f4       	brne	.+12     	; 0x2718 <__addsf3+0x1e>
    270c:	9f 3f       	cpi	r25, 0xFF	; 255
    270e:	11 f4       	brne	.+4      	; 0x2714 <__addsf3+0x1a>
    2710:	1e f4       	brtc	.+6      	; 0x2718 <__addsf3+0x1e>
    2712:	33 c1       	rjmp	.+614    	; 0x297a <__fp_nan>
    2714:	0e f4       	brtc	.+2      	; 0x2718 <__addsf3+0x1e>
    2716:	e0 95       	com	r30
    2718:	e7 fb       	bst	r30, 7
    271a:	29 c1       	rjmp	.+594    	; 0x296e <__fp_inf>

0000271c <__addsf3x>:
    271c:	e9 2f       	mov	r30, r25
    271e:	4f d1       	rcall	.+670    	; 0x29be <__fp_split3>
    2720:	80 f3       	brcs	.-32     	; 0x2702 <__addsf3+0x8>
    2722:	ba 17       	cp	r27, r26
    2724:	62 07       	cpc	r22, r18
    2726:	73 07       	cpc	r23, r19
    2728:	84 07       	cpc	r24, r20
    272a:	95 07       	cpc	r25, r21
    272c:	18 f0       	brcs	.+6      	; 0x2734 <__addsf3x+0x18>
    272e:	71 f4       	brne	.+28     	; 0x274c <__addsf3x+0x30>
    2730:	9e f5       	brtc	.+102    	; 0x2798 <__addsf3x+0x7c>
    2732:	67 c1       	rjmp	.+718    	; 0x2a02 <__fp_zero>
    2734:	0e f4       	brtc	.+2      	; 0x2738 <__addsf3x+0x1c>
    2736:	e0 95       	com	r30
    2738:	0b 2e       	mov	r0, r27
    273a:	ba 2f       	mov	r27, r26
    273c:	a0 2d       	mov	r26, r0
    273e:	0b 01       	movw	r0, r22
    2740:	b9 01       	movw	r22, r18
    2742:	90 01       	movw	r18, r0
    2744:	0c 01       	movw	r0, r24
    2746:	ca 01       	movw	r24, r20
    2748:	a0 01       	movw	r20, r0
    274a:	11 24       	eor	r1, r1
    274c:	ff 27       	eor	r31, r31
    274e:	59 1b       	sub	r21, r25
    2750:	99 f0       	breq	.+38     	; 0x2778 <__addsf3x+0x5c>
    2752:	59 3f       	cpi	r21, 0xF9	; 249
    2754:	50 f4       	brcc	.+20     	; 0x276a <__addsf3x+0x4e>
    2756:	50 3e       	cpi	r21, 0xE0	; 224
    2758:	68 f1       	brcs	.+90     	; 0x27b4 <__addsf3x+0x98>
    275a:	1a 16       	cp	r1, r26
    275c:	f0 40       	sbci	r31, 0x00	; 0
    275e:	a2 2f       	mov	r26, r18
    2760:	23 2f       	mov	r18, r19
    2762:	34 2f       	mov	r19, r20
    2764:	44 27       	eor	r20, r20
    2766:	58 5f       	subi	r21, 0xF8	; 248
    2768:	f3 cf       	rjmp	.-26     	; 0x2750 <__addsf3x+0x34>
    276a:	46 95       	lsr	r20
    276c:	37 95       	ror	r19
    276e:	27 95       	ror	r18
    2770:	a7 95       	ror	r26
    2772:	f0 40       	sbci	r31, 0x00	; 0
    2774:	53 95       	inc	r21
    2776:	c9 f7       	brne	.-14     	; 0x276a <__addsf3x+0x4e>
    2778:	7e f4       	brtc	.+30     	; 0x2798 <__addsf3x+0x7c>
    277a:	1f 16       	cp	r1, r31
    277c:	ba 0b       	sbc	r27, r26
    277e:	62 0b       	sbc	r22, r18
    2780:	73 0b       	sbc	r23, r19
    2782:	84 0b       	sbc	r24, r20
    2784:	ba f0       	brmi	.+46     	; 0x27b4 <__addsf3x+0x98>
    2786:	91 50       	subi	r25, 0x01	; 1
    2788:	a1 f0       	breq	.+40     	; 0x27b2 <__addsf3x+0x96>
    278a:	ff 0f       	add	r31, r31
    278c:	bb 1f       	adc	r27, r27
    278e:	66 1f       	adc	r22, r22
    2790:	77 1f       	adc	r23, r23
    2792:	88 1f       	adc	r24, r24
    2794:	c2 f7       	brpl	.-16     	; 0x2786 <__addsf3x+0x6a>
    2796:	0e c0       	rjmp	.+28     	; 0x27b4 <__addsf3x+0x98>
    2798:	ba 0f       	add	r27, r26
    279a:	62 1f       	adc	r22, r18
    279c:	73 1f       	adc	r23, r19
    279e:	84 1f       	adc	r24, r20
    27a0:	48 f4       	brcc	.+18     	; 0x27b4 <__addsf3x+0x98>
    27a2:	87 95       	ror	r24
    27a4:	77 95       	ror	r23
    27a6:	67 95       	ror	r22
    27a8:	b7 95       	ror	r27
    27aa:	f7 95       	ror	r31
    27ac:	9e 3f       	cpi	r25, 0xFE	; 254
    27ae:	08 f0       	brcs	.+2      	; 0x27b2 <__addsf3x+0x96>
    27b0:	b3 cf       	rjmp	.-154    	; 0x2718 <__addsf3+0x1e>
    27b2:	93 95       	inc	r25
    27b4:	88 0f       	add	r24, r24
    27b6:	08 f0       	brcs	.+2      	; 0x27ba <__addsf3x+0x9e>
    27b8:	99 27       	eor	r25, r25
    27ba:	ee 0f       	add	r30, r30
    27bc:	97 95       	ror	r25
    27be:	87 95       	ror	r24
    27c0:	08 95       	ret

000027c2 <__divsf3>:
    27c2:	0c d0       	rcall	.+24     	; 0x27dc <__divsf3x>
    27c4:	eb c0       	rjmp	.+470    	; 0x299c <__fp_round>
    27c6:	e3 d0       	rcall	.+454    	; 0x298e <__fp_pscB>
    27c8:	40 f0       	brcs	.+16     	; 0x27da <__divsf3+0x18>
    27ca:	da d0       	rcall	.+436    	; 0x2980 <__fp_pscA>
    27cc:	30 f0       	brcs	.+12     	; 0x27da <__divsf3+0x18>
    27ce:	21 f4       	brne	.+8      	; 0x27d8 <__divsf3+0x16>
    27d0:	5f 3f       	cpi	r21, 0xFF	; 255
    27d2:	19 f0       	breq	.+6      	; 0x27da <__divsf3+0x18>
    27d4:	cc c0       	rjmp	.+408    	; 0x296e <__fp_inf>
    27d6:	51 11       	cpse	r21, r1
    27d8:	15 c1       	rjmp	.+554    	; 0x2a04 <__fp_szero>
    27da:	cf c0       	rjmp	.+414    	; 0x297a <__fp_nan>

000027dc <__divsf3x>:
    27dc:	f0 d0       	rcall	.+480    	; 0x29be <__fp_split3>
    27de:	98 f3       	brcs	.-26     	; 0x27c6 <__divsf3+0x4>

000027e0 <__divsf3_pse>:
    27e0:	99 23       	and	r25, r25
    27e2:	c9 f3       	breq	.-14     	; 0x27d6 <__divsf3+0x14>
    27e4:	55 23       	and	r21, r21
    27e6:	b1 f3       	breq	.-20     	; 0x27d4 <__divsf3+0x12>
    27e8:	95 1b       	sub	r25, r21
    27ea:	55 0b       	sbc	r21, r21
    27ec:	bb 27       	eor	r27, r27
    27ee:	aa 27       	eor	r26, r26
    27f0:	62 17       	cp	r22, r18
    27f2:	73 07       	cpc	r23, r19
    27f4:	84 07       	cpc	r24, r20
    27f6:	38 f0       	brcs	.+14     	; 0x2806 <__divsf3_pse+0x26>
    27f8:	9f 5f       	subi	r25, 0xFF	; 255
    27fa:	5f 4f       	sbci	r21, 0xFF	; 255
    27fc:	22 0f       	add	r18, r18
    27fe:	33 1f       	adc	r19, r19
    2800:	44 1f       	adc	r20, r20
    2802:	aa 1f       	adc	r26, r26
    2804:	a9 f3       	breq	.-22     	; 0x27f0 <__divsf3_pse+0x10>
    2806:	33 d0       	rcall	.+102    	; 0x286e <__divsf3_pse+0x8e>
    2808:	0e 2e       	mov	r0, r30
    280a:	3a f0       	brmi	.+14     	; 0x281a <__divsf3_pse+0x3a>
    280c:	e0 e8       	ldi	r30, 0x80	; 128
    280e:	30 d0       	rcall	.+96     	; 0x2870 <__divsf3_pse+0x90>
    2810:	91 50       	subi	r25, 0x01	; 1
    2812:	50 40       	sbci	r21, 0x00	; 0
    2814:	e6 95       	lsr	r30
    2816:	00 1c       	adc	r0, r0
    2818:	ca f7       	brpl	.-14     	; 0x280c <__divsf3_pse+0x2c>
    281a:	29 d0       	rcall	.+82     	; 0x286e <__divsf3_pse+0x8e>
    281c:	fe 2f       	mov	r31, r30
    281e:	27 d0       	rcall	.+78     	; 0x286e <__divsf3_pse+0x8e>
    2820:	66 0f       	add	r22, r22
    2822:	77 1f       	adc	r23, r23
    2824:	88 1f       	adc	r24, r24
    2826:	bb 1f       	adc	r27, r27
    2828:	26 17       	cp	r18, r22
    282a:	37 07       	cpc	r19, r23
    282c:	48 07       	cpc	r20, r24
    282e:	ab 07       	cpc	r26, r27
    2830:	b0 e8       	ldi	r27, 0x80	; 128
    2832:	09 f0       	breq	.+2      	; 0x2836 <__divsf3_pse+0x56>
    2834:	bb 0b       	sbc	r27, r27
    2836:	80 2d       	mov	r24, r0
    2838:	bf 01       	movw	r22, r30
    283a:	ff 27       	eor	r31, r31
    283c:	93 58       	subi	r25, 0x83	; 131
    283e:	5f 4f       	sbci	r21, 0xFF	; 255
    2840:	2a f0       	brmi	.+10     	; 0x284c <__divsf3_pse+0x6c>
    2842:	9e 3f       	cpi	r25, 0xFE	; 254
    2844:	51 05       	cpc	r21, r1
    2846:	68 f0       	brcs	.+26     	; 0x2862 <__divsf3_pse+0x82>
    2848:	92 c0       	rjmp	.+292    	; 0x296e <__fp_inf>
    284a:	dc c0       	rjmp	.+440    	; 0x2a04 <__fp_szero>
    284c:	5f 3f       	cpi	r21, 0xFF	; 255
    284e:	ec f3       	brlt	.-6      	; 0x284a <__divsf3_pse+0x6a>
    2850:	98 3e       	cpi	r25, 0xE8	; 232
    2852:	dc f3       	brlt	.-10     	; 0x284a <__divsf3_pse+0x6a>
    2854:	86 95       	lsr	r24
    2856:	77 95       	ror	r23
    2858:	67 95       	ror	r22
    285a:	b7 95       	ror	r27
    285c:	f7 95       	ror	r31
    285e:	9f 5f       	subi	r25, 0xFF	; 255
    2860:	c9 f7       	brne	.-14     	; 0x2854 <__divsf3_pse+0x74>
    2862:	88 0f       	add	r24, r24
    2864:	91 1d       	adc	r25, r1
    2866:	96 95       	lsr	r25
    2868:	87 95       	ror	r24
    286a:	97 f9       	bld	r25, 7
    286c:	08 95       	ret
    286e:	e1 e0       	ldi	r30, 0x01	; 1
    2870:	66 0f       	add	r22, r22
    2872:	77 1f       	adc	r23, r23
    2874:	88 1f       	adc	r24, r24
    2876:	bb 1f       	adc	r27, r27
    2878:	62 17       	cp	r22, r18
    287a:	73 07       	cpc	r23, r19
    287c:	84 07       	cpc	r24, r20
    287e:	ba 07       	cpc	r27, r26
    2880:	20 f0       	brcs	.+8      	; 0x288a <__divsf3_pse+0xaa>
    2882:	62 1b       	sub	r22, r18
    2884:	73 0b       	sbc	r23, r19
    2886:	84 0b       	sbc	r24, r20
    2888:	ba 0b       	sbc	r27, r26
    288a:	ee 1f       	adc	r30, r30
    288c:	88 f7       	brcc	.-30     	; 0x2870 <__divsf3_pse+0x90>
    288e:	e0 95       	com	r30
    2890:	08 95       	ret

00002892 <__fixsfsi>:
    2892:	04 d0       	rcall	.+8      	; 0x289c <__fixunssfsi>
    2894:	68 94       	set
    2896:	b1 11       	cpse	r27, r1
    2898:	b5 c0       	rjmp	.+362    	; 0x2a04 <__fp_szero>
    289a:	08 95       	ret

0000289c <__fixunssfsi>:
    289c:	98 d0       	rcall	.+304    	; 0x29ce <__fp_splitA>
    289e:	88 f0       	brcs	.+34     	; 0x28c2 <__fixunssfsi+0x26>
    28a0:	9f 57       	subi	r25, 0x7F	; 127
    28a2:	90 f0       	brcs	.+36     	; 0x28c8 <__fixunssfsi+0x2c>
    28a4:	b9 2f       	mov	r27, r25
    28a6:	99 27       	eor	r25, r25
    28a8:	b7 51       	subi	r27, 0x17	; 23
    28aa:	a0 f0       	brcs	.+40     	; 0x28d4 <__fixunssfsi+0x38>
    28ac:	d1 f0       	breq	.+52     	; 0x28e2 <__fixunssfsi+0x46>
    28ae:	66 0f       	add	r22, r22
    28b0:	77 1f       	adc	r23, r23
    28b2:	88 1f       	adc	r24, r24
    28b4:	99 1f       	adc	r25, r25
    28b6:	1a f0       	brmi	.+6      	; 0x28be <__fixunssfsi+0x22>
    28b8:	ba 95       	dec	r27
    28ba:	c9 f7       	brne	.-14     	; 0x28ae <__fixunssfsi+0x12>
    28bc:	12 c0       	rjmp	.+36     	; 0x28e2 <__fixunssfsi+0x46>
    28be:	b1 30       	cpi	r27, 0x01	; 1
    28c0:	81 f0       	breq	.+32     	; 0x28e2 <__fixunssfsi+0x46>
    28c2:	9f d0       	rcall	.+318    	; 0x2a02 <__fp_zero>
    28c4:	b1 e0       	ldi	r27, 0x01	; 1
    28c6:	08 95       	ret
    28c8:	9c c0       	rjmp	.+312    	; 0x2a02 <__fp_zero>
    28ca:	67 2f       	mov	r22, r23
    28cc:	78 2f       	mov	r23, r24
    28ce:	88 27       	eor	r24, r24
    28d0:	b8 5f       	subi	r27, 0xF8	; 248
    28d2:	39 f0       	breq	.+14     	; 0x28e2 <__fixunssfsi+0x46>
    28d4:	b9 3f       	cpi	r27, 0xF9	; 249
    28d6:	cc f3       	brlt	.-14     	; 0x28ca <__fixunssfsi+0x2e>
    28d8:	86 95       	lsr	r24
    28da:	77 95       	ror	r23
    28dc:	67 95       	ror	r22
    28de:	b3 95       	inc	r27
    28e0:	d9 f7       	brne	.-10     	; 0x28d8 <__fixunssfsi+0x3c>
    28e2:	3e f4       	brtc	.+14     	; 0x28f2 <__fixunssfsi+0x56>
    28e4:	90 95       	com	r25
    28e6:	80 95       	com	r24
    28e8:	70 95       	com	r23
    28ea:	61 95       	neg	r22
    28ec:	7f 4f       	sbci	r23, 0xFF	; 255
    28ee:	8f 4f       	sbci	r24, 0xFF	; 255
    28f0:	9f 4f       	sbci	r25, 0xFF	; 255
    28f2:	08 95       	ret

000028f4 <__floatunsisf>:
    28f4:	e8 94       	clt
    28f6:	09 c0       	rjmp	.+18     	; 0x290a <__floatsisf+0x12>

000028f8 <__floatsisf>:
    28f8:	97 fb       	bst	r25, 7
    28fa:	3e f4       	brtc	.+14     	; 0x290a <__floatsisf+0x12>
    28fc:	90 95       	com	r25
    28fe:	80 95       	com	r24
    2900:	70 95       	com	r23
    2902:	61 95       	neg	r22
    2904:	7f 4f       	sbci	r23, 0xFF	; 255
    2906:	8f 4f       	sbci	r24, 0xFF	; 255
    2908:	9f 4f       	sbci	r25, 0xFF	; 255
    290a:	99 23       	and	r25, r25
    290c:	a9 f0       	breq	.+42     	; 0x2938 <__floatsisf+0x40>
    290e:	f9 2f       	mov	r31, r25
    2910:	96 e9       	ldi	r25, 0x96	; 150
    2912:	bb 27       	eor	r27, r27
    2914:	93 95       	inc	r25
    2916:	f6 95       	lsr	r31
    2918:	87 95       	ror	r24
    291a:	77 95       	ror	r23
    291c:	67 95       	ror	r22
    291e:	b7 95       	ror	r27
    2920:	f1 11       	cpse	r31, r1
    2922:	f8 cf       	rjmp	.-16     	; 0x2914 <__floatsisf+0x1c>
    2924:	fa f4       	brpl	.+62     	; 0x2964 <__floatsisf+0x6c>
    2926:	bb 0f       	add	r27, r27
    2928:	11 f4       	brne	.+4      	; 0x292e <__floatsisf+0x36>
    292a:	60 ff       	sbrs	r22, 0
    292c:	1b c0       	rjmp	.+54     	; 0x2964 <__floatsisf+0x6c>
    292e:	6f 5f       	subi	r22, 0xFF	; 255
    2930:	7f 4f       	sbci	r23, 0xFF	; 255
    2932:	8f 4f       	sbci	r24, 0xFF	; 255
    2934:	9f 4f       	sbci	r25, 0xFF	; 255
    2936:	16 c0       	rjmp	.+44     	; 0x2964 <__floatsisf+0x6c>
    2938:	88 23       	and	r24, r24
    293a:	11 f0       	breq	.+4      	; 0x2940 <__floatsisf+0x48>
    293c:	96 e9       	ldi	r25, 0x96	; 150
    293e:	11 c0       	rjmp	.+34     	; 0x2962 <__floatsisf+0x6a>
    2940:	77 23       	and	r23, r23
    2942:	21 f0       	breq	.+8      	; 0x294c <__floatsisf+0x54>
    2944:	9e e8       	ldi	r25, 0x8E	; 142
    2946:	87 2f       	mov	r24, r23
    2948:	76 2f       	mov	r23, r22
    294a:	05 c0       	rjmp	.+10     	; 0x2956 <__floatsisf+0x5e>
    294c:	66 23       	and	r22, r22
    294e:	71 f0       	breq	.+28     	; 0x296c <__floatsisf+0x74>
    2950:	96 e8       	ldi	r25, 0x86	; 134
    2952:	86 2f       	mov	r24, r22
    2954:	70 e0       	ldi	r23, 0x00	; 0
    2956:	60 e0       	ldi	r22, 0x00	; 0
    2958:	2a f0       	brmi	.+10     	; 0x2964 <__floatsisf+0x6c>
    295a:	9a 95       	dec	r25
    295c:	66 0f       	add	r22, r22
    295e:	77 1f       	adc	r23, r23
    2960:	88 1f       	adc	r24, r24
    2962:	da f7       	brpl	.-10     	; 0x295a <__floatsisf+0x62>
    2964:	88 0f       	add	r24, r24
    2966:	96 95       	lsr	r25
    2968:	87 95       	ror	r24
    296a:	97 f9       	bld	r25, 7
    296c:	08 95       	ret

0000296e <__fp_inf>:
    296e:	97 f9       	bld	r25, 7
    2970:	9f 67       	ori	r25, 0x7F	; 127
    2972:	80 e8       	ldi	r24, 0x80	; 128
    2974:	70 e0       	ldi	r23, 0x00	; 0
    2976:	60 e0       	ldi	r22, 0x00	; 0
    2978:	08 95       	ret

0000297a <__fp_nan>:
    297a:	9f ef       	ldi	r25, 0xFF	; 255
    297c:	80 ec       	ldi	r24, 0xC0	; 192
    297e:	08 95       	ret

00002980 <__fp_pscA>:
    2980:	00 24       	eor	r0, r0
    2982:	0a 94       	dec	r0
    2984:	16 16       	cp	r1, r22
    2986:	17 06       	cpc	r1, r23
    2988:	18 06       	cpc	r1, r24
    298a:	09 06       	cpc	r0, r25
    298c:	08 95       	ret

0000298e <__fp_pscB>:
    298e:	00 24       	eor	r0, r0
    2990:	0a 94       	dec	r0
    2992:	12 16       	cp	r1, r18
    2994:	13 06       	cpc	r1, r19
    2996:	14 06       	cpc	r1, r20
    2998:	05 06       	cpc	r0, r21
    299a:	08 95       	ret

0000299c <__fp_round>:
    299c:	09 2e       	mov	r0, r25
    299e:	03 94       	inc	r0
    29a0:	00 0c       	add	r0, r0
    29a2:	11 f4       	brne	.+4      	; 0x29a8 <__fp_round+0xc>
    29a4:	88 23       	and	r24, r24
    29a6:	52 f0       	brmi	.+20     	; 0x29bc <__fp_round+0x20>
    29a8:	bb 0f       	add	r27, r27
    29aa:	40 f4       	brcc	.+16     	; 0x29bc <__fp_round+0x20>
    29ac:	bf 2b       	or	r27, r31
    29ae:	11 f4       	brne	.+4      	; 0x29b4 <__fp_round+0x18>
    29b0:	60 ff       	sbrs	r22, 0
    29b2:	04 c0       	rjmp	.+8      	; 0x29bc <__fp_round+0x20>
    29b4:	6f 5f       	subi	r22, 0xFF	; 255
    29b6:	7f 4f       	sbci	r23, 0xFF	; 255
    29b8:	8f 4f       	sbci	r24, 0xFF	; 255
    29ba:	9f 4f       	sbci	r25, 0xFF	; 255
    29bc:	08 95       	ret

000029be <__fp_split3>:
    29be:	57 fd       	sbrc	r21, 7
    29c0:	90 58       	subi	r25, 0x80	; 128
    29c2:	44 0f       	add	r20, r20
    29c4:	55 1f       	adc	r21, r21
    29c6:	59 f0       	breq	.+22     	; 0x29de <__fp_splitA+0x10>
    29c8:	5f 3f       	cpi	r21, 0xFF	; 255
    29ca:	71 f0       	breq	.+28     	; 0x29e8 <__fp_splitA+0x1a>
    29cc:	47 95       	ror	r20

000029ce <__fp_splitA>:
    29ce:	88 0f       	add	r24, r24
    29d0:	97 fb       	bst	r25, 7
    29d2:	99 1f       	adc	r25, r25
    29d4:	61 f0       	breq	.+24     	; 0x29ee <__fp_splitA+0x20>
    29d6:	9f 3f       	cpi	r25, 0xFF	; 255
    29d8:	79 f0       	breq	.+30     	; 0x29f8 <__fp_splitA+0x2a>
    29da:	87 95       	ror	r24
    29dc:	08 95       	ret
    29de:	12 16       	cp	r1, r18
    29e0:	13 06       	cpc	r1, r19
    29e2:	14 06       	cpc	r1, r20
    29e4:	55 1f       	adc	r21, r21
    29e6:	f2 cf       	rjmp	.-28     	; 0x29cc <__fp_split3+0xe>
    29e8:	46 95       	lsr	r20
    29ea:	f1 df       	rcall	.-30     	; 0x29ce <__fp_splitA>
    29ec:	08 c0       	rjmp	.+16     	; 0x29fe <__fp_splitA+0x30>
    29ee:	16 16       	cp	r1, r22
    29f0:	17 06       	cpc	r1, r23
    29f2:	18 06       	cpc	r1, r24
    29f4:	99 1f       	adc	r25, r25
    29f6:	f1 cf       	rjmp	.-30     	; 0x29da <__fp_splitA+0xc>
    29f8:	86 95       	lsr	r24
    29fa:	71 05       	cpc	r23, r1
    29fc:	61 05       	cpc	r22, r1
    29fe:	08 94       	sec
    2a00:	08 95       	ret

00002a02 <__fp_zero>:
    2a02:	e8 94       	clt

00002a04 <__fp_szero>:
    2a04:	bb 27       	eor	r27, r27
    2a06:	66 27       	eor	r22, r22
    2a08:	77 27       	eor	r23, r23
    2a0a:	cb 01       	movw	r24, r22
    2a0c:	97 f9       	bld	r25, 7
    2a0e:	08 95       	ret

00002a10 <__mulsf3>:
    2a10:	0b d0       	rcall	.+22     	; 0x2a28 <__mulsf3x>
    2a12:	c4 cf       	rjmp	.-120    	; 0x299c <__fp_round>
    2a14:	b5 df       	rcall	.-150    	; 0x2980 <__fp_pscA>
    2a16:	28 f0       	brcs	.+10     	; 0x2a22 <__mulsf3+0x12>
    2a18:	ba df       	rcall	.-140    	; 0x298e <__fp_pscB>
    2a1a:	18 f0       	brcs	.+6      	; 0x2a22 <__mulsf3+0x12>
    2a1c:	95 23       	and	r25, r21
    2a1e:	09 f0       	breq	.+2      	; 0x2a22 <__mulsf3+0x12>
    2a20:	a6 cf       	rjmp	.-180    	; 0x296e <__fp_inf>
    2a22:	ab cf       	rjmp	.-170    	; 0x297a <__fp_nan>
    2a24:	11 24       	eor	r1, r1
    2a26:	ee cf       	rjmp	.-36     	; 0x2a04 <__fp_szero>

00002a28 <__mulsf3x>:
    2a28:	ca df       	rcall	.-108    	; 0x29be <__fp_split3>
    2a2a:	a0 f3       	brcs	.-24     	; 0x2a14 <__mulsf3+0x4>

00002a2c <__mulsf3_pse>:
    2a2c:	95 9f       	mul	r25, r21
    2a2e:	d1 f3       	breq	.-12     	; 0x2a24 <__mulsf3+0x14>
    2a30:	95 0f       	add	r25, r21
    2a32:	50 e0       	ldi	r21, 0x00	; 0
    2a34:	55 1f       	adc	r21, r21
    2a36:	62 9f       	mul	r22, r18
    2a38:	f0 01       	movw	r30, r0
    2a3a:	72 9f       	mul	r23, r18
    2a3c:	bb 27       	eor	r27, r27
    2a3e:	f0 0d       	add	r31, r0
    2a40:	b1 1d       	adc	r27, r1
    2a42:	63 9f       	mul	r22, r19
    2a44:	aa 27       	eor	r26, r26
    2a46:	f0 0d       	add	r31, r0
    2a48:	b1 1d       	adc	r27, r1
    2a4a:	aa 1f       	adc	r26, r26
    2a4c:	64 9f       	mul	r22, r20
    2a4e:	66 27       	eor	r22, r22
    2a50:	b0 0d       	add	r27, r0
    2a52:	a1 1d       	adc	r26, r1
    2a54:	66 1f       	adc	r22, r22
    2a56:	82 9f       	mul	r24, r18
    2a58:	22 27       	eor	r18, r18
    2a5a:	b0 0d       	add	r27, r0
    2a5c:	a1 1d       	adc	r26, r1
    2a5e:	62 1f       	adc	r22, r18
    2a60:	73 9f       	mul	r23, r19
    2a62:	b0 0d       	add	r27, r0
    2a64:	a1 1d       	adc	r26, r1
    2a66:	62 1f       	adc	r22, r18
    2a68:	83 9f       	mul	r24, r19
    2a6a:	a0 0d       	add	r26, r0
    2a6c:	61 1d       	adc	r22, r1
    2a6e:	22 1f       	adc	r18, r18
    2a70:	74 9f       	mul	r23, r20
    2a72:	33 27       	eor	r19, r19
    2a74:	a0 0d       	add	r26, r0
    2a76:	61 1d       	adc	r22, r1
    2a78:	23 1f       	adc	r18, r19
    2a7a:	84 9f       	mul	r24, r20
    2a7c:	60 0d       	add	r22, r0
    2a7e:	21 1d       	adc	r18, r1
    2a80:	82 2f       	mov	r24, r18
    2a82:	76 2f       	mov	r23, r22
    2a84:	6a 2f       	mov	r22, r26
    2a86:	11 24       	eor	r1, r1
    2a88:	9f 57       	subi	r25, 0x7F	; 127
    2a8a:	50 40       	sbci	r21, 0x00	; 0
    2a8c:	8a f0       	brmi	.+34     	; 0x2ab0 <__mulsf3_pse+0x84>
    2a8e:	e1 f0       	breq	.+56     	; 0x2ac8 <__mulsf3_pse+0x9c>
    2a90:	88 23       	and	r24, r24
    2a92:	4a f0       	brmi	.+18     	; 0x2aa6 <__mulsf3_pse+0x7a>
    2a94:	ee 0f       	add	r30, r30
    2a96:	ff 1f       	adc	r31, r31
    2a98:	bb 1f       	adc	r27, r27
    2a9a:	66 1f       	adc	r22, r22
    2a9c:	77 1f       	adc	r23, r23
    2a9e:	88 1f       	adc	r24, r24
    2aa0:	91 50       	subi	r25, 0x01	; 1
    2aa2:	50 40       	sbci	r21, 0x00	; 0
    2aa4:	a9 f7       	brne	.-22     	; 0x2a90 <__mulsf3_pse+0x64>
    2aa6:	9e 3f       	cpi	r25, 0xFE	; 254
    2aa8:	51 05       	cpc	r21, r1
    2aaa:	70 f0       	brcs	.+28     	; 0x2ac8 <__mulsf3_pse+0x9c>
    2aac:	60 cf       	rjmp	.-320    	; 0x296e <__fp_inf>
    2aae:	aa cf       	rjmp	.-172    	; 0x2a04 <__fp_szero>
    2ab0:	5f 3f       	cpi	r21, 0xFF	; 255
    2ab2:	ec f3       	brlt	.-6      	; 0x2aae <__mulsf3_pse+0x82>
    2ab4:	98 3e       	cpi	r25, 0xE8	; 232
    2ab6:	dc f3       	brlt	.-10     	; 0x2aae <__mulsf3_pse+0x82>
    2ab8:	86 95       	lsr	r24
    2aba:	77 95       	ror	r23
    2abc:	67 95       	ror	r22
    2abe:	b7 95       	ror	r27
    2ac0:	f7 95       	ror	r31
    2ac2:	e7 95       	ror	r30
    2ac4:	9f 5f       	subi	r25, 0xFF	; 255
    2ac6:	c1 f7       	brne	.-16     	; 0x2ab8 <__mulsf3_pse+0x8c>
    2ac8:	fe 2b       	or	r31, r30
    2aca:	88 0f       	add	r24, r24
    2acc:	91 1d       	adc	r25, r1
    2ace:	96 95       	lsr	r25
    2ad0:	87 95       	ror	r24
    2ad2:	97 f9       	bld	r25, 7
    2ad4:	08 95       	ret

00002ad6 <pow>:
    2ad6:	fa 01       	movw	r30, r20
    2ad8:	ee 0f       	add	r30, r30
    2ada:	ff 1f       	adc	r31, r31
    2adc:	30 96       	adiw	r30, 0x00	; 0
    2ade:	21 05       	cpc	r18, r1
    2ae0:	31 05       	cpc	r19, r1
    2ae2:	99 f1       	breq	.+102    	; 0x2b4a <pow+0x74>
    2ae4:	61 15       	cp	r22, r1
    2ae6:	71 05       	cpc	r23, r1
    2ae8:	61 f4       	brne	.+24     	; 0x2b02 <pow+0x2c>
    2aea:	80 38       	cpi	r24, 0x80	; 128
    2aec:	bf e3       	ldi	r27, 0x3F	; 63
    2aee:	9b 07       	cpc	r25, r27
    2af0:	49 f1       	breq	.+82     	; 0x2b44 <pow+0x6e>
    2af2:	68 94       	set
    2af4:	90 38       	cpi	r25, 0x80	; 128
    2af6:	81 05       	cpc	r24, r1
    2af8:	61 f0       	breq	.+24     	; 0x2b12 <pow+0x3c>
    2afa:	80 38       	cpi	r24, 0x80	; 128
    2afc:	bf ef       	ldi	r27, 0xFF	; 255
    2afe:	9b 07       	cpc	r25, r27
    2b00:	41 f0       	breq	.+16     	; 0x2b12 <pow+0x3c>
    2b02:	99 23       	and	r25, r25
    2b04:	42 f5       	brpl	.+80     	; 0x2b56 <pow+0x80>
    2b06:	ff 3f       	cpi	r31, 0xFF	; 255
    2b08:	e1 05       	cpc	r30, r1
    2b0a:	31 05       	cpc	r19, r1
    2b0c:	21 05       	cpc	r18, r1
    2b0e:	11 f1       	breq	.+68     	; 0x2b54 <pow+0x7e>
    2b10:	e8 94       	clt
    2b12:	08 94       	sec
    2b14:	e7 95       	ror	r30
    2b16:	d9 01       	movw	r26, r18
    2b18:	aa 23       	and	r26, r26
    2b1a:	29 f4       	brne	.+10     	; 0x2b26 <pow+0x50>
    2b1c:	ab 2f       	mov	r26, r27
    2b1e:	be 2f       	mov	r27, r30
    2b20:	f8 5f       	subi	r31, 0xF8	; 248
    2b22:	d0 f3       	brcs	.-12     	; 0x2b18 <pow+0x42>
    2b24:	10 c0       	rjmp	.+32     	; 0x2b46 <pow+0x70>
    2b26:	ff 5f       	subi	r31, 0xFF	; 255
    2b28:	70 f4       	brcc	.+28     	; 0x2b46 <pow+0x70>
    2b2a:	a6 95       	lsr	r26
    2b2c:	e0 f7       	brcc	.-8      	; 0x2b26 <pow+0x50>
    2b2e:	f7 39       	cpi	r31, 0x97	; 151
    2b30:	50 f0       	brcs	.+20     	; 0x2b46 <pow+0x70>
    2b32:	19 f0       	breq	.+6      	; 0x2b3a <pow+0x64>
    2b34:	ff 3a       	cpi	r31, 0xAF	; 175
    2b36:	38 f4       	brcc	.+14     	; 0x2b46 <pow+0x70>
    2b38:	9f 77       	andi	r25, 0x7F	; 127
    2b3a:	9f 93       	push	r25
    2b3c:	0c d0       	rcall	.+24     	; 0x2b56 <pow+0x80>
    2b3e:	0f 90       	pop	r0
    2b40:	07 fc       	sbrc	r0, 7
    2b42:	90 58       	subi	r25, 0x80	; 128
    2b44:	08 95       	ret
    2b46:	3e f0       	brts	.+14     	; 0x2b56 <pow+0x80>
    2b48:	18 cf       	rjmp	.-464    	; 0x297a <__fp_nan>
    2b4a:	60 e0       	ldi	r22, 0x00	; 0
    2b4c:	70 e0       	ldi	r23, 0x00	; 0
    2b4e:	80 e8       	ldi	r24, 0x80	; 128
    2b50:	9f e3       	ldi	r25, 0x3F	; 63
    2b52:	08 95       	ret
    2b54:	4f e7       	ldi	r20, 0x7F	; 127
    2b56:	9f 77       	andi	r25, 0x7F	; 127
    2b58:	5f 93       	push	r21
    2b5a:	4f 93       	push	r20
    2b5c:	3f 93       	push	r19
    2b5e:	2f 93       	push	r18
    2b60:	9e d0       	rcall	.+316    	; 0x2c9e <log>
    2b62:	2f 91       	pop	r18
    2b64:	3f 91       	pop	r19
    2b66:	4f 91       	pop	r20
    2b68:	5f 91       	pop	r21
    2b6a:	52 df       	rcall	.-348    	; 0x2a10 <__mulsf3>
    2b6c:	05 c0       	rjmp	.+10     	; 0x2b78 <exp>
    2b6e:	19 f4       	brne	.+6      	; 0x2b76 <pow+0xa0>
    2b70:	0e f0       	brts	.+2      	; 0x2b74 <pow+0x9e>
    2b72:	fd ce       	rjmp	.-518    	; 0x296e <__fp_inf>
    2b74:	46 cf       	rjmp	.-372    	; 0x2a02 <__fp_zero>
    2b76:	01 cf       	rjmp	.-510    	; 0x297a <__fp_nan>

00002b78 <exp>:
    2b78:	2a df       	rcall	.-428    	; 0x29ce <__fp_splitA>
    2b7a:	c8 f3       	brcs	.-14     	; 0x2b6e <pow+0x98>
    2b7c:	96 38       	cpi	r25, 0x86	; 134
    2b7e:	c0 f7       	brcc	.-16     	; 0x2b70 <pow+0x9a>
    2b80:	07 f8       	bld	r0, 7
    2b82:	0f 92       	push	r0
    2b84:	e8 94       	clt
    2b86:	2b e3       	ldi	r18, 0x3B	; 59
    2b88:	3a ea       	ldi	r19, 0xAA	; 170
    2b8a:	48 eb       	ldi	r20, 0xB8	; 184
    2b8c:	5f e7       	ldi	r21, 0x7F	; 127
    2b8e:	4e df       	rcall	.-356    	; 0x2a2c <__mulsf3_pse>
    2b90:	0f 92       	push	r0
    2b92:	0f 92       	push	r0
    2b94:	0f 92       	push	r0
    2b96:	4d b7       	in	r20, 0x3d	; 61
    2b98:	5e b7       	in	r21, 0x3e	; 62
    2b9a:	0f 92       	push	r0
    2b9c:	c0 d0       	rcall	.+384    	; 0x2d1e <modf>
    2b9e:	e4 ee       	ldi	r30, 0xE4	; 228
    2ba0:	f0 e0       	ldi	r31, 0x00	; 0
    2ba2:	16 d0       	rcall	.+44     	; 0x2bd0 <__fp_powser>
    2ba4:	4f 91       	pop	r20
    2ba6:	5f 91       	pop	r21
    2ba8:	ef 91       	pop	r30
    2baa:	ff 91       	pop	r31
    2bac:	e5 95       	asr	r30
    2bae:	ee 1f       	adc	r30, r30
    2bb0:	ff 1f       	adc	r31, r31
    2bb2:	49 f0       	breq	.+18     	; 0x2bc6 <exp+0x4e>
    2bb4:	fe 57       	subi	r31, 0x7E	; 126
    2bb6:	e0 68       	ori	r30, 0x80	; 128
    2bb8:	44 27       	eor	r20, r20
    2bba:	ee 0f       	add	r30, r30
    2bbc:	44 1f       	adc	r20, r20
    2bbe:	fa 95       	dec	r31
    2bc0:	e1 f7       	brne	.-8      	; 0x2bba <exp+0x42>
    2bc2:	41 95       	neg	r20
    2bc4:	55 0b       	sbc	r21, r21
    2bc6:	32 d0       	rcall	.+100    	; 0x2c2c <ldexp>
    2bc8:	0f 90       	pop	r0
    2bca:	07 fe       	sbrs	r0, 7
    2bcc:	26 c0       	rjmp	.+76     	; 0x2c1a <inverse>
    2bce:	08 95       	ret

00002bd0 <__fp_powser>:
    2bd0:	df 93       	push	r29
    2bd2:	cf 93       	push	r28
    2bd4:	1f 93       	push	r17
    2bd6:	0f 93       	push	r16
    2bd8:	ff 92       	push	r15
    2bda:	ef 92       	push	r14
    2bdc:	df 92       	push	r13
    2bde:	7b 01       	movw	r14, r22
    2be0:	8c 01       	movw	r16, r24
    2be2:	68 94       	set
    2be4:	05 c0       	rjmp	.+10     	; 0x2bf0 <__fp_powser+0x20>
    2be6:	da 2e       	mov	r13, r26
    2be8:	ef 01       	movw	r28, r30
    2bea:	1e df       	rcall	.-452    	; 0x2a28 <__mulsf3x>
    2bec:	fe 01       	movw	r30, r28
    2bee:	e8 94       	clt
    2bf0:	a5 91       	lpm	r26, Z+
    2bf2:	25 91       	lpm	r18, Z+
    2bf4:	35 91       	lpm	r19, Z+
    2bf6:	45 91       	lpm	r20, Z+
    2bf8:	55 91       	lpm	r21, Z+
    2bfa:	ae f3       	brts	.-22     	; 0x2be6 <__fp_powser+0x16>
    2bfc:	ef 01       	movw	r28, r30
    2bfe:	8e dd       	rcall	.-1252   	; 0x271c <__addsf3x>
    2c00:	fe 01       	movw	r30, r28
    2c02:	97 01       	movw	r18, r14
    2c04:	a8 01       	movw	r20, r16
    2c06:	da 94       	dec	r13
    2c08:	79 f7       	brne	.-34     	; 0x2be8 <__fp_powser+0x18>
    2c0a:	df 90       	pop	r13
    2c0c:	ef 90       	pop	r14
    2c0e:	ff 90       	pop	r15
    2c10:	0f 91       	pop	r16
    2c12:	1f 91       	pop	r17
    2c14:	cf 91       	pop	r28
    2c16:	df 91       	pop	r29
    2c18:	08 95       	ret

00002c1a <inverse>:
    2c1a:	9b 01       	movw	r18, r22
    2c1c:	ac 01       	movw	r20, r24
    2c1e:	60 e0       	ldi	r22, 0x00	; 0
    2c20:	70 e0       	ldi	r23, 0x00	; 0
    2c22:	80 e8       	ldi	r24, 0x80	; 128
    2c24:	9f e3       	ldi	r25, 0x3F	; 63
    2c26:	cd cd       	rjmp	.-1126   	; 0x27c2 <__divsf3>
    2c28:	a2 ce       	rjmp	.-700    	; 0x296e <__fp_inf>
    2c2a:	ac c0       	rjmp	.+344    	; 0x2d84 <__fp_mpack>

00002c2c <ldexp>:
    2c2c:	d0 de       	rcall	.-608    	; 0x29ce <__fp_splitA>
    2c2e:	e8 f3       	brcs	.-6      	; 0x2c2a <inverse+0x10>
    2c30:	99 23       	and	r25, r25
    2c32:	d9 f3       	breq	.-10     	; 0x2c2a <inverse+0x10>
    2c34:	94 0f       	add	r25, r20
    2c36:	51 1d       	adc	r21, r1
    2c38:	bb f3       	brvs	.-18     	; 0x2c28 <inverse+0xe>
    2c3a:	91 50       	subi	r25, 0x01	; 1
    2c3c:	50 40       	sbci	r21, 0x00	; 0
    2c3e:	94 f0       	brlt	.+36     	; 0x2c64 <ldexp+0x38>
    2c40:	59 f0       	breq	.+22     	; 0x2c58 <ldexp+0x2c>
    2c42:	88 23       	and	r24, r24
    2c44:	32 f0       	brmi	.+12     	; 0x2c52 <ldexp+0x26>
    2c46:	66 0f       	add	r22, r22
    2c48:	77 1f       	adc	r23, r23
    2c4a:	88 1f       	adc	r24, r24
    2c4c:	91 50       	subi	r25, 0x01	; 1
    2c4e:	50 40       	sbci	r21, 0x00	; 0
    2c50:	c1 f7       	brne	.-16     	; 0x2c42 <ldexp+0x16>
    2c52:	9e 3f       	cpi	r25, 0xFE	; 254
    2c54:	51 05       	cpc	r21, r1
    2c56:	44 f7       	brge	.-48     	; 0x2c28 <inverse+0xe>
    2c58:	88 0f       	add	r24, r24
    2c5a:	91 1d       	adc	r25, r1
    2c5c:	96 95       	lsr	r25
    2c5e:	87 95       	ror	r24
    2c60:	97 f9       	bld	r25, 7
    2c62:	08 95       	ret
    2c64:	5f 3f       	cpi	r21, 0xFF	; 255
    2c66:	ac f0       	brlt	.+42     	; 0x2c92 <ldexp+0x66>
    2c68:	98 3e       	cpi	r25, 0xE8	; 232
    2c6a:	9c f0       	brlt	.+38     	; 0x2c92 <ldexp+0x66>
    2c6c:	bb 27       	eor	r27, r27
    2c6e:	86 95       	lsr	r24
    2c70:	77 95       	ror	r23
    2c72:	67 95       	ror	r22
    2c74:	b7 95       	ror	r27
    2c76:	08 f4       	brcc	.+2      	; 0x2c7a <ldexp+0x4e>
    2c78:	b1 60       	ori	r27, 0x01	; 1
    2c7a:	93 95       	inc	r25
    2c7c:	c1 f7       	brne	.-16     	; 0x2c6e <ldexp+0x42>
    2c7e:	bb 0f       	add	r27, r27
    2c80:	58 f7       	brcc	.-42     	; 0x2c58 <ldexp+0x2c>
    2c82:	11 f4       	brne	.+4      	; 0x2c88 <ldexp+0x5c>
    2c84:	60 ff       	sbrs	r22, 0
    2c86:	e8 cf       	rjmp	.-48     	; 0x2c58 <ldexp+0x2c>
    2c88:	6f 5f       	subi	r22, 0xFF	; 255
    2c8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c8c:	8f 4f       	sbci	r24, 0xFF	; 255
    2c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    2c90:	e3 cf       	rjmp	.-58     	; 0x2c58 <ldexp+0x2c>
    2c92:	b8 ce       	rjmp	.-656    	; 0x2a04 <__fp_szero>
    2c94:	0e f0       	brts	.+2      	; 0x2c98 <ldexp+0x6c>
    2c96:	76 c0       	rjmp	.+236    	; 0x2d84 <__fp_mpack>
    2c98:	70 ce       	rjmp	.-800    	; 0x297a <__fp_nan>
    2c9a:	68 94       	set
    2c9c:	68 ce       	rjmp	.-816    	; 0x296e <__fp_inf>

00002c9e <log>:
    2c9e:	97 de       	rcall	.-722    	; 0x29ce <__fp_splitA>
    2ca0:	c8 f3       	brcs	.-14     	; 0x2c94 <ldexp+0x68>
    2ca2:	99 23       	and	r25, r25
    2ca4:	d1 f3       	breq	.-12     	; 0x2c9a <ldexp+0x6e>
    2ca6:	c6 f3       	brts	.-16     	; 0x2c98 <ldexp+0x6c>
    2ca8:	df 93       	push	r29
    2caa:	cf 93       	push	r28
    2cac:	1f 93       	push	r17
    2cae:	0f 93       	push	r16
    2cb0:	ff 92       	push	r15
    2cb2:	c9 2f       	mov	r28, r25
    2cb4:	dd 27       	eor	r29, r29
    2cb6:	88 23       	and	r24, r24
    2cb8:	2a f0       	brmi	.+10     	; 0x2cc4 <log+0x26>
    2cba:	21 97       	sbiw	r28, 0x01	; 1
    2cbc:	66 0f       	add	r22, r22
    2cbe:	77 1f       	adc	r23, r23
    2cc0:	88 1f       	adc	r24, r24
    2cc2:	da f7       	brpl	.-10     	; 0x2cba <log+0x1c>
    2cc4:	20 e0       	ldi	r18, 0x00	; 0
    2cc6:	30 e0       	ldi	r19, 0x00	; 0
    2cc8:	40 e8       	ldi	r20, 0x80	; 128
    2cca:	5f eb       	ldi	r21, 0xBF	; 191
    2ccc:	9f e3       	ldi	r25, 0x3F	; 63
    2cce:	88 39       	cpi	r24, 0x98	; 152
    2cd0:	20 f0       	brcs	.+8      	; 0x2cda <log+0x3c>
    2cd2:	80 3e       	cpi	r24, 0xE0	; 224
    2cd4:	30 f0       	brcs	.+12     	; 0x2ce2 <log+0x44>
    2cd6:	21 96       	adiw	r28, 0x01	; 1
    2cd8:	8f 77       	andi	r24, 0x7F	; 127
    2cda:	0f dd       	rcall	.-1506   	; 0x26fa <__addsf3>
    2cdc:	ec e0       	ldi	r30, 0x0C	; 12
    2cde:	f1 e0       	ldi	r31, 0x01	; 1
    2ce0:	03 c0       	rjmp	.+6      	; 0x2ce8 <log+0x4a>
    2ce2:	0b dd       	rcall	.-1514   	; 0x26fa <__addsf3>
    2ce4:	e9 e3       	ldi	r30, 0x39	; 57
    2ce6:	f1 e0       	ldi	r31, 0x01	; 1
    2ce8:	73 df       	rcall	.-282    	; 0x2bd0 <__fp_powser>
    2cea:	8b 01       	movw	r16, r22
    2cec:	be 01       	movw	r22, r28
    2cee:	ec 01       	movw	r28, r24
    2cf0:	fb 2e       	mov	r15, r27
    2cf2:	6f 57       	subi	r22, 0x7F	; 127
    2cf4:	71 09       	sbc	r23, r1
    2cf6:	75 95       	asr	r23
    2cf8:	77 1f       	adc	r23, r23
    2cfa:	88 0b       	sbc	r24, r24
    2cfc:	99 0b       	sbc	r25, r25
    2cfe:	fc dd       	rcall	.-1032   	; 0x28f8 <__floatsisf>
    2d00:	28 e1       	ldi	r18, 0x18	; 24
    2d02:	32 e7       	ldi	r19, 0x72	; 114
    2d04:	41 e3       	ldi	r20, 0x31	; 49
    2d06:	5f e3       	ldi	r21, 0x3F	; 63
    2d08:	8f de       	rcall	.-738    	; 0x2a28 <__mulsf3x>
    2d0a:	af 2d       	mov	r26, r15
    2d0c:	98 01       	movw	r18, r16
    2d0e:	ae 01       	movw	r20, r28
    2d10:	ff 90       	pop	r15
    2d12:	0f 91       	pop	r16
    2d14:	1f 91       	pop	r17
    2d16:	cf 91       	pop	r28
    2d18:	df 91       	pop	r29
    2d1a:	00 dd       	rcall	.-1536   	; 0x271c <__addsf3x>
    2d1c:	3f ce       	rjmp	.-898    	; 0x299c <__fp_round>

00002d1e <modf>:
    2d1e:	fa 01       	movw	r30, r20
    2d20:	dc 01       	movw	r26, r24
    2d22:	aa 0f       	add	r26, r26
    2d24:	bb 1f       	adc	r27, r27
    2d26:	9b 01       	movw	r18, r22
    2d28:	ac 01       	movw	r20, r24
    2d2a:	bf 57       	subi	r27, 0x7F	; 127
    2d2c:	28 f4       	brcc	.+10     	; 0x2d38 <modf+0x1a>
    2d2e:	22 27       	eor	r18, r18
    2d30:	33 27       	eor	r19, r19
    2d32:	44 27       	eor	r20, r20
    2d34:	50 78       	andi	r21, 0x80	; 128
    2d36:	1f c0       	rjmp	.+62     	; 0x2d76 <modf+0x58>
    2d38:	b7 51       	subi	r27, 0x17	; 23
    2d3a:	88 f4       	brcc	.+34     	; 0x2d5e <modf+0x40>
    2d3c:	ab 2f       	mov	r26, r27
    2d3e:	00 24       	eor	r0, r0
    2d40:	46 95       	lsr	r20
    2d42:	37 95       	ror	r19
    2d44:	27 95       	ror	r18
    2d46:	01 1c       	adc	r0, r1
    2d48:	a3 95       	inc	r26
    2d4a:	d2 f3       	brmi	.-12     	; 0x2d40 <modf+0x22>
    2d4c:	00 20       	and	r0, r0
    2d4e:	69 f0       	breq	.+26     	; 0x2d6a <modf+0x4c>
    2d50:	22 0f       	add	r18, r18
    2d52:	33 1f       	adc	r19, r19
    2d54:	44 1f       	adc	r20, r20
    2d56:	b3 95       	inc	r27
    2d58:	da f3       	brmi	.-10     	; 0x2d50 <modf+0x32>
    2d5a:	0d d0       	rcall	.+26     	; 0x2d76 <modf+0x58>
    2d5c:	cd cc       	rjmp	.-1638   	; 0x26f8 <__subsf3>
    2d5e:	61 30       	cpi	r22, 0x01	; 1
    2d60:	71 05       	cpc	r23, r1
    2d62:	a0 e8       	ldi	r26, 0x80	; 128
    2d64:	8a 07       	cpc	r24, r26
    2d66:	b9 46       	sbci	r27, 0x69	; 105
    2d68:	30 f4       	brcc	.+12     	; 0x2d76 <modf+0x58>
    2d6a:	9b 01       	movw	r18, r22
    2d6c:	ac 01       	movw	r20, r24
    2d6e:	66 27       	eor	r22, r22
    2d70:	77 27       	eor	r23, r23
    2d72:	88 27       	eor	r24, r24
    2d74:	90 78       	andi	r25, 0x80	; 128
    2d76:	30 96       	adiw	r30, 0x00	; 0
    2d78:	21 f0       	breq	.+8      	; 0x2d82 <modf+0x64>
    2d7a:	20 83       	st	Z, r18
    2d7c:	31 83       	std	Z+1, r19	; 0x01
    2d7e:	42 83       	std	Z+2, r20	; 0x02
    2d80:	53 83       	std	Z+3, r21	; 0x03
    2d82:	08 95       	ret

00002d84 <__fp_mpack>:
    2d84:	9f 3f       	cpi	r25, 0xFF	; 255
    2d86:	31 f0       	breq	.+12     	; 0x2d94 <__fp_mpack_finite+0xc>

00002d88 <__fp_mpack_finite>:
    2d88:	91 50       	subi	r25, 0x01	; 1
    2d8a:	20 f4       	brcc	.+8      	; 0x2d94 <__fp_mpack_finite+0xc>
    2d8c:	87 95       	ror	r24
    2d8e:	77 95       	ror	r23
    2d90:	67 95       	ror	r22
    2d92:	b7 95       	ror	r27
    2d94:	88 0f       	add	r24, r24
    2d96:	91 1d       	adc	r25, r1
    2d98:	96 95       	lsr	r25
    2d9a:	87 95       	ror	r24
    2d9c:	97 f9       	bld	r25, 7
    2d9e:	08 95       	ret

00002da0 <__udivmodqi4>:
    2da0:	99 1b       	sub	r25, r25
    2da2:	79 e0       	ldi	r23, 0x09	; 9
    2da4:	04 c0       	rjmp	.+8      	; 0x2dae <__udivmodqi4_ep>

00002da6 <__udivmodqi4_loop>:
    2da6:	99 1f       	adc	r25, r25
    2da8:	96 17       	cp	r25, r22
    2daa:	08 f0       	brcs	.+2      	; 0x2dae <__udivmodqi4_ep>
    2dac:	96 1b       	sub	r25, r22

00002dae <__udivmodqi4_ep>:
    2dae:	88 1f       	adc	r24, r24
    2db0:	7a 95       	dec	r23
    2db2:	c9 f7       	brne	.-14     	; 0x2da6 <__udivmodqi4_loop>
    2db4:	80 95       	com	r24
    2db6:	08 95       	ret

00002db8 <__udivmodhi4>:
    2db8:	aa 1b       	sub	r26, r26
    2dba:	bb 1b       	sub	r27, r27
    2dbc:	51 e1       	ldi	r21, 0x11	; 17
    2dbe:	07 c0       	rjmp	.+14     	; 0x2dce <__udivmodhi4_ep>

00002dc0 <__udivmodhi4_loop>:
    2dc0:	aa 1f       	adc	r26, r26
    2dc2:	bb 1f       	adc	r27, r27
    2dc4:	a6 17       	cp	r26, r22
    2dc6:	b7 07       	cpc	r27, r23
    2dc8:	10 f0       	brcs	.+4      	; 0x2dce <__udivmodhi4_ep>
    2dca:	a6 1b       	sub	r26, r22
    2dcc:	b7 0b       	sbc	r27, r23

00002dce <__udivmodhi4_ep>:
    2dce:	88 1f       	adc	r24, r24
    2dd0:	99 1f       	adc	r25, r25
    2dd2:	5a 95       	dec	r21
    2dd4:	a9 f7       	brne	.-22     	; 0x2dc0 <__udivmodhi4_loop>
    2dd6:	80 95       	com	r24
    2dd8:	90 95       	com	r25
    2dda:	bc 01       	movw	r22, r24
    2ddc:	cd 01       	movw	r24, r26
    2dde:	08 95       	ret

00002de0 <__divmodhi4>:
    2de0:	97 fb       	bst	r25, 7
    2de2:	09 2e       	mov	r0, r25
    2de4:	07 26       	eor	r0, r23
    2de6:	0a d0       	rcall	.+20     	; 0x2dfc <__divmodhi4_neg1>
    2de8:	77 fd       	sbrc	r23, 7
    2dea:	04 d0       	rcall	.+8      	; 0x2df4 <__divmodhi4_neg2>
    2dec:	e5 df       	rcall	.-54     	; 0x2db8 <__udivmodhi4>
    2dee:	06 d0       	rcall	.+12     	; 0x2dfc <__divmodhi4_neg1>
    2df0:	00 20       	and	r0, r0
    2df2:	1a f4       	brpl	.+6      	; 0x2dfa <__divmodhi4_exit>

00002df4 <__divmodhi4_neg2>:
    2df4:	70 95       	com	r23
    2df6:	61 95       	neg	r22
    2df8:	7f 4f       	sbci	r23, 0xFF	; 255

00002dfa <__divmodhi4_exit>:
    2dfa:	08 95       	ret

00002dfc <__divmodhi4_neg1>:
    2dfc:	f6 f7       	brtc	.-4      	; 0x2dfa <__divmodhi4_exit>
    2dfe:	90 95       	com	r25
    2e00:	81 95       	neg	r24
    2e02:	9f 4f       	sbci	r25, 0xFF	; 255
    2e04:	08 95       	ret

00002e06 <_exit>:
    2e06:	f8 94       	cli

00002e08 <__stop_program>:
    2e08:	ff cf       	rjmp	.-2      	; 0x2e08 <__stop_program>
