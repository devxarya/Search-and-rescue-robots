/*
? * Team Id : 2018
? * Author List :Devvrat arya  and Deva harasha bolisetty
? * Filename: <Filename>
? * Theme: Search and rescue
? * Functions: 
? * Global Variables: These are listed below
? */

#define __OPTIMIZE__ -O0
#define F_CPU 14745600
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "lcd.h"

#include <math.h> //included to support power function

// Interrupt variables
volatile unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder
volatile unsigned long int ShaftCountRight = 0; //to keep track of right position encoder
volatile unsigned int Degrees; //to accept angle in degrees for turning

//Global variables
unsigned int value;
unsigned char ADC_Value;
unsigned char sharp;
unsigned int l=0,r=0;
unsigned int arena[9][9];
unsigned int orientation=3;   // 1 for horizontal, 0 for vertical
unsigned int num_white_block=0;

unsigned int S[3];

unsigned char Left_white_line = 0;
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;
unsigned char flag = 0;

unsigned int mid= 500/2;
 


unsigned int black;
unsigned int x_counter = 10;  
unsigned int y_counter = 5;   
unsigned int  counter=0;
unsigned int right_turns=0;   
unsigned int left_turns=1;  
signed int direction=0;

unsigned int next_y=0,next_x=0;

 unsigned int n=0;

unsigned num_plots=0;

// Navigaiton variable
unsigned int plot[9][9];
unsigned int block_log[11][11]={
	      { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
		  { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		  { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9}, 
	      { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		  { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},  
		  { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
	      { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
	      { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
          { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
	      { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		  { 9, 9, 9, 9, 9, 9, 9, 9 ,9, 9, 9}
           };
		   
unsigned int temp_path_log[11][11]={
		   { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9},
		   { 9, 9, 9, 9, 9, 9, 9, 9 ,9, 9, 9}
		   };
		   

// color sensor, rgb and zigbee variable
volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called
volatile unsigned long int no_ff;     // variable to store the pulse count when no_filter function is called

unsigned int data; //to store received data from UDR1

unsigned int value;
unsigned char ADC_Value;
unsigned char sharp;


unsigned int block_on_bot2;
unsigned int block_on_bot1;

unsigned int dest_x[9]={0,0,0,0,0,0,0,0,0};//{0,0,0,0,0,0,0,0,0}  {8,6,8,2,8,6,4,2}
unsigned int dest_y[9]={0,0,0,0,0,0,0,0,0};// {2,4,8,8,2,6,6,2}
unsigned int color[9]={0,0,0,0,0,0,0,0,0};   // {1,1,1,1,2,2,2,2}
unsigned int adj_x[4];  //x1 top, x2 right , x3 bottom , x4 left
unsigned int adj_y[4];
unsigned int wait=0,start;
unsigned int connection=0;

int x_turns,y_turns;


unsigned int s_next_x, s_next_y;
unsigned Iam_at=0 ;        //  0 start , 1 node , 2 mid_1
unsigned int packet[6]={0,0,0,0,0,0};
unsigned int search_x;
unsigned int search_y;

unsigned int index=0;
unsigned int d[4],best,alternate1,alternate2;
unsigned int patient=0;
unsigned int reached=1;
int servo=0;
 //1 for x, 2 for y
 unsigned int take_another_axis=0;

unsigned int plotORcamp=0; //0 for plot 1 for camp 
unsigned int stop_here;


/*
?The fucnction defined below is same as example
These functions are to provide basic functionality
For further detail line comments are present
*/


void motion_set (unsigned char Direct)
{
	unsigned char PortARestore = 0;

	Direct &= 0x0F; 			// removing upper nibble as it is not needed
	PortARestore = PORTA; 		// reading the PORTA's original status
	PortARestore &= 0xF0; 			// setting lower direction nibble to 0
	PortARestore |= Direct; 	// adding lower nibble for direction command and restoring the PORTA status
	PORTA = PortARestore; 			// setting the command to the port
}


void motor_init (void)
{
	DDRA = DDRA | 0x0F;
	PORTA = PORTA & 0xF0; 
	
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.

}

void timer5_init()
{
	TCCR5B = 0x00;	//Stop
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
}

void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor-50;
	OCR5BL = (unsigned char)right_motor-50;
}

void forward (void) //both wheels forward
{
	motion_set(0x06);
}

void back (void) //both wheels backward
{
	motion_set(0x09);
}

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
}

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
}


void stop (void) //hard stop
{
	motion_set(0x00);
}

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
}

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
}



void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
	sei();   // Enables the global interrupt
}

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
	sei();   // Enables the global interrupt
}

//ISR for right position encoder
ISR(INT5_vect)
{
	ShaftCountRight++;  //increment right shaft position count
}


//ISR for left position encoder
ISR(INT4_vect)
{
	ShaftCountLeft++;  //increment left shaft position count
}

ISR(INT0_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/4.090; // division by resolution to get shaft count 4.62
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
	ShaftCountRight = 0;
	ShaftCountLeft = 0;

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
		break;
	}
	stop(); //Stop robot
}


//Function used for moving robot forward by specified distance
void linear_distance_mm(unsigned int DistanceInMM)
	{
		float ReqdShaftCount = 0;
		unsigned long int ReqdShaftCountInt = 0;

		ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
		ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
		ShaftCountRight = 0;
		ShaftCountLeft = 0;
		while(1)
		{
			if(ShaftCountLeft > ReqdShaftCountInt)
			{  break;
			}
		}
		stop(); //Stop robot
	}

void forward_mm(unsigned int DistanceInMM)
	{
		forward();
		linear_distance_mm(DistanceInMM);
	}

void back_mm(unsigned int DistanceInMM)
	{
		back();
		linear_distance_mm(DistanceInMM);
	}

void left_degrees(unsigned int Degrees)
	{
		// 88 pulses for 360 degrees rotation 4.090 degrees per count
		left(); //Turn left
		angle_rotate(Degrees);
	}



void right_degrees(unsigned int Degrees)
	{
		// 88 pulses for 360 degrees rotation 4.090 degrees per count
		right(); //Turn right
		angle_rotate(Degrees);
	}



void lcd_port_config (void)
	{
	 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
	 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
	}

// Servo pin Configuration
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
}

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
	DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
	PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
}

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
	DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
	PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
}

void timer1_init(void)
{
 TCCR1B = 0x00; //stop
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR1H  = 0x03;	
 ICR1L  = 0xFF;
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}

void buzzer_pin_config (void)
	{
	 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
	 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
	}

void buzzer_on (void)
	{
		unsigned char port_restore = 0;
		port_restore = PINC;
		port_restore = port_restore | 0x08;
		PORTC = port_restore;
	}	 

void buzzer_off (void)
	{
		unsigned char port_restore = 0;
		port_restore = PINC;
		port_restore = port_restore & 0xF7;
		PORTC = port_restore;
	}

void ADC_init (void)
	{
		 DDRF = 0x00;
		 PORTF =  0x00;
		 ADCSRA = 0x00;
	     ADCSRB = 0x00;		//MUX5 = 0
		 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
	     ACSR = 0x80;
		 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
	}	

unsigned char ADC_Conversion(unsigned char Ch)
	{
		unsigned char a;
		if(Ch>7)
		{
			ADCSRB = 0x08;
		}
		Ch = Ch & 0x07;
		ADMUX= 0x20| Ch;
		ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
		while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
		a=ADCH;
		ADCSRA = ADCSRA|0x10;       //clear ADIF (ADC Interrupt Flag) by writing 1 to it
		ADCSRB = 0x00;
		return a;
	}




void Sharp (void)
	{
	DDRK = 0x00; //set PORTK direction as input
	PORTK = 0x00; //set PORTK pins floating
	}

void buzzer_init (void)
	{
		DDRC = DDRC | 0x08;		    //Setting PORTC 3 as output
		PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer	
	}

void print_sensor(char row, char coloumn,unsigned char channel)
	{
		
		ADC_Value = ADC_Conversion(channel);
		lcd_print(row, coloumn, ADC_Value, 3);
	}


unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
	distanceInt = (int)distance;

	if(distanceInt>800)
			{
				distanceInt=800;
			}
	return distanceInt;
}

//Color sensor and rgb LED
void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
}

void rgb_off(void)
{
	PORTH= PORTH &~ 0x60;
	PORTG= PORTG &~ 0x02;
	PORTL= PORTL &~ 0x80;
}

void rgb_config (void)
{
	DDRH = DDRH | 0x60; //Setting PortH 5,6 as output
	DDRG = DDRG | 0x02;  // Setting PortG 1 as output
	DDRL = DDRL | 0x80;
	rgb_off();
}

void red_on (void)  //rph6 gph5 bpg1
{
	rgb_off();
	PORTH = PORTH | 0x20;
}

void green_on (void)
{
	rgb_off();
	PORTH = PORTH | 0x40;
}

void blue_on (void)
{
	rgb_off();
	PORTL = PORTL | 0x80;
}

//Function To Initialize UART0
// desired baud rate:9600
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
	UCSR0A = 0x00;
	UCSR0C = 0x06;
	UBRR0L = 0x5F; //set baud rate lo
	UBRR0H = 0x00; //set baud rate hi
	UCSR0B = 0x98;
}

void rgb_test (void)
{
	while(1)
	{
		
	
	red_on();
	_delay_ms(1000);
	green_on();
	_delay_ms(1000);
	blue_on();
	_delay_ms(1000);
	}  
}

/************************************************************************/
/* Ports are initialized here, after it function are for specific purpose*/                                                         
/************************************************************************/
void port_init()
		{  
			motor_init(); //robot motion pins config
			buzzer_init();	
			left_encoder_pin_config(); //left encoder pin config
			right_encoder_pin_config(); //right encoder pin config
			left_position_encoder_interrupt_init();
			right_position_encoder_interrupt_init();
			
			ADC_init();
			lcd_port_config();
			timer5_init();
			
			rgb_config();
			uart0_init(); //Initailize UART0 for serial communiaction
			
			servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
			servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation
			servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation
			timer1_init(); //For servo PWM
		}




/*
? * Function Name: Block_buzzer
? * Input : None
? * Output : None
? * Logic: Buzzer On for 1 sec
? * in the function>
? * Example Call: block_buuzer();
? */
void block_buzzer (void)
{
	buzzer_on();                // Making buzzer sound for two seconds
	_delay_ms(1000);
	buzzer_off();
}

/*
? * Function Name: end_buzzer
? * Input : None
? * Output : None
? * Logic: Buzzer On for 10 sec
? * in the function>
? * Example Call: end_buuzer();
? */
void end_buzzer (void)
{
	buzzer_on();                // Making buzzer sound for two seconds
	_delay_ms(10000);
	buzzer_off() ;
}


/*
? * Function Name: Align_right
? * Input :none
? * Output : none
? * Logic: It rotates in right direction till the line is detected by central WL sensor
? * Example Call: align_right_1(void)
//Purpose: for aligning robot after scanning a plot in left
? */
// Align with black line present in right <alternate>
void align_right_1(void)
		{   
			velocity (200, 200);
			 right();
			 line_scan();
			
				while (S[2]==1)
         				{    
							 line_scan();
						}
	
			velocity (255, 255);
			stop();
		}

/*
? * Function Name: align_left_1
? * Input :none
? * Output : none
? * Logic: It rotates in left direction till the line is detected by central WL sensor
? * Example Call: align_left_1(void)
//Purpose: for aligning robot after scanning a plot in right
? */
void align_left_1(void)
{		
		     velocity (200,200);
		   left();
		   line_scan();
		   
		  while (S[2]==1)
					{
					  line_scan();
                     }
	
  velocity (255, 255);
  stop();
 
}


/*
? * Function Name: right_90_1
? * Input :none
? * Output : none
? * Logic: It rotates in right direction till the line is detected by central WL sensor
? * Example Call: align_right_1(void)
//Purpose: for aligning robot after scanning a plot in left
? */
// 90 degree right turn at intersection  <alternate>
void right_90_1(void)
{
	right_degrees(40);
	
	align_right_1();
	
}

/*
? * Function Name: left_90_1
? * Input :none
? * Output : none
? * Logic: It rotates in left direction till the line is detected by central WL sensor
? * Example Call: align_left_1(void)
//Purpose: for aligning robot after scanning a plot in right
? */
//90 degree lest turn at intersection <alternate>
void  left_90_1 (void)
{   left_degrees(40);
	align_left_1();	
}
  
  
/*
? * Function Name: scan_block
? * Input :none
? * Output : 1 or 0 ; 1 on block detected
? * Logic: It scans white or black block in front of robot
? * Example Call: scan_block(void)
? */
// if block is in range it return 1 otherwise zero
int scan_block (void)
{  unsigned int yes=0;
	for(int i=0;i<=5;i++)
	{	sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
		value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calculated in a variable "value".
	lcd_print(2,1,value,3);
	
	}
		
	if(value<180 && value>50)   //Check for block in a plot by distance
	{
		yes=1;                     // if yes=1 , block exist
 	}
	
	return yes;
}

/*
? * Function Name: Line_scan
? * Input :from three WL sensor
? * Output : A global arrray is set S[3] is set by this func
? * Logic: It scans black line on WL sensor
? * Example Call: line_scan();
? */
void line_scan(void)
{   unsigned int s[3];

 	s[1]=ADC_Conversion(3);  // Value of sensor 1 left
	s[2]=ADC_Conversion(2);
	s[3]=ADC_Conversion(1); //right
	
	
					if (s[1]<20)
							{ S[1]=1; } //variable is set to 1 ,if white
					else
							{ S[1]=0;  }  //if black
					
				 if (s[2]<20)
				         { S[2]=1; } //variable is set to 1 ,if white
				 else
				         { S[2]=0;  }  //if black
							   
							   
			    if (s[3]<20)
				         { S[3]=1; } //variable is set to 1 ,if white
			    else
			          	{ S[3]=0;  }  //if black
	
}	


/*
? * Function Name: Align_right
? * Input :none
? * Output : none
? * Logic: It rotates in right direction till the line is detected by central WL sensor
? * Example Call: align_right(void)
//Purpose: for aligning robot at a node
? */
void align_right(void)
{ 	velocity (150, 150);
	right();
    line_scan();
	
	while (S[2]==1)
	{
		line_scan();
	}
	
	velocity (255, 255);
	stop();
}

/*
? * Function Name: align_left
? * Input :none
? * Output : none
? * Logic: It rotates in left direction till the line is detected by central WL sensor
? * Example Call: align_left(void)
//Purpose: for aligning robot at node
? */
void align_left(void)
{
	velocity (150,150);
	left();
	line_scan();
	
	while (S[2]==1)
	{
		line_scan();
	}
	
	velocity (255, 255);
	stop();
	
}

 
/*
? * Function Name: right_90
? * Input :none
? * Output : none
? * Logic: It rotates in right direction till the line is detected by central WL sensor
? * Example Call: align_right_1(void)
//Purpose: for aligning robot after scanning a plot in left
? */
// 90 degree right at grid lines
 void right_90(void)
	 { 
		 right_degrees(40);
		 align_right();
	      right_turns++;
	  
	  }
 

/*
? * Function Name: left_90
? * Input :none
? * Output : none
? * Logic: It rotates in left direction till the line is detected by central WL sensor
? * Example Call: align_left_1(void)
? *///90 degree lest turn at intersection <alternate>


//90 degree turn left on grid lines
void  left_90 (void)
{   left_degrees(40);
//	_delay_ms(500);
	align_left();

  
   left_turns++;
}

void line_scan(void)
{   unsigned int s[3];

 	s[1]=ADC_Conversion(3);  // Value of sensor 1 left
	s[2]=ADC_Conversion(2);
	s[3]=ADC_Conversion(1); //right
	
	
					if (s[1]<20)
							{ S[1]=1; } //variable is set to 1 ,if white
					else
							{ S[1]=0;  }  //if black
					
				 if (s[2]<20)
				         { S[2]=1; } //variable is set to 1 ,if white
				 else
				         { S[2]=0;  }  //if black
							   
							   
			    if (s[3]<20)
				         { S[3]=1; } //variable is set to 1 ,if white
			    else
			          	{ S[3]=0;  }  //if black
	
}	


/*
? * Function Name: Align_right
? * Input :none
? * Output : none
? * Logic: It rotates in right direction till the line is detected by central WL sensor
? * Example Call: align_right(void)
//Purpose: for aligning robot at a node
? */
void align_right(void)
{ 	velocity (150, 150);
	right();
    line_scan();
	
	while (S[2]==1)
	{
		line_scan();
	}
	
	velocity (255, 255);
	stop();
}

/*
? * Function Name: align_left
? * Input :none
? * Output : none
? * Logic: It rotates in left direction till the line is detected by central WL sensor
? * Example Call: align_left(void)
//Purpose: for aligning robot at node
? */
void align_left(void)
{
	velocity (150,150);
	left();
	line_scan();
	
	while (S[2]==1)
	{
		line_scan();
	}
	
	velocity (255, 255);
	stop();
	
}

 
/*
? * Function Name: right_90
? * Input :none
? * Output : none
? * Logic: It rotates in right direction till the line is detected by central WL sensor
? * Example Call: align_right_1(void)
//Purpose: for aligning robot after scanning a plot in left
? */
// 90 degree right at grid lines
 void right_90(void)
	 { 
		 right_degrees(40);
		 align_right();
	      right_turns++;
	  
	  }
 

/*
? * Function Name: left_90
? * Input :none
? * Output : none
? * Logic: It rotates in left direction till the line is detected by central WL sensor
? * Example Call: align_left_1(void)
? *///90 degree lest turn at intersection <alternate>


//90 degree turn left on grid lines
void  left_90 (void)
{   left_degrees(40);
//	_delay_ms(500);
	align_left();

  
   left_turns++;
}


/*
? * Function Name: Increase counter
? * Input :none
? * Output : It is responsible for maintaitng all coordinates throughout traversing
? * Logic: Increse counter according to orientaion 
? * Example Call: increase_counter(void)
*/
void increase_counter (void)   
 { direction = right_turns-left_turns;
	if ( (direction==0 ) || (direction==4) || (direction == -4))
		{
			y_counter++;
			right_turns=0;
			left_turns=0;
			orientation=0;  // +y axis
		}
	
	 if ( (direction==1) || (direction== -3) )
		{
			x_counter++;
			orientation=1;  // +x axis
		}
   
    if (direction== -1 || direction == 3)
       {
		   x_counter--;
		   orientation=3; // -x axis
	   }
 
    if ( (direction==-2) || (direction ==2) )
       {
		 y_counter--;
		 orientation=2;   //-y axis
	   }
 }

/*
? * Function Name: Update_counter
? * Input :none
? * Output : Update orientation as per turns
? * Logic: Subtract  R and L turns
? * Example Call: increase_orientation(void)
*/
void update_orientation (void)
	{
		direction = right_turns-left_turns;
		if ( (direction==0 ) || (direction==4) || (direction == -4))
		{
			right_turns=0;
			left_turns=0;
			orientation=0;  // +y axis
		}
		
		if ( (direction==1) || (direction== -3) )
		{
			orientation=1;  // +x axis
		}
		
		if (direction== -1 || direction == 3)
		{
			orientation=3; // -x axis
		}
		
		if ( (direction==-2) || (direction ==2) )
		{
			orientation=2;   //-y axis
		}
		
	
	}

/*-
? * Function Name: follow_line
? * Input :none
? * Output :  Line following till node/Midpoint detected
? * Logic: Turn left if right sensor on right and inverse
? * Example Call: follow_line(void)
*/
void follow_line(void)   
	{       
		unsigned int stayOnLine=1;
		unsigned int flag1=0;
	
	    while(stayOnLine==1)
	
		{ 
		
           should_i_wait();
			Left_white_line   = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line  = ADC_Conversion(1); //Getting data of Right WL Sensor

			flag=0;

// 		print_sensor(1,1,3);	//Prints value of White Line Sensor1
// 		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
//      print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		
			if(Center_white_line>50) //0x10 -black
			{
				flag=1;
				forward();
				velocity(250,250);
			}

			if((Left_white_line<40) && (flag==0))
			{
				flag=1;
				forward();                            // value<0x14 means sensor on white
				velocity(260,175);
			}

			if((Right_white_line<40) && (flag==0))  
			{
				flag=1;
				forward();
				velocity(175,260);
			}

			if((Center_white_line>40 && Left_white_line>40 )||(Center_white_line>40 && Right_white_line>40))
			 {  
				 flag1++;
			 } 
	
	
			if (flag1==1)
						{
							stayOnLine=0;
							
							linear_distance_mm(65);
								flag1=0;
						}
	
		}			
		increase_counter();
}

/*-
? * Function Name: clear_path
? * Input :none
? * Output :  Reset the path log of robot
? * Example Call: Clear_path();
*/
 void clear_path(void)   //for making all elements of matrix zero
  { int i,j;
 	for(i=1;i<=9;i++)
 	 {
 		 for (j=1;j<=9;j++)
 		 {
 			 temp_path_log[i][j]=0;
 		 }
 	 }
 }
 

/*-
? * Function Name: next_cordinate
? * Input :orientation
? * Output :  next x-y cordintes in global var(next_x,next_y)
? * Logic: Add or subtract x-y as the direction of robot
? * Example Call: next_cordinate(1)
*/
 void next_cordinate (int my_orientation)
{ 
	my_orientation=orientation_overflow(my_orientation);
	if(my_orientation==0)
	{
		next_x=x_counter;
		next_y=y_counter+1;
	}
	
	if(my_orientation==1)
	{
	    next_x=x_counter+1;
		next_y=y_counter;		
	}
	
	if(my_orientation==2)
	{
		next_x=x_counter;
		next_y=y_counter-1;
	}
	
	if(my_orientation==3)
	{
		next_x=x_counter-1;
		next_y=y_counter;
	}	
}

/*-
? * Function Name: next_cordin
? * Input :orientation
? * Output :  next node x-y coordinates in global var(next_x,next_y)
? * Logic: Add or subtract x-y as the direction of robot
? * Example Call: next_node(2)
*/
 void next_node (int my_orientation)
 {
	 
	 if(my_orientation==0)
	 {
		 next_x=x_counter;
		 next_y=y_counter+2;
	 }
	 
	 if(my_orientation==1)
	 {
		 next_x=x_counter+2;
		 next_y=y_counter;
	 }
	 
	 if(my_orientation==2)
	 {
		 next_x=x_counter;
		 next_y=y_counter-2;
	 }
	 
	 if(my_orientation==3)
	 {
		 next_x=x_counter-2;
		 next_y=y_counter;
	 }
 }

/*-
? * Function Name: search_next_cordinate
? * Input :x-cord, y-cord, orientation
? * Output :  next x-y cordintes in global var(s_next_x,s_next_y)
? * Logic: Add or subtract x-y as the direction of robot
? * Example Call: search_next_cordinate(5,4,2)
*/
void search_next_cordinate (int x,int y,int my_orientation)
{
	
	if(my_orientation==0)
	{
		s_next_x=x;
		s_next_y=y+1;
	}
	
	if(my_orientation==1)
	{
		s_next_x=x+1;
		s_next_y=y;
	}
	
	if(my_orientation==2)
	{
		s_next_x=x;
		s_next_y=y-1;
	}
	
	if(my_orientation==3)
	{
		s_next_x=x-1;
		s_next_y=y;
	}
}

/*-
? * Function Name: nodeORmid
? * Input : x_counter and y_counter
? * Output :  1 for node and 2 for mid point
? * Logic: Obtained by dividing 2 
? * Example Call: nodeORmid(void)
*/

void nodeORmid (void)
{
	if( (x_counter%2) || (y_counter%2) )
      {
		  Iam_at= 2;      // midpoint and orientation x axis
	  }
    		
	 if ((x_counter%2) && (y_counter%2))
	 {
		 Iam_at= 1;        // at node
	 }	    
	 
}

/*-
? * Function Name: orientation_overflow
? * Input : orientation
? * Output : a suitable orientation (0-3)
? * Logic: orientation should between 0 to 3
? * Example: orientation_overflow(void)
*/
int orientation_overflow (int o)
{
	if (o==-1)
	{
		o=3;
	}
	if (o==4)
	{
		o==0;
	}
	return o;
}



/*
? * Function Name: Send_data
? * Input : x-cord , y_cord ,orienatiaion
? * Output : none
? * Logic: Mux data and send it to the other
? * Example: Send_data(void)
*/
void send_data(void)
{
	UDR0=100+orientation;
	UDR0=10*y_counter+x_counter;
}

/*
? * Function Name: Should_i_wait
? * Input :None
? * Output : None
? * Logic: Wait till seacrch passes
? * Example: Should_i_wait(void)
*/
void should_i_wait (void)
{ stop_here=1;
	int i;
		   next_cordinate(orientation);
		  if ((search_x==next_x) && (search_y==next_y))
		 { while (stop_here)
			 stop();	 
          }
		  
		  next_cordinate(orientation+1);
		 if ((search_x==next_x) && (search_y==next_y))
		  { while (stop_here)
			  stop();
		  }
		  
		  next_cordinate(orientation-1);
		  if ((search_x==next_x) && (search_y==next_y))
		  { while (stop_here)
			  stop();
		  }
		  
		  next_cordinate(orientation);
		  for (i=0;i<4;i++)
		  {
			 search_next_cordinate(next_x,next_y,i);
			 if ((search_x==s_next_x) && (search_y==s_next_y))
			 { while (stop_here)
				 stop();
			 }
		  }		 
}


//Ricieve signal 
SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{   
	data=UDR0;	

	demux_data();
}


/*
? * Function Name: demux_data
? * Input :None
? * Output : Set a global array packet[] after demuxing each digit
? * Logic: Wait till seacrch passes
? * Example: demux_data();
*/
void demux_data (void)
{
	if (data/100==0)
	{
		packet[0]=data%10;              //y           // 0-dest_x-dest_y
		packet[1]=(data%100-data%10)/10;//x
	}
	if (data/100==1)
	{
		
		packet[2]=data%10; //1-trigger-xx
		packet[3]=(data%100-data%10)/10;
		search_y=packet[2];
		search_x=packet[3];
		stop_here=0;
	}
	
	if (data/100==2)     // 2-color-trigger
	{
		packet[4]=data%10;             
		packet[5]=(data%100-data%10)/10;
		dest_x[index]=packet[1];
		dest_y[index]=packet[0];
		color[index]=packet[5];
        index++;	
	}
		
}


/*
? * Function Name: block_log_entry
? * Input :None
? * Output : Set a value in 2x2 array black_log
? * Logic: Wait till seacrch passes
? * Example: block_log_entry();
*/



void block_log_entry (void)
{ 
	   next_cordinate(orientation);
	   block_log[next_x][next_y]=8;
}


/*
? * Function Name: adjacent_point
? * Input :None
? * Output : Set adjacent point as per 
? * Example: adjacent_point();
*/
void adjacent_point (void)
{
	adj_x[0]= dest_x[patient];
	adj_y[0]= dest_y[patient]+1;
	
	adj_x[1]= dest_x[patient]+1;
	adj_y[1]=dest_y[patient];
	
	adj_x[2]= dest_x[patient];
	adj_y[2]= dest_y[patient]-1;
	
	adj_x[3]= dest_x[patient]-1;
	adj_y[3]= dest_y[patient];
	
}



/*
? * Function Name: adjacent_point
? * Input :None
? * Output : Set adjacent point as per
? * Example: adjacent_point();
*/
 void turn_to_plot (void)
{ int plot_direction=0; // -1 for right & +1 for left
  
unsigned int stop_here;
  next_cordinate(orientation_overflow(orientation+1));
  if ((next_x==dest_x[patient])&&(next_y==dest_y[patient]))
  {
	  plot_direction=-1;
  }
  next_cordinate(orientation_overflow(orientation-1));
  if ((next_x==dest_x[patient])&&(next_y==dest_y[patient]))
  {
	  plot_direction=1;
  }
  
 	 if (plot_direction==-1)
	 {
		 right_degrees(90);
		 		block_buzzer();
		 left_90_1();
	 }
	 if (plot_direction==1)
	 {
		 left_degrees(90);
		 		block_buzzer();
		 right_90_1();
	 }
}


/*
? * Function Name: transport_survivor 
? * Input :None
? * Output : robot will move forward 
? * Example: adjacent_point();
*/
void transport_survivor (void)
{
	forward_mm(150);
	rgb_off();
	block_buzzer();
	_delay_ms(5000);	
	back_mm(120);
    
}


void turn_to_camp (void)
{
	int plot_direction=0; // -1 for right & +1 for left
	
	next_cordinate(orientation_overflow(orientation+1));
	if ((next_x==10)&&(next_y==5))
	{
		plot_direction=-1;
	}
	next_cordinate(orientation_overflow(orientation-1));
	if ((next_x==10)&&(next_y==5))
	{
		plot_direction=1;
	}
	
	if (plot_direction==0)
	{
		transport_survivor();
	}
	
	if (plot_direction==-1)
	{
		right_degrees(90);
		transport_survivor();
		left_90_1();
	}
	if (plot_direction==1)
	{
		left_degrees(90);
		transport_survivor();
		right_90_1();
	}
}


// Input a desired orientaion , the bot will attain it
void get_me_this_orientatoin (unsigned int wanted_orientation)
{ unsigned int clear=1, o1,o2, o1_log, o2_log;
	while(clear)
	{		
		o1=orientation+1;
		o2=orientation-1;
		if (o1==4)
		{
			o1=0;
			
		}
		
		if ( o2==-1)
		{
			o2=3;
			
		}
		
		if (orientation==wanted_orientation)
		{
			clear=0;
		}
		
		else if (o1==wanted_orientation)
		{
			right_90();
		}
		
		else if (o2==wanted_orientation)
		{
			left_90();
		}
		
		else
		{
			next_cordinate(o1);
			o1_log=block_log[next_x][next_y];
			next_cordinate(o2);
			o2_log=block_log[next_x][next_y];
			if(o1_log>o2_log)
			{ left_90(); }
			else
			{
			right_90();
			}
				 	
		}
		
		update_orientation();
	}
}

int distance_of_medical_camp (int x,int y)
{ int b;
	b=abs(9-x)+abs(5-y);
	return b;
}

int distance_of_plot (int x, int y)
{ unsigned int b;
	b=abs(dest_x[patient]-x)+abs(dest_y[patient]-y);
	return b;
}

void find_a_way_to_plot (void)
{
     unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
	  for (i=0;i<4;i++)
	  {
		  next_cordinate(i);

		  blockings=block_log[next_x][next_y]+temp_path_log[next_x][next_y];
		  //lcd_print(2,11+i,blocnkings,1);
		  if (blockings==0)
		  {
			  next_node(i);
			  distance[i]= distance_of_plot(next_x,next_y);
		  }
		  else
		  {
			  next_node(i);
			  distance_of_plot(next_x,next_y);
			  distance[i]= distance_of_plot(next_x,next_y)+blockings*3;
		  }
	  }

	  for (i=0;i<4;i++)
	  {
		  
		  if (distance[i]<prev)
		  {
			  prev=distance[i];
			  result=i;
		  }
	  }
	  
	  wanted_orientation=result;
	  get_me_this_orientatoin(wanted_orientation);
	  
	  // 	 next_cordinate(result);
	  // 	 distance_of_plot(next_x,next_y);

}

void find_a_way_to_camp (void)
{ unsigned int i=0,j=0,blockings,distance[4],result, prev=100, wanted_orientation;
	for (i=0;i<4;i++)
	{
		next_cordinate(i);

		blockings=block_log[next_x][next_y]+temp_path_log[next_x][next_y];
		//lcd_print(2,11+i,blocnkings,1);
		if (blockings==0)
		{
			next_cordinate(i);
			distance[i]= distance_of_medical_camp(next_x,next_y);
		}
		else
		{
			next_cordinate(i);
			distance_of_medical_camp(next_x,next_y);
			distance[i]= distance_of_medical_camp(next_x,next_y)+blockings*4;
		}
	
	}
      lcd_string("x");
  for (i=0;i<4;i++)
	{
		
		if (distance[i]<prev)
		{
			prev=distance[i];
			result=i;
		}
	}
	
	wanted_orientation=result;
	get_me_this_orientatoin(wanted_orientation);
	
	// 	 next_cordinate(result);
	// 	 distance_of_plot(next_x,next_y);

}




void node_action (void)
{ int clear=1;
	while(clear)
	{   lcd_cursor(1,10);
		if (plotORcamp==0)
		{
			lcd_string("plot");
		    find_a_way_to_plot();
	
		}		
		
		if (plotORcamp==1)
		{
			lcd_string("camp");
			find_a_way_to_camp();
			
		}
		black=scan_block();
		if(black==1)
		{
			
			next_cordinate(orientation);
			block_log[next_x][next_y]=7;
		}
		else
		{
			clear=0;
		}
	}
}

void sort_array (void)
{
		unsigned int c_temp,x_temp,y_temp,iteration,prev,i;

	for(iteration=0;iteration<5;iteration++)
	{   prev=color[patient+1];
		i=patient+2;
		while (color[i])
			{
			if (color[i]<prev)
			   {    c_temp=color[i];
					x_temp=dest_x[i];
					y_temp=dest_y[i];
					color[i]=color[i-1];
					dest_x[i]=dest_x[i-1];
					dest_y[i]=dest_y[i-1];
					color[i-1]=c_temp;
					dest_x[i-1]=x_temp;
					dest_y[i-1]=y_temp;
	           }     
		prev=color[i];
		i=i+1;
	    }		
	}		

}

void go_to_medical_camp (void)
{ int flag=1,i;
	plotORcamp=1;
	clear_path();
	follow_line();
	while (flag)       //1
     {
		 
		 nodeORmid();
		 if(Iam_at==1)
		 {
		   node_action();
		   follow_line();
		 }		   
		   	 
		 if (Iam_at==2)
		 {
			 send_data();
			 temp_path_log[x_counter][y_counter]++;
			 follow_line();
			 if ((x_counter==9) && (y_counter==5))
			 {  
				 flag=0;
			 }
		 } 
	 }
	 	 
}

void MSR (void)
{
	if (color[patient]==1)
	{
		turn_to_plot();

	    go_to_medical_camp();
		turn_to_camp();
	}
	if (color[patient]==2)
	{
		turn_to_plot();
		servo++;

		rgb_off();
		block_buzzer();
	}
	
}

void plot_signal_wait (void)
{
  while(!(color[patient]))
  {
	  lcd_cursor(2,1);
	  lcd_string("wait");  
  }	
}

void is_all_patient_treated (void)
{
	if(patient==8)
	{
	reached=0;}
}

/*-
? *
? * Input :type of patient
? * Output :  Led glow accordingly
? *
? *
*/
void have_i_reached_plot (void)
{   unsigned int i;
	for (i=0;i<4;i++)
	{
		if((adj_x[i]==x_counter) && (adj_y[i]==y_counter) )
		{
			clear_path();
		    is_all_patient_treated();
			MSR();
			patient++;
			clear_path();
		}
	}
	if (reached && !plotORcamp)
	{
		temp_path_log[x_counter][y_counter]++;
		follow_line();
		
	}
	plotORcamp=0;

}

/*-
? *
? * Input :type of patient
? * Output :  Led glow accordingly
? *
? *
*/
void patient_led (void)
{
	if (color[patient]==1) //red_patient
	{
		red_on();
	}
	
	if (color[patient]==2) // greeen_patient
	{
		green_on();
	}
}
//Rescue robot..... 

int main (void)
{ 
	cli();
	port_init();
	sei();

           // clear matrix of arena

    lcd_set_4bit();
	lcd_init();


 unsigned int i;

while (color[0]==0)
{
	lcd_print(1,1,color[0],1);
}

follow_line();
while (reached)
          { 
			  for (i=0;i<8;i++)
			  	{
			  		lcd_print(1,1+i,dest_x[i],1);
			  		lcd_print(2,1+i,dest_y[i],1);
			  		lcd_print(1,9+i,color[i],1);
			  	}
		  
		  nodeORmid();
		 if (Iam_at==1) //node
		 {	 sort_array();
			 patient_led();
			 lcd_print(2,10,dest_x[patient],1);
			 lcd_string("x");
			 lcd_print(2,12,dest_y[patient],1);
			 
			 node_action();
			 follow_line();
	 	}

		 if (Iam_at==2)
	     {
			 send_data();
			 plot_signal_wait();
			 adjacent_point();
			 have_i_reached_plot();  
		 }				 
	}
end_buzzer();
}		

 
 

